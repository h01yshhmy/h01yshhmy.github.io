<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>231226T3</title>
    <url>/2023/12/26/231226T3/</url>
    <content><![CDATA[<p>没有链接，线下模拟赛题。</p>
<span id="more"></span>
<p>来自23年梦熊省选集训。</p>
<h2 id="问题描述">问题描述</h2>
<p>小 <span class="math inline">\(L\)</span> 是 Y
国的国王，这一天他派你去决定哪个城市应该设置为首都。Y 国一共有 <span
class="math inline">\(n\)</span>
个城市，城市之间有一些双向道路连接。当你确定好首都之后，小 <span
class="math inline">\(L\)</span>
还会派另外一个人在除了首都的另外一座城市建立防御工事，假设他的是等概率地选择，即选每座城市的概率都是
<span class="math inline">\(\frac {1} {n-1}\)</span>。</p>
<p>叛军未来会对 Y
国的首都发起袭击，而你身为叛军安插在国王身边的内鬼，知道叛军可能会按照
<span class="math inline">\(q\)</span> 种方案中的一种开始行动。在第
<span class="math inline">\(i\)</span> 种方案中，他们会在 <span
class="math inline">\(k_i\)</span>
个城市中准备一支军队，如果存在某条从这个城市到首都的路径，使得它不经过建立了防御工事的城市，那么这只军队会一路打到首都。显然，越多的军队能进攻首都，胜利的概率就越大。你的任务就是，对于所有的进攻方案，选择一个首都，使得能进攻首都的军队个数的期望值最大。你只要输出这个期望值乘以
<span class="math inline">\(n-1\)</span>
即可，容易发现这一定是一个整数。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入的第一行有三个数 <span
class="math inline">\(n,m,q\)</span>，分别表示城市的个数，道路的条数，和进攻方案数。</p>
<p>接下来 <span class="math inline">\(m\)</span> 行，每行两个数 <span
class="math inline">\(x_i,y_i\)</span>，表示第 <span
class="math inline">\(x_i\)</span> 个城市和第 <span
class="math inline">\(y_i\)</span>
个城市之间有一条双向道路相连。保证没有重边和自环。</p>
<p>接下来 <span class="math inline">\(q\)</span>
行，每一行表示一种方案。每种方案的第一个数 <span
class="math inline">\(k_i\)</span> 表示军队的个数。接下来 <span
class="math inline">\(k_i\)</span>
个数表示每支军队所在的城市，注意可能有一些军队在相同的城市。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出共 <span class="math inline">\(q\)</span>
行，对于每一种方案，输出最大的期望能进攻首都的军队个数乘以 <span
class="math inline">\(n-1\)</span> 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">2 2 4</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="数据范围">数据范围</h2>
<p>对于所有数据，满足 <span class="math inline">\(1 \leq n \leq 2 \times
10^5,1 \leq m \leq 5 \times 10^5,1 \leq q \leq 5 \times 10^5,\sum k_i
\leq 5 \times 10^5\)</span>，保证图连通。</p>
<h2 id="题解">题解</h2>
<p>期望乘上 <span
class="math inline">\(n-1\)</span>，相当于是在求全部防御工事方案的答案之和了。</p>
<p>显然，只有防御工事是割点的时候，才对答案有贡献。</p>
<p>对图求一个圆方树。</p>
<p>设关键点集合为 <span
class="math inline">\(S\)</span>，在圆方树上，如果首都为 <span
class="math inline">\(u\)</span>，设 <span
class="math inline">\(W(u,v)\)</span> 为圆方树上 <span
class="math inline">\(u\to v\)</span> 路径上的圆点个数（除去 <span
class="math inline">\(u,v\)</span> 自己），答案为 <span
class="math inline">\(k(n-1)-\sum_{v\in S}W(u,v)\)</span>。</p>
<p>为什么呢？首先做了一个容斥，数无法到达的个数。</p>
<p>显然这些路径上圆点显然都是割点，他们都在两个方点之间，那么这些割点作为防御工事的时候，<span
class="math inline">\(v\)</span> 一定无法达到 <span
class="math inline">\(u\)</span>，这是 <span
class="math inline">\(v\)</span>
自己的贡献。不需要和其他关键点去重之类的，对每个 <span
class="math inline">\(v\)</span> 都减去即可。</p>
<p>现在考虑怎么找到一个 <span class="math inline">\(u\)</span> 使得
<span class="math inline">\(\sum_{v\in S}W(u,v)\)</span> 最小。</p>
<p>看到类似于 <span class="math inline">\(f(u)=\sum_{v\in
D}dis(u,v)\)</span> 的最小化问题，想到重心。</p>
<p>关于为什么是重心：对于两个通过某方点连接的圆点 <span
class="math inline">\(p,q\)</span>，如果选择的首都从 <span
class="math inline">\(p\)</span> 移动到 <span
class="math inline">\(q\)</span> 会使和式更小，一定是因为 <span
class="math inline">\(p\)</span> 一侧的关键点个数少于 <span
class="math inline">\(q\)</span> 一侧（对于每个 <span
class="math inline">\(v\in S\)</span> 且在 <span
class="math inline">\(p\)</span> 左侧的 <span
class="math inline">\(W(u,v)\)</span>
都加了一，另一侧都减了一），而且这是互为充要的。所以说可以根据关键点个数移动首都：对于当前的
<span class="math inline">\(p\)</span>，要找一个相邻的 <span
class="math inline">\(q\)</span> 满足 <span
class="math inline">\(siz[p]-siz[q]&lt;siz[q]\)</span>，并移动到 <span
class="math inline">\(q\)</span>（<span
class="math inline">\(siz\)</span>
为块内圆点个数，这里对点的移动忽略方点圆点的烦人讨论），显然满足条件的
<span class="math inline">\(q\)</span>
至多存在一个，容易发现最终一定会移动到带权重心上。</p>
<p>首先对关键点建出虚树，显然 <span class="math inline">\(u\)</span>
至少要存在于虚树上或虚树的边上。我们需要虚树点数 <span
class="math inline">\(O(k)\)</span> 的性质来减少复杂度。</p>
<p>如果将虚树边上的点也加入虚树，设关键点点权为 <span
class="math inline">\(1\)</span>，其余为 <span
class="math inline">\(0\)</span>，那么最优首都就是虚树上重心。</p>
<p>进一步发现，如果首都在边上最优，那么这条边两边的块内关键点个数一定相等——不然向两侧移动可以使
<span class="math inline">\(\sum_{v\in S}W(u,v)\)</span> 更小。</p>
<p>既然是相等的情况，向两侧移动 <span class="math inline">\(\sum_{v\in
S}W(u,v)\)</span> 是不变的，那就不如放在虚树节点上好做了。</p>
<p>所以可以去掉虚树边上的点，直接对真虚树跑带权重心，就是最优点。</p>
<p>但是需要注意，虚树中有很多方点，那么重心也可能是方点，这样就需要移动重心。</p>
<p>首先，我们需要移动的方位一定是圆点多的部分，这样才能“平衡”。具体的，遍历虚树上和重心
<span class="math inline">\(u\)</span> 相邻的圆点 <span
class="math inline">\(v\)</span>，如果 <span
class="math inline">\(v\)</span> 在圆方树上深度比 <span
class="math inline">\(u\)</span> 浅，那圆方树上 <span
class="math inline">\(fa[u]\)</span>
可能为首都；否则，我们需要圆方树上找 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(v\)</span>
方向上的儿子，写一个树上祖先的倍增数组，从 <span
class="math inline">\(u\)</span> 调整到圆方树上 <span
class="math inline">\(v\)</span> 上方深度为“<span
class="math inline">\(u\)</span>
在圆方树上深度加一”的祖先。对所有可以调整到的点取一个最优即可，具体见代码。</p>
<p>时间复杂度 <span class="math inline">\(O(\sum k\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">600005</span>,M=<span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> dfn[N],tot,vis[N],h[N],cnt,num,dep[N],f[N][<span class="number">20</span>],n,m,q;</span><br><span class="line"><span class="type">int</span> siz[N],mx[N],a[N],b[N],sum,rt,u,v,k,val[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,nxt;&#125;e[M];vector&lt;<span class="type">int</span>&gt;c[N],g[N],G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[++cnt]=&#123;v,h[u]&#125;;h[u]=cnt;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Tarjan</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> dfn[N],low[N],vis[N],tot;stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++tot;vis[u]=<span class="number">1</span>;st.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">tarjan</span>(v);</span><br><span class="line">        low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">          num++;</span><br><span class="line">          <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="type">int</span> x=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();vis[x]=<span class="number">0</span>;</span><br><span class="line">            c[num].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(x==v)<span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          c[num].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u]=dep[fa]+<span class="number">1</span>;f[u][<span class="number">0</span>]=fa;dfn[u]=++tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v=g[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(dep[f[u][i]]&gt;=dep[v])u=f[u][i];</span><br><span class="line">  <span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  siz[u]=vis[u];mx[u]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v=G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,u);siz[u]+=siz[v];mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  mx[u]=<span class="built_in">max</span>(mx[u],sum-siz[u]);</span><br><span class="line">  <span class="keyword">if</span>(mx[u]&lt;mx[rt])rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="keyword">return</span> dep[u]+dep[v]<span class="number">-2</span>*dep[<span class="built_in">lca</span>(u,v)];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(dep[f[u][i]]&gt;=d)u=f[u][i];</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;capital.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;capital.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;u&gt;&gt;v,<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!Tarjan::dfn[i])Tarjan::<span class="built_in">tarjan</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c[i].<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">      g[n+i].<span class="built_in">emplace_back</span>(c[i][j]);</span><br><span class="line">      g[c[i][j]].<span class="built_in">emplace_back</span>(n+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tot=<span class="number">0</span>;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)cin&gt;&gt;a[i],b[i]=a[i],vis[b[i]]++;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+k+<span class="number">1</span>,cmp);<span class="type">int</span> tot=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)a[++tot]=<span class="built_in">lca</span>(a[i],a[i+<span class="number">1</span>]);a[++tot]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,cmp);</span><br><span class="line">    tot=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>)-a<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x=<span class="built_in">lca</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">      G[x].<span class="built_in">emplace_back</span>(a[i]);G[a[i]].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[rt=<span class="number">0</span>]=<span class="number">0x3f3f3f3f</span>;sum=k;<span class="built_in">dfs2</span>(a[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(rt&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> pos=<span class="number">0</span>;val[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[rt].<span class="built_in">size</span>();i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v=G[rt][i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]&lt;dep[rt])</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">int</span> now=f[rt][<span class="number">0</span>];</span><br><span class="line">          val[now]=sum-siz[rt];</span><br><span class="line">          <span class="keyword">if</span>(val[now]&gt;val[pos])pos=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">int</span> now=<span class="built_in">jump</span>(v,dep[rt]+<span class="number">1</span>);</span><br><span class="line">          val[now]=siz[v];</span><br><span class="line">          <span class="keyword">if</span>(val[now]&gt;val[pos])pos=now;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      rt=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>,val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)ans+=n<span class="number">-1</span>,val+=<span class="built_in">dis</span>(b[i],rt);</span><br><span class="line">    ans-=val/<span class="number">2</span>;cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)G[a[i]].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)vis[b[i]]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>虚树</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC132F</title>
    <url>/2023/12/01/ABC132F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc132_f">[ABC132F]
Small Products</a></p>
<span id="more"></span>
<p>虽然 <span class="math inline">\(n\)</span>
很大，但是还是考虑DP。</p>
<p>朴素的DP很好得到：</p>
<p><span class="math inline">\(f[i][j]\)</span> 表示长度 <span
class="math inline">\(i\)</span> 为的序列，序列末尾的数为 <span
class="math inline">\(j\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=\sum_{v=1}^{\lfloor\frac{n}{j}\rfloor}f[i-1][v]\\
&amp;g[i][j]=\sum_{v=1}^jf[i][v]\\
&amp;f[i][j]=g[i-1][\lfloor\frac{n}{j}\rfloor]\\
\end{aligned}
\]</span></p>
<p>（有时候填表法和刷表法都要写一写，笔者一直在考虑刷表的倍数形式
导致这题没做出来/ng）</p>
<p>即使前缀和优化，时空复杂度也均为 <span
class="math inline">\(O(nk)\)</span>，过不去。</p>
<p>看到这个分数下取整，可以想到一些根号算法：数论分块。</p>
<p>怎么做呢？</p>
<p>发现，如果有 <span
class="math inline">\(\lfloor\frac{n}{u}\rfloor=\lfloor\frac{n}{v}\rfloor\)</span>，那么
<span class="math inline">\(f[i][u]=f[i][v]\)</span>。</p>
<p>所以我们可以把每一种 <span
class="math inline">\(\lfloor\frac{n}{j}\rfloor\)</span>合并到一个<code>DP</code>状态里。</p>
<p>预处理出每一段的长度，转移时乘上长度即可。</p>
<p>设 <span class="math inline">\(cnt\)</span> 为块的个数，<span
class="math inline">\(f[i][j]\)</span> 为长度为<span
class="math inline">\(i\)</span>，最后一块的 <span
class="math inline">\(\lfloor\frac{n}{x}\rfloor=j\)</span>。</p>
<p>转移式子：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=len[j]\times g[i-1][cnt-j+1]\\
&amp;g[i][j]=g[i][j-1]+f[i][j]
\end{aligned}
\]</span></p>
<p><span class="math inline">\(cnt-j+1\)</span> 为 <span
class="math inline">\(\left\lfloor\dfrac{n}{\lfloor\frac{n}{x}\rfloor}\right\rfloor\)</span>
的编号，显然这是当前值为 <span
class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span>
的枚举上界。（数论分块值域乘除和编号加减相关，并左右对称）</p>
<p>时空复杂度均为 <span
class="math inline">\(O(k\sqrt{n})\)</span>，可以通过。</p>
<p>由于一些原因，数论分块的数组最好开二倍根号以上的空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">105</span>)</span>,<span class="title">sqN</span><span class="params">(<span class="number">80000</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[N][sqN],g[N][sqN];</span><br><span class="line"><span class="type">int</span> len[sqN],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),n);</span><br><span class="line">        len[++cnt]=r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        f[<span class="number">1</span>][i]=len[i];</span><br><span class="line">        g[<span class="number">1</span>][i]=(g[<span class="number">1</span>][i<span class="number">-1</span>]+f[<span class="number">1</span>][i])%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,cnt)&#123;</span><br><span class="line">            f[i][j]=len[j]*g[i<span class="number">-1</span>][cnt-j+<span class="number">1</span>]%Mod;</span><br><span class="line">            g[i][j]=(g[i][j<span class="number">-1</span>]+f[i][j])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;g[k][cnt]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>我会根号</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC138F</title>
    <url>/2024/01/01/ABC138F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc138_f">[ABC138F]
Coincidence</a></p>
<span id="more"></span>
<p>数位DP。</p>
<p>思考 <span class="math inline">\(y\;\textrm{mod}\;x=x\oplus
y\)</span> 有啥性质。</p>
<p>对于两种毫不相关的两种运算的等式，可以先考虑一些不等关系，
如：它们各自答案的值域，等号两侧在不同关系中的变量要求。</p>
<p>首先，题目有约束：<span class="math inline">\(x\le y\)</span>。</p>
<p>对于取模，很显然有 <span
class="math inline">\(y\;\textrm{mod}\;x&lt;x\)</span>。</p>
<p>位运算值域的约束可以考虑加减法规定界限，顺便加减法在取模上也有很好的性质：<span
class="math inline">\((y-x)\;\textrm{mod}\;x=y\;\textrm{mod}\;x\)</span>，不过在这题没啥用。</p>
<p>对于异或，从二进制位上考虑，显然：<span class="math inline">\(x\oplus
y\ge y-x\)</span>。</p>
<p>注意到，当 <span class="math inline">\(x\le y-x\)</span>
时，取模的最大值一定小于异或最小值，有 <span
class="math inline">\(y-x&gt;y\;\textrm{mod}\;x\)</span>。</p>
<p>当 <span class="math inline">\(x&gt;y-x\)</span> 时，有 <span
class="math inline">\(y-x=y\;\textrm{mod}\;x\)</span>，注意这里和上面的性质不一样，左边不是模意义。</p>
<p>可以发现，<span class="math inline">\(x\le y-x\)</span> 时没有合法
<span
class="math inline">\((x,y)\)</span>，而两个条件互斥且两条件的并是全集，那就只剩第二种情况。</p>
<p>问题转化为：找 <span class="math inline">\(y-x=x\oplus y\)</span> 的
<span class="math inline">\((x,y)\)</span> 对数。</p>
<p><span class="math inline">\(x&gt;y-x\)</span>，即 <span
class="math inline">\(2x&gt;y\)</span>。</p>
<p>由于 <span class="math inline">\(x\le
y\)</span>，在二进制中，容易发现 <span
class="math inline">\(x,y\)</span> 位数相同，方便我们数位 DP。</p>
<p>满足 <span class="math inline">\(y-x=x\oplus
y\)</span>，简单分讨可得，如果 <span class="math inline">\(y\)</span>
在某一位上为 <span class="math inline">\(1\)</span>，<span
class="math inline">\(x\)</span> 这一位 <span
class="math inline">\(0,1\)</span> 均可；否则 <span
class="math inline">\(x\)</span> 只能取 <span
class="math inline">\(0\)</span>。</p>
<p>这东西没法差分，那就将 <span class="math inline">\(L,R\)</span>
的约束放进状态。</p>
<p>设 <span class="math inline">\(F(i,down,up)\)</span> 为：<span
class="math inline">\(x,y\)</span> 都是二进制 <span
class="math inline">\(i\)</span> 位数，是否碰触到下边界 <span
class="math inline">\(L\)</span> 和上边界 <span
class="math inline">\(R\)</span> 的 <span
class="math inline">\((x,y)\)</span> 对数，转移过程很自然。</p>
<p>因为 <span class="math inline">\(x\)</span> 需要依照 <span
class="math inline">\(y\)</span> 来决定自己的 <span
class="math inline">\(0/1\)</span>，所以转移时先枚举 <span
class="math inline">\(y\)</span> 再枚举 <span
class="math inline">\(x\)</span>，数位 DP 经典记忆化一下即可通过。</p>
<p>答案为 <span class="math inline">\(\sum_i
F(i,down_0,up_0)\)</span>，<span class="math inline">\(i\)</span>
为合法的位数。</p>
<p>时间复杂度 <span class="math inline">\(O(AC)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">65</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> l,r,f[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> bl,br;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dn,<span class="type">int</span> up)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i][dn][up]!=<span class="number">-1</span>)<span class="keyword">return</span> f[i][dn][up];</span><br><span class="line">    f[i][dn][up]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dn)t1=(l&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(up)t2=(r&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="number">1</span>&amp;&amp;t2==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1==t2)&#123;</span><br><span class="line">        f[i][dn][up]+=<span class="built_in">DP</span>(i<span class="number">-1</span>,dn,up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        f[i][dn][up]+=<span class="built_in">DP</span>(i<span class="number">-1</span>,<span class="number">0</span>,up)+<span class="built_in">DP</span>(i<span class="number">-1</span>,dn,<span class="number">0</span>)+<span class="built_in">DP</span>(i<span class="number">-1</span>,dn,up);</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][dn][up]%=mod;</span><br><span class="line">    <span class="keyword">return</span> f[i][dn][up];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(l,r);</span><br><span class="line">    <span class="type">int</span> tl=l,tr=r;</span><br><span class="line">    <span class="keyword">while</span>(tl)&#123;bl++,tl&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(tr)&#123;br++,tr&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,bl,br)&#123;</span><br><span class="line">        ans+=<span class="built_in">DP</span>(i<span class="number">-1</span>,i==bl,i==br);</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>240116T1</title>
    <url>/2024/01/16/240116T1/</url>
    <content><![CDATA[<p>没有链接，模拟赛题。</p>
<span id="more"></span>
<h2 id="题面">题面</h2>
<p>有一个 <span class="math inline">\(01\)</span> 序列，初始全 <span
class="math inline">\(0\)</span>。</p>
<p>给定 <span class="math inline">\(m\)</span> 个 <span
class="math inline">\((l_i,r_i,s_i),i\in [1,m]\)</span>，如果序列的
<span class="math inline">\([l_i,r_i]\)</span> 中如果存在至少一个 <span
class="math inline">\(1\)</span>，将造成 <span
class="math inline">\(s_i\)</span> 的贡献。</p>
<p><span class="math inline">\(q\)</span> 次操作 <span
class="math inline">\((t_i,u_i,v_i),t_i\in\{0,1\},i\in[1,q]\)</span>，将
<span class="math inline">\([u_i,v_i]\)</span> 覆盖为 <span
class="math inline">\(t_i\)</span>，<strong>强制在线</strong>。</p>
<p>在每次操作后输出当前总贡献。</p>
<p><span class="math inline">\(1\le n,m,q\le 2\times 10^5,\,|s_i|\le
10^9\)</span>。</p>
<h2 id="题解">题解</h2>
<p>赛时少<code>erase</code>了一些段，没调出来，警钟长鸣。</p>
<p>先考虑贡献的处理方式。</p>
<p>至少存在一个 <span class="math inline">\(1\)</span>
不好数，容斥一步，考虑逆命题：全 <span
class="math inline">\(0\)</span>。</p>
<p>显然他们互斥且包含全部情况，用 <span class="math inline">\(\sum
s\)</span> 减去全 <span class="math inline">\(0\)</span> 的 <span
class="math inline">\(s_i\)</span> 之和就是答案。</p>
<p>对于一个全 <span class="math inline">\(0\)</span> 的极长连续段 <span
class="math inline">\([L,R]\)</span>，可以保证 <span
class="math inline">\(L\le l\le R,L\le r\le R\)</span> 的 <span
class="math inline">\((l,r)\)</span> 产生贡献。</p>
<p>将区间 <span class="math inline">\((l,r)\)</span>
看作点，就是二维数点的形式，每次数矩形 <span
class="math inline">\((L,L),(R,R)\)</span>（副对角线）
内带权点个数，我们记为 <span class="math inline">\(w(L,R)\)</span>。</p>
<p>注意到没有对这个二维坐标系的任何修改，不需要树套树，主席树即可。</p>
<p>注：有个小优化，可以把 <span class="math inline">\(r\)</span>
放到主席树时间轴上，这样就不需要差分。因为有 <span
class="math inline">\(l\le r\)</span> 的保证，在第 <span
class="math inline">\(l\)</span> 棵线段树前不存在能贡献到 <span
class="math inline">\([l,r]\)</span> 的点。直接查询第 <span
class="math inline">\(r\)</span> 棵树的 <span
class="math inline">\([l,r]\)</span> 区间和就是 <span
class="math inline">\(w(l,r)\)</span>。</p>
<p>现在考虑区间覆盖怎么做。</p>
<p>划分颜色段，做区间覆盖，容易想到珂朵莉树。</p>
<p>重点在于对贡献的处理，需要一些珂朵莉树的“熟练度”。</p>
<p>容易发现，<span class="math inline">\(w(L,p)+w(p+1,R)\ne
w(L,R)\)</span>，我们不能简单结合贡献。</p>
<p><code>split</code> 时，如果分裂 <span
class="math inline">\(0\)</span> 段，可以先删掉 <span
class="math inline">\(w(L,R)\)</span>，加上 <span
class="math inline">\(w(L,p)+w(p+1,R)\)</span>，因为 <span
class="math inline">\([L,R]\)</span>
在覆盖后一定不会是<strong>极长</strong>且<strong>为零</strong>的段，所以可以先拆了，这样好写很多。</p>
<p><code>assign</code>时，对于两个相邻的 <span
class="math inline">\(0\)</span>
段，我们需要手动将它们合并，删去原有贡献，加入新贡献，覆盖一整个极长连续
<span class="math inline">\(0\)</span> 段。注意删除元素最好缓冲一下，用
<code>vector</code>
存需要删除的元素统一删除，不然容易出现各种迭代器问题！</p>
<p>具体细节见代码。</p>
<p>因为只有区间覆盖，颜色段个数有严格保障，珂朵莉树复杂度不依赖于随机数据。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, op, Op, Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, s;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> pos &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; rhs.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll siz;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N], tnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> pre, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  now = ++tnt;</span><br><span class="line">  tr[now].l = tr[pre].l, tr[now].r = tr[pre].r, tr[now].siz = tr[pre].siz + w;</span><br><span class="line">  <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid = (l +r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">update</span>(tr[now].l, tr[pre].l, l, mid, p, w);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">update</span>(tr[now].r, tr[pre].r, mid + <span class="number">1</span>, r, p, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dl &lt;= l &amp;&amp; r &lt;= dr) &#123;</span><br><span class="line">    ll res = tr[now].siz;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(dl &lt;= mid) res = <span class="built_in">query</span>(tr[now].l, l, mid, dl, dr);</span><br><span class="line">  <span class="keyword">if</span>(dr &gt; mid) res += <span class="built_in">query</span>(tr[now].r, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;pos&gt;s;</span><br><span class="line">ll ans, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>((pos)&#123;<span class="number">0</span>, now, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span>(it != s.<span class="built_in">end</span>() &amp;&amp; it-&gt;r == now) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> l = it-&gt;l, r = it-&gt;r, x = it-&gt;s;</span><br><span class="line">  s.<span class="built_in">erase</span>(it);</span><br><span class="line">  s.<span class="built_in">insert</span>((pos)&#123;l, now, x&#125;);</span><br><span class="line">  s.<span class="built_in">insert</span>((pos)&#123;now+<span class="number">1</span>, r, x&#125;); </span><br><span class="line">  <span class="keyword">if</span>(!x) ans -= <span class="built_in">query</span>(rt[r], <span class="number">1</span>, n, l, r);</span><br><span class="line">  <span class="keyword">if</span>(!x) ans += <span class="built_in">query</span>(rt[now], <span class="number">1</span>, n, l, now) + <span class="built_in">query</span>(rt[r], <span class="number">1</span>, n, now+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> itl = s.<span class="built_in">upper_bound</span>((pos)&#123;<span class="number">0</span>, l<span class="number">-1</span>, <span class="number">0</span>&#125;), itr = s.<span class="built_in">upper_bound</span>((pos)&#123;<span class="number">0</span>, r, <span class="number">0</span>&#125;);</span><br><span class="line">  vec.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = itl; it != itr; ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span>(it-&gt;s == <span class="number">0</span>) ans -= <span class="built_in">query</span>(rt[it-&gt;r], <span class="number">1</span>, n, it-&gt;l, it-&gt;r);</span><br><span class="line">    vec.<span class="built_in">pb</span>(it-&gt;r);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span>(itl != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">    --itl;</span><br><span class="line">    <span class="keyword">if</span>(itl-&gt;s == x) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!x) ans -= <span class="built_in">query</span>(rt[itl-&gt;r], <span class="number">1</span>, n, itl-&gt;l, itl-&gt;r);</span><br><span class="line">      l = itl-&gt;l;</span><br><span class="line">      s.<span class="built_in">erase</span>(itl);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(itr != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(itr-&gt;s == x) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!x) ans -= <span class="built_in">query</span>(rt[itr-&gt;r], <span class="number">1</span>, n, itr-&gt;l, itr-&gt;r);</span><br><span class="line">      r = itr-&gt;r;</span><br><span class="line">      s.<span class="built_in">erase</span>(itr);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i : vec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>((pos)&#123;<span class="number">0</span>, i, <span class="number">0</span>&#125;);</span><br><span class="line">    s.<span class="built_in">erase</span>(it);</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="built_in">insert</span>((pos)&#123;l, r, x&#125;);</span><br><span class="line">  <span class="keyword">if</span>(!x) ans += <span class="built_in">query</span>(rt[r], <span class="number">1</span>, n, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll sum;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen(&quot;class.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">  <span class="comment">// freopen(&quot;class.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(Op);</span><br><span class="line">  <span class="built_in">re</span>(i, m) &#123;</span><br><span class="line">    <span class="built_in">read</span>(p[i].l),<span class="built_in">read</span>(p[i].r), <span class="built_in">read</span>(p[i].s);</span><br><span class="line">    <span class="keyword">if</span>(p[i].l &gt; p[i].r) <span class="built_in">swap</span>(p[i].l, p[i].r);</span><br><span class="line">    ans += p[i].s;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = ans;</span><br><span class="line">  <span class="built_in">sort</span>(p + <span class="number">1</span>, p + m + <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    rt[i] = rt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(now &lt;= m &amp;&amp; p[now].r == i) &#123;</span><br><span class="line">      <span class="built_in">update</span>(rt[i], rt[i], <span class="number">1</span>, n, p[now].l, p[now].s);</span><br><span class="line">      ++now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(Q);</span><br><span class="line">  s.<span class="built_in">insert</span>((pos)&#123;<span class="number">1</span>, n, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">    ll l, r;</span><br><span class="line">    <span class="built_in">read</span>(op), <span class="built_in">read</span>(l), <span class="built_in">read</span>(r);</span><br><span class="line">    l ^= (<span class="number">1ll</span> * Op * lst), r ^= (<span class="number">1ll</span> * Op * lst);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">   	<span class="built_in">split</span>(r);</span><br><span class="line">   	<span class="keyword">if</span>(l != <span class="number">1</span>) <span class="built_in">split</span>(l<span class="number">-1</span>);</span><br><span class="line">   	<span class="built_in">solve</span>(l, r, op);</span><br><span class="line">   	<span class="built_in">outn</span>(sum - ans);</span><br><span class="line">    lst = sum - ans; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>ODT</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC127E</title>
    <url>/2023/12/01/ABC127E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc127_e">[ABC127E] Cell
Distance</a></p>
<span id="more"></span>
<p>首先发现行和列可以拆开算。</p>
<p>考虑拆贡献，计算行上两点距离为 <span class="math inline">\(i\)</span>
的线段的个数：<span class="math inline">\((n-i)\times
m^2\)</span>，单个对答案的贡献为 <span
class="math inline">\(i\)</span>。</p>
<p>因为距离为 <span class="math inline">\(i\)</span> 的线段可以放 <span
class="math inline">\(n-i\)</span> 个，然后两个点的 <span
class="math inline">\(y\)</span> 值随便取，共 <span
class="math inline">\(m^2\)</span> 种。</p>
<p>列同理。</p>
<p>最终答案为：</p>
<p><span
class="math inline">\((m^2\times\sum\limits_{i=1}^{n-1}i(n-i)+n^2\times\sum\limits_{i=1}^{m-1}i(m-i))\dbinom{n\times
m-2}{k-2}\)</span></p>
<p>最后的组合数：剩下的 <span class="math inline">\(k-2\)</span> 个点在
<span class="math inline">\(n\times m-2\)</span> 个空位内随意选。</p>
<p>此类算全部总方案的题一般都是拆贡献。不要考虑最终点的分布，想最好算的（两个点情况）然后数出所有可能就好了。</p>
<p>一项内一般只贡献一个小部分的答案，不会出现重复计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=inv[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[m]%Mod*inv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*i*(n-i)%Mod*m%Mod*m%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*i*(m-i)%Mod*n%Mod*n%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*<span class="built_in">C</span>(n*m<span class="number">-2</span>,k<span class="number">-2</span>)%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC162E</title>
    <url>/2023/12/01/ABC162E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc162_e">[ABC162E] Sum
of gcd of Tuples (Hard)</a></p>
<span id="more"></span>
<p><span class="math inline">\(\gcd(a[j])=bx\)</span> 的充要条件是 <span
class="math inline">\(a[j]\)</span> 都是 <span
class="math inline">\(x\)</span> 的倍数。</p>
<p>设 <span class="math inline">\(f_i\)</span> 是 <span
class="math inline">\(\gcd(a[j])\)</span> 为 <span
class="math inline">\(i\)</span> 的数列个数。</p>
<p><span
class="math inline">\(f_i=\lfloor\frac{k}{i}\rfloor^n-\sum\limits_{j=2}^{\lfloor\frac{k}{i}\rfloor
}f_{i\times j}\)</span>。</p>
<p>前一项为任选的倍数，通过快速幂<span class="math inline">\(O(\log
n)\)</span>，后一项为减掉 <span class="math inline">\(gcd(a[j])=mi,m\ge
2\)</span> 的个数，调和级数 <span class="math inline">\(O(\ln
k)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(k\log n+k\ln
k)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,f[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">pe</span>(i,k)&#123;</span><br><span class="line">        f[i]=<span class="built_in">qpow</span>(k/i,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=k;j+=i)&#123;</span><br><span class="line">            f[i]=(f[i]-f[j]+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,k)&#123;</span><br><span class="line">        ans=(ans+f[i]*<span class="number">1ll</span>*i%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC242F</title>
    <url>/2023/12/01/ABC242F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc242_f">[ABC242F]
Black and White Rooks</a></p>
<span id="more"></span>
<p>计数，先考虑放车的性质。</p>
<p>发现题目的要求实质上是：同一行/列内只能有一种颜色。</p>
<p>因为只要有两种颜色就一定有分界点，可以互相攻击。</p>
<p>显然的思路：枚举黑色用了 <span class="math inline">\(i\)</span> 行
<span class="math inline">\(j\)</span> 列。</p>
<p>可能会有一些比较naive的想法，直接乘上组合数求个和之类。</p>
<p>但稍加思考 直接组合数显然会出现放不满行列的情况，会算重。</p>
<p>所以要容斥。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为恰好黑色的放了
<span class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数，<span
class="math inline">\(g[i][j]\)</span> 为黑色的至多放了 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数。（<span
class="math inline">\(f,g\)</span>
这里均只考虑黑色方案，白色先不管，且均不含行列在总共 <span
class="math inline">\(n,m\)</span> 个中的位置的贡献）</p>
<p>有二项式反演：</p>
<p><span class="math display">\[
\begin{aligned}
g[n][m]&amp;=\sum_{i=1}^n\sum_{j=1}^m\binom{n}{i}\binom{m}{j}f[i][j]\\
f[n][m]&amp;=\sum_{i=1}^n(-1)^{n-i}\binom{n}{i}\sum_{j=1}^m(-1)^{m-j}\binom{m}{j}g[i][j]\\
&amp;=\sum_{i=1}^n\sum_{j=1}^m(-1)^{n+m-i-j}\binom{n}{i}\binom{m}{j}g[i][j]
\end{aligned}
\]</span></p>
<p>那么 <span class="math inline">\(g\)</span> 好算吗？很好算。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;g[i][j]=\dbinom{i\times j}{B}
\end{aligned}
\]</span></p>
<p>交叉点上随便选。</p>
<p>最终答案需要考虑上白色的方案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;Ans=\sum_{i=1}^n\sum_{j=1}^m\binom{n}{i}\binom{m}{j}f[i][j]\times\dbinom{(n-i)(m-j)}{W}
\end{aligned}
\]</span></p>
<p>容易理解：剩下 <span class="math inline">\((n-i)(m-j)\)</span>
个位置随意选都合法。</p>
<p>因为 <span class="math inline">\(f\)</span>
的状态设计为“恰好方案”，所有不重不漏。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2m^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">55</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,B,W;</span><br><span class="line"><span class="type">int</span> fac[N*N],ifac[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2500</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,m,B,W);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            g[i][j]=<span class="built_in">C</span>(i*j,B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(u,n)<span class="built_in">re</span>(v,m)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,u)<span class="built_in">re</span>(j,v)&#123;</span><br><span class="line">            op=((u+v-i-j)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">            f[u][v]=(f[u][v]+<span class="number">1ll</span>*op*<span class="built_in">C</span>(u,i)*<span class="built_in">C</span>(v,j)%Mod*g[i][j]%Mod+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            ans=(ans+<span class="number">1ll</span>*<span class="built_in">C</span>(n,i)*<span class="built_in">C</span>(m,j)%Mod*f[i][j]%Mod*<span class="built_in">C</span>((n-i)*(m-j),W)%Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>反演</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC277Ex</title>
    <url>/2023/12/21/ABC277Ex/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc277_h">[ABC277Ex]
Constrained Sums</a></p>
<span id="more"></span>
<p>构造也是可以图论的！</p>
<p>两个条件，显然第二个条件比较有用，将两个不等式分开看，现在一个是变量大于等于定量，一个是变量小于等于定量，我们要想办法搞出两个式子，在两个式子里分别做<strong>统一的符号</strong>，有结论：
<span class="math display">\[
\begin{aligned}
&amp;L\le x_i+x_j\Leftrightarrow\forall t\in\mathbb{Z},t\le x_i\lor
L-t+1\le x_j\\
&amp;x_i+x_j\le R\Leftrightarrow\forall t\in\mathbb{Z},t&gt;x_i\lor
R-t+1&gt;x_j
\end{aligned}
\]</span> 证明：</p>
<p>若 <span class="math inline">\(\exists t\in\mathbb{Z},t&gt;x_i\land
L-t+1&gt;x_j\)</span>，有<span class="math inline">\(\exists
t\in\mathbb{Z},t\ge x_i+1\land L-t+1\ge x_j+1\)</span>。</p>
<p>将 <span class="math inline">\(\land\)</span> 两边两式相加，得 <span
class="math inline">\(L-1\ge x_i+x_j\)</span> 即 <span
class="math inline">\(L&gt;x_i+x_j\)</span>，所以 <span
class="math inline">\(L&gt;x_i+x_j\Leftarrow \exists
t\in\mathbb{Z},t&gt;x_i\land L-t+1&gt;x_j\)</span>。</p>
<p>若 <span class="math inline">\(L&gt;x_i+x_j\)</span>，当 <span
class="math inline">\(t=x_i+1\)</span> 时，满足 <span
class="math inline">\(t&gt;x_i\land L-t+1&gt;x_j\)</span>，所以 <span
class="math inline">\(L&gt;x_i+x_j\Rightarrow \exists
t\in\mathbb{Z},t&gt;x_i\land L-t+1&gt;x_j\)</span>。</p>
<p>综上，<span class="math inline">\(L&gt;x_i+x_j\Leftrightarrow \exists
t\in\mathbb{Z},t&gt;x_i\land L-t+1&gt;x_j\)</span>，可得：<span
class="math inline">\(L\le x_i+x_j\Leftrightarrow\forall
t\in\mathbb{Z},t\le x_i\lor L-t+1\le x_j\)</span>。</p>
<p>同理可证 <span class="math inline">\(x_i+x_j\le
R\Leftrightarrow\forall t\in\mathbb{Z},t&gt;x_i\lor
R-t+1&gt;x_j\)</span>。</p>
<p>两个结论中，<span class="math inline">\(\lor\)</span>
两侧的符号都可以统一成 <span class="math inline">\(\le\)</span>（<span
class="math inline">\(&gt;\)</span> 就取反一下）。</p>
<p>对于“或”命题，考虑 2-SAT。</p>
<p>设 <span class="math inline">\((i,j)\)</span> 表示 <span
class="math inline">\(j\le x_i\)</span> 是否为真，<span
class="math inline">\((i,j,0/1)\)</span>
分别对应代表“假”或“真”的点。</p>
<p>有 <span class="math inline">\(\forall
i\in[1,n],x_i\in[0,M]\)</span>，所以 <span
class="math inline">\((i,0)\)</span> 一定为真，<span
class="math inline">\((i,m+1)\)</span> 一定为假，至于 <span
class="math inline">\(j\in(-\infty,0)\cup(m+1,+\infty)\)</span>，就不用讨论了。</p>
<p>2-SAT 的边都是“如果那么”的关系，所以根据定义，<span
class="math inline">\((i,j,1)\to (i,j-1,1)\)</span> 和 <span
class="math inline">\((i,j,0)\to (i,j+1,0)\)</span> 是需要连边的。</p>
<p>然后对于 <span class="math inline">\(Q\)</span>
个限制，再去连边。<span class="math inline">\(M\)</span> 很小，每次枚举
<span class="math inline">\(t\)</span>，对 <span
class="math inline">\(a_i,b_i\)</span>
连对应的边即可，具体见代码，没啥好说的。</p>
<p>对于构造方案，直接枚举，放点合法的就行。</p>
<p>总边数和复杂度均为 <span
class="math inline">\(O((N+Q)M)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">7</span>, M = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, dfn_cnt, scc_cnt, top, dfn[M], low[M], sta[M], scc[M], ans[N];</span><br><span class="line"><span class="type">bool</span> vis[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> z * (m + <span class="number">2</span>) * n + (y - <span class="number">1</span>) * (m + <span class="number">2</span>) + x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++dfn_cnt;</span><br><span class="line">    sta[++top] = u, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[v])</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        ++scc_cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">-1</span>; t != u;) &#123;</span><br><span class="line">            t = sta[top--];</span><br><span class="line">            vis[t] = <span class="number">0</span>;</span><br><span class="line">            scc[t] = scc_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        G[<span class="built_in">id</span>(<span class="number">0</span>, i, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(<span class="number">0</span>, i, <span class="number">1</span>));</span><br><span class="line">        G[<span class="built_in">id</span>(m + <span class="number">1</span>, i, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(m + <span class="number">1</span>, i, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">re</span>(j, m + <span class="number">1</span>) &#123;</span><br><span class="line">            G[<span class="built_in">id</span>(j, i, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(j - <span class="number">1</span>, i, <span class="number">1</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(j - <span class="number">1</span>, i, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(j, i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, q) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="built_in">re</span>(x, m) &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">min</span>(m + <span class="number">1</span>, <span class="built_in">max</span>(<span class="number">0</span>, l + <span class="number">1</span> - x));</span><br><span class="line">            G[<span class="built_in">id</span>(x, a, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(y, b, <span class="number">1</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(y, b, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(x, a, <span class="number">1</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(x, b, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(y, a, <span class="number">1</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(y, a, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(x, b, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">re</span>(x, m) &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">min</span>(m + <span class="number">1</span>, <span class="built_in">max</span>(<span class="number">0</span>, r + <span class="number">1</span> - x));</span><br><span class="line">            G[<span class="built_in">id</span>(x, a, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(y, b, <span class="number">0</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(y, b, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(x, a, <span class="number">0</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(x, b, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(y, a, <span class="number">0</span>));</span><br><span class="line">            G[<span class="built_in">id</span>(y, a, <span class="number">1</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(x, b, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot = (m + <span class="number">2</span>) * n * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, tot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scc[<span class="built_in">id</span>(j, i, <span class="number">0</span>)] == scc[<span class="built_in">id</span>(j, i, <span class="number">1</span>)]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (scc[<span class="built_in">id</span>(j, i, <span class="number">1</span>)] &lt; scc[<span class="built_in">id</span>(j, i, <span class="number">0</span>)]) ans[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构造</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC277G</title>
    <url>/2024/01/05/ABC277G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc277_g">[ABC277G]
Random Walk to Millionaire</a></p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/CF235B">Let's Play Osu!</a>
的图上游走版本。</p>
<p>有最朴素 DP：</p>
<p>设 <span class="math inline">\(f(u,i,j)\)</span>：到点 <span
class="math inline">\(u\)</span>，已经走了 <span
class="math inline">\(i\)</span> 步，目前等级为 <span
class="math inline">\(j\)</span> 时的期望 <span
class="math inline">\(\sum X^2\)</span>。</p>
<p>答案是 <span class="math inline">\(\sum_{u,j}f(u,K,j)\)</span>。</p>
<p>立方的复杂度，太慢。</p>
<p>设某个时刻到达某个点等级为 <span class="math inline">\(i\)</span>
的概率为 <span
class="math inline">\(p_i\)</span>，那么到这个点的贡献就是 <span
class="math inline">\(\sum i^2p_i\)</span>。</p>
<p>在之后，如果遇到一个等级加一，贡献变成 <span
class="math inline">\(\sum (i+1)^2p_i\)</span>。</p>
<p>做差，<span class="math inline">\(\sum ((i+1)^2-i^2)p_i=\sum
(2i+1)p_i\)</span>。</p>
<p>贡献增加了这些，考虑等级升级的时候 <span
class="math inline">\(2i+1\)</span> 怎么变化。</p>
<p>显然每次会增加 <span class="math inline">\(2\sum
p_i\)</span>，维护一个 <span class="math inline">\(E(\sum p_i),E(\sum
(2i+1)p_i),E(\sum 1)\)</span>，就可以得到答案了。</p>
<p><span class="math inline">\(\sum 1\)</span> 其实就是“和式的长度”
或者说贡献序列的长度，就是期望的 <span
class="math inline">\(C_i=1\)</span> 次数。</p>
<p>注意贡献序列长度会影响其他两项，<span
class="math inline">\(p_i\)</span> 的下标 <span
class="math inline">\(i\)</span> 范围其实就是这个长度。</p>
<p>时间复杂度 <span class="math inline">\(O(nK)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y), g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; c[i];</span><br><span class="line">    e1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ind[i] = <span class="built_in">Pow</span>(g[i].<span class="built_in">size</span>(), P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) </span><br><span class="line">                <span class="keyword">if</span> (c[u] || (i == <span class="number">1</span> &amp;&amp; u == <span class="number">1</span>)) </span><br><span class="line">                    <span class="built_in">add</span>(e1[i][v], <span class="number">1ll</span> * e1[i - <span class="number">1</span>][u] * ind[u] % P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">                <span class="built_in">add</span>(ep[i][v], <span class="number">1ll</span> * ep[i - <span class="number">1</span>][u] * ind[u] % P);</span><br><span class="line">                <span class="built_in">add</span>(e2i1[i][v], <span class="number">1ll</span> * e2i1[i - <span class="number">1</span>][u] * ind[u] % P);</span><br><span class="line">                <span class="built_in">add</span>(f[i][v], <span class="number">1ll</span> * f[i - <span class="number">1</span>][u] * ind[u] % P);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (c[j]) <span class="built_in">add</span>(ans, <span class="number">1ll</span> * f[i][j] % P);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(e2i1[i][j], <span class="number">2ll</span> * ep[i][j] % P);</span><br><span class="line">                <span class="built_in">add</span>(e2i1[i][j], e1[i][j]);</span><br><span class="line">                <span class="built_in">add</span>(f[i][j], e2i1[i][j]);</span><br><span class="line">                <span class="built_in">add</span>(ep[i][j], e1[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC282Ex</title>
    <url>/2023/12/30/ABC282Ex/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc282_h">[ABC282Ex] Min
+ Sum</a></p>
<span id="more"></span>
<p>最小值很烦人，那就让最小值不变。</p>
<p>分治。以最小值位置为分治的 <span
class="math inline">\(mid\)</span>，处理跨过 <span
class="math inline">\(mid\)</span>
的区间。找最小值位置通过ST表处理。</p>
<p>这样是一个虚拟笛卡尔树，启发式分裂，枚举短的那一边，另一边的合法个数只需要考虑
<span class="math inline">\(\sum B\)</span>，<span
class="math inline">\(B_i\ge
0\)</span>，单调的，可以直接在前缀和数组上二分。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，证明不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, S;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200005</span>], b[<span class="number">200005</span>], s[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> pos[<span class="number">200005</span>][<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pw(x) (1 &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> merge(x, y, i) (a[pos[x][i]] &lt; a[pos[y][i]] ? pos[x][i] : pos[y][i])</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    pos[i][<span class="number">0</span>] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; <span class="built_in">pw</span>(j) &lt;= n; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + <span class="built_in">pw</span>(j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">      pos[i][j] = <span class="built_in">merge</span>(i, i + <span class="built_in">pw</span>(j - <span class="number">1</span>), j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">merge</span>(l, r - <span class="built_in">pw</span>(i) + <span class="number">1</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcl</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = L - <span class="number">1</span>, r = R + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[mid] - s[x - <span class="number">1</span>] &lt;= S)</span><br><span class="line">      l = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcr</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = L - <span class="number">1</span>, r = R + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[x] - s[mid - <span class="number">1</span>] &lt;= S)</span><br><span class="line">      r = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid = <span class="built_in">qry</span>(l, r);</span><br><span class="line">  <span class="keyword">if</span> (mid - l &lt; r - mid)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= mid; i++)</span><br><span class="line">      ans += <span class="built_in">calcl</span>(i, mid, r, S - a[mid]) - mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= r; i++)</span><br><span class="line">      ans += mid + <span class="number">1</span> - <span class="built_in">calcr</span>(i, l, mid, S - a[mid]);</span><br><span class="line">  <span class="built_in">Solve</span>(l, mid - <span class="number">1</span>), <span class="built_in">Solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>(), S = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    a[i] = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    b[i] = <span class="built_in">read</span>(), s[i] = s[i - <span class="number">1</span>] + b[i];</span><br><span class="line">  <span class="built_in">build</span>();</span><br><span class="line">  <span class="built_in">Solve</span>(<span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC332E</title>
    <url>/2023/12/11/ABC332E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc332_e">[ABC332E]
Lucky bag</a></p>
<span id="more"></span>
<p>题不难，写题解是为了嘲讽VP时候自己十分不明确的思路，甚至庆幸忘了报名。</p>
<p>拆柿子过程省略。</p>
<p>设 <span class="math inline">\(S\)</span> 为 <span
class="math inline">\(\sum w\)</span>，求：<span
class="math inline">\(\dfrac{D\times\sum_{i=1}^D
x_i^2-S^2}{D^2}\)</span> 的最小值。</p>
<p>剔除常量，问题转为：将集合划分为 <span
class="math inline">\(D\)</span> 个集合，求最小的 <span
class="math inline">\(\sum_{i=1}^Dx_i^2\)</span>。</p>
<p>在 <a href="https://h01yshhmy.github.io/2023/12/04/P4072/">P4072 |
h01yshhmy</a> 中，是对数列做有序的插板，思路是 <span
class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(j\)</span> 个数划 <span
class="math inline">\(i\)</span>
个部分的答案，每次转移都加上当前新部分的贡献。</p>
<p>在无序集合中当然可以类比——从枚举前 <span
class="math inline">\(j\)</span>
个数的一个后缀变成枚举当前集合的一个子集。</p>
<p>状压就行，没啥好说的了，时间复杂度 <span
class="math inline">\(O(3^n\times n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,d,w[N];</span><br><span class="line"><span class="type">double</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>][N],g[(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">    <span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">1</span>&lt;&lt;<span class="number">15</span>],<span class="number">1e18</span>L);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> S=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        S+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> U=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,U)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                g[i]+=w[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,U)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j;j=(j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">            <span class="built_in">re</span>(k,d)&#123;</span><br><span class="line">                f[i][k]=<span class="built_in">min</span>(f[i][k],f[i^j][k<span class="number">-1</span>]+g[j]*g[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans=(f[U][d]*d-S*S)/(d*d);</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">30</span>)&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC332G</title>
    <url>/2023/12/11/ABC332G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc332_g">[ABC332G] Not
Too Many Balls</a></p>
<span id="more"></span>
<p>题意：<span class="math inline">\(n\)</span> 种颜色，有 <span
class="math inline">\(A_i\)</span> 个颜色为 <span
class="math inline">\(i\)</span> 的球，<span
class="math inline">\(m\)</span> 个盒子，第 <span
class="math inline">\(j\)</span> 个盒子最多能放 <span
class="math inline">\(B_j\)</span> 个球，且第 <span
class="math inline">\(j\)</span> 个盒子最多只能放 <span
class="math inline">\(i\times j\)</span> 个颜色为 <span
class="math inline">\(i\)</span> 的球，最多能放多少个球。</p>
<p>颜色和盒子之间的配对/所属关系，考虑二分图，球转化成网络中的流量，变成了最大流问题。</p>
<p>关于连边：设 <span class="math inline">\(x_i\)</span> 为第 <span
class="math inline">\(i\)</span> 种颜色编号，<span
class="math inline">\(y_j\)</span> 为第 <span
class="math inline">\(j\)</span> 个盒子编号。</p>
<ul>
<li><span class="math inline">\(1\)</span> 类边：从源点 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(x_i\)</span> 连容量为 <span
class="math inline">\(A_i\)</span> 的边。</li>
<li><span class="math inline">\(2\)</span> 类边：从 <span
class="math inline">\(y_j\)</span> 到汇点 <span
class="math inline">\(t\)</span> 连容量为 <span
class="math inline">\(B_j\)</span> 的边。</li>
<li><span class="math inline">\(3\)</span> 类边：从 <span
class="math inline">\(x_i\)</span> 到 <span
class="math inline">\(y_j\)</span> 连容量为 <span
class="math inline">\(i\times j\)</span> 的边。</li>
</ul>
<p>边数为 <span class="math inline">\(O(nm)\)</span> 量级，跑不动。</p>
<p>发现很难直接优化这个边数，<span class="math inline">\(i\times
j\)</span> 的容量不太有性质。</p>
<p>将求最大流换成求最小割，事实上部分容量有规律的二分图最小割可以通过
<code>DP</code> 或其他最优化算法优化。</p>
<p>形式化最小割的式子。</p>
<p>设 <span
class="math inline">\(X=\{x_i|i\in[1,n]\},Y=\{y_j|j\in[1,m]\}\)</span>，<span
class="math inline">\(s-t\)</span> 的一个割等价于：</p>
<p>选点集 <span class="math inline">\(P\subseteq X,Q\subseteq
Y\)</span>，不失一般性的，对于 <span class="math inline">\(1\)</span>
类边，<span class="math inline">\(s\to u\)</span>，将 <span
class="math inline">\(u\)</span> 不属于 <span
class="math inline">\(P\)</span> 的边割掉；对于 <span
class="math inline">\(2\)</span> 类边，<span class="math inline">\(u\to
v\)</span>，将 <span class="math inline">\(u\)</span> 属于 <span
class="math inline">\(P\)</span>，<span class="math inline">\(v\)</span>
不属于 <span class="math inline">\(Q\)</span> 的边割掉；对于 <span
class="math inline">\(3\)</span> 类边，<span class="math inline">\(v\to
t\)</span>，将 <span class="math inline">\(v\)</span> 属于 <span
class="math inline">\(Q\)</span> 的边割掉。</p>
<p>“左右反过来”同理（在左边留下 <span class="math inline">\(P\)</span>
或在右边留下 <span class="math inline">\(Q\)</span>），怎么写都行。</p>
<p>写出式子。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\min_{P\subseteq X}\min_{Q\subseteq Y}\left(\sum_{x_i\in
X\backslash P}A_i+\sum_{x_i\in P}\sum_{y_i\in Y\backslash
Q}ij+\sum_{y_i\in Q}B_j\right)\\
&amp;\min_{P\subseteq X}\left(\sum_{x_i\in X\backslash
P}A_i+\min_{Q\subseteq Y}\left(\sum_{x_i\in P}i\sum_{y_i\in Y\backslash
Q}j+\sum_{y_i\in Q}B_j\right)\right)
\end{aligned}
\]</span></p>
<p>十分关键的，设 <span class="math inline">\(k=\sum_{x_i\in
P}i\)</span>，<span
class="math inline">\(S=\binom{n}{2}\)</span>，并枚举 <span
class="math inline">\(k\)</span>，实质上是在枚举不在 <span
class="math inline">\(s\to u\)</span> 处切断，流量继续向后流动的 <span
class="math inline">\(\sum i\)</span>。 <span class="math display">\[
\begin{aligned}
&amp;\min_{0\le k\le S}\left(\min_{P\subseteq X}\sum_{x_i\in X\backslash
P}A_i+\min_{Q\subseteq Y}\left(\sum_{y_i\in Y\backslash
Q}jk+\sum_{y_i\in Q}B_j\right)\right)
\end{aligned}
\]</span></p>
<p>发现最后一个 <span class="math inline">\(\min\)</span> 本质上是将
<span class="math inline">\(Y\)</span>
分成各自可以为空的两部分，写成：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\min_{0\le k\le S}\left(\min_{P\subseteq X}\sum_{x_i\in X\backslash
P}A_i+\sum_{y_i\in Y}\min(jk,B_j)\right)\\
\end{aligned}
\]</span></p>
<p>对这两个式子，前者可以通过 <span
class="math inline">\(O(nS)=O(n^3)\)</span> 的<code>DP</code>解决：设
<span class="math inline">\(f[i][j]\)</span> 为 <span
class="math inline">\(X\)</span> 中前 <span
class="math inline">\(i\)</span> 个数，<span
class="math inline">\(k=j\)</span> 时的最小值，<span
class="math inline">\(f[i][j]\)</span> 可以通过 <span
class="math inline">\(f[i-1][j]+A[i]\)</span> 和 <span
class="math inline">\(f[i-1][j-i]\)</span> 更新——各自是将 <span
class="math inline">\(A[i]\)</span> 不放进 <span
class="math inline">\(P\)</span> 内，或放进 <span
class="math inline">\(P\)</span> 内，注意这里是补集，是反过来的。<span
class="math inline">\(n^3\)</span>
空间稍大，可以滚动数组滚掉第一维。</p>
<p>对于后者，继续变式。</p>
<p>将 <span class="math inline">\(B_j\le jk\)</span>
中下标相同的放在一起，得到 <span
class="math inline">\(k\ge\frac{B_j}{j}\)</span>，不等号右边是一个定值，枚举的
<span class="math inline">\(k\)</span> 是递增的，<span
class="math inline">\(B\)</span> 没有什么顺序要求，可以将 <span
class="math inline">\(B\)</span> 根据 <span
class="math inline">\(\frac{B_j}{j}\)</span> 排序，在排序后，两者之中
<span class="math inline">\(B_j\)</span> 更小的位置就是 <span
class="math inline">\(B\)</span>
上的一个前缀，而且这个前缀只会不断变长，用指针维护这个前缀，记一下当前答案即可。</p>
<p>总复杂度：做<code>DP</code>，对 <span
class="math inline">\(B\)</span> 排序，枚举 <span
class="math inline">\(k\)</span>，扫指针，总复杂度为 <span
class="math inline">\(n^3+m\log m+n^2+m=O(n^3+m\log m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">505</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,ord[M];</span><br><span class="line">ll a[N],b[M],f[<span class="number">2</span>][N*N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">re</span>(i,m)<span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> S=n*(n+<span class="number">1</span>)/<span class="number">2</span>,o=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[o],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[o]));</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,S)&#123;</span><br><span class="line">            f[o][j]=<span class="built_in">min</span>(f[o][j],f[o^<span class="number">1</span>][j]+a[i]);</span><br><span class="line">            f[o][j+i]=<span class="built_in">min</span>(f[o][j+i],f[o^<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,S)f[o^<span class="number">1</span>][j]=f[o][j];</span><br><span class="line">        o^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)ord[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(ord+<span class="number">1</span>,ord+m+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> b[x]/x&lt;b[y]/y;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    ll Sj=<span class="number">1ll</span>*m*(m+<span class="number">1</span>)/<span class="number">2</span>,Sb=<span class="number">0</span>,ans=INF;</span><br><span class="line">    <span class="built_in">rep</span>(k,<span class="number">0</span>,S)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr&lt;m&amp;&amp;b[ord[ptr+<span class="number">1</span>]]&lt;=<span class="number">1ll</span>*k*ord[ptr+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> x=ord[++ptr];</span><br><span class="line">            Sb+=b[x];</span><br><span class="line">            Sj-=x;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[o][k]+Sb+Sj*k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>最大流最小割</tag>
        <tag>网络流</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC335G</title>
    <url>/2024/01/11/ABC335G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc335_g">[ABC335G]
Discrete Logarithm Problems</a></p>
<span id="more"></span>
<p>一些前置：</p>
<p>若 <span class="math inline">\(\delta_p(a)\)</span> 是满足 <span
class="math inline">\(a^{\delta_{p}(a)}\equiv 1\,(\textrm{mod
}p)\)</span> 的最小正整数，则称 <span
class="math inline">\(\delta_p(a)\)</span> 为 <span
class="math inline">\(a\)</span> 在模 <span
class="math inline">\(p\)</span> 意义下的<strong>阶</strong>。</p>
<p>有结论：</p>
<ul>
<li>若 <span class="math inline">\(p\)</span> 是质数，一定有 <span
class="math inline">\(\delta_p(a)|(p-1)\)</span>。</li>
<li>若 <span
class="math inline">\(\delta_{p}(a)|\delta_p(b)\)</span>，一定存在正整数
<span class="math inline">\(c\)</span> 满足 <span
class="math inline">\(b^c\equiv a\,(\textrm{mod }p)\)</span>，<span
class="math inline">\(c\)</span> 取 <span
class="math inline">\(\dfrac{\delta_p(b)}{\delta_p(a)}\)</span>
就是一个合法解。</li>
</ul>
<p>预处理 <span class="math inline">\(p-1\)</span>
的所有质因数，总个数最多 <span class="math inline">\(O(\log p)\)</span>
量级。</p>
<p>因为 <span
class="math inline">\(\delta_p(a)|(p-1)\)</span>，所以直接用 <span
class="math inline">\(p-1\)</span> 不断试除就可以得到 <span
class="math inline">\(\delta_p(a)\)</span>。</p>
<p>这部分复杂度为 <span class="math inline">\(O(n\log^2
p)\)</span>。</p>
<p>注意到不同的 <span class="math inline">\(\delta_p(a)\)</span>
的个数最多只有 <span class="math inline">\(\sigma_0(p)\)</span>
种，大约是 <span class="math inline">\(10^4\)</span> 量级。</p>
<p>所以直接暴力数就行。记得开 <code>__int128</code>。</p>
<p>时间复杂度 <span
class="math inline">\(O(n\log^2p+\sigma_0^2(p))\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i128=__int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll P,a[N];</span><br><span class="line">vector&lt;ll&gt; fac;</span><br><span class="line"><span class="function">i128 <span class="title">qpow</span><span class="params">(i128 a,ll b)</span></span>&#123;</span><br><span class="line">    i128 res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%P;</span><br><span class="line">        a=a*a%P;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">delta</span><span class="params">(ll v)</span></span>&#123;</span><br><span class="line">    ll ans=P<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i:fac)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qpow</span>(v,ans/i)==<span class="number">1</span>)&#123;</span><br><span class="line">            ans/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (P<span class="number">-1</span>)/ans;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;P;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll v=P<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=v;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v%i==<span class="number">0</span>)&#123;</span><br><span class="line">            fac.<span class="built_in">pb</span>(i);</span><br><span class="line">            v/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v)fac.<span class="built_in">pb</span>(v);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">range</span>(fac));</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        mp[<span class="built_in">delta</span>(a[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [i,u]:mp)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,v]:mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)ans+=<span class="number">1ll</span>*u*v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC006F</title>
    <url>/2023/12/08/AGC006F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_agc006_f">[AGC006F]
Blackout</a></p>
<span id="more"></span>
<p>首先将点 <span class="math inline">\((x,y)\)</span> 转成 <span
class="math inline">\(x,y\)</span> 之间连边。</p>
<p>题意转化为：如果 <span class="math inline">\(x\leftrightarrow
y,y\leftrightarrow z\)</span>，那么 <span
class="math inline">\(x,z\)</span> 也连边，求最终边的个数。</p>
<p>对图 三染色。</p>
<p>如果染色成功，那么红色可以连蓝色，蓝色可以连绿色，绿色可以连红色，一个连通块可以贡献
<span class="math inline">\(R\times B+B\times G+G\times R\)</span>
的答案。</p>
<p>否则如果染色失败，可以发现，最终整个图可以连成完全图，可以贡献连通块大小的平方。</p>
<p>记得要特判：染色成功，但是总颜色个数不足三种的情况，答案只会被贡献原图中边数。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt[<span class="number">3</span>],col[N],vis[N],tot,esum,flg;</span><br><span class="line">vector&lt;pii&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">3</span>)x-=<span class="number">3</span>;<span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    cnt[col[u]]++,vis[u]=<span class="number">1</span>,tot++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])&#123;</span><br><span class="line">        esum+=(w==<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            col[v]=<span class="built_in">cor</span>(col[u]+w);</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(col[v]!=<span class="built_in">cor</span>(col[u]+w))&#123;</span><br><span class="line">            flg=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v,<span class="number">1</span>&#125;);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(&#123;u,<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        flg=esum=tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(flg)&#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>*tot*tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">0</span>]&amp;&amp;cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>])&#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>*cnt[<span class="number">0</span>]*cnt[<span class="number">1</span>]+<span class="number">1ll</span>*cnt[<span class="number">1</span>]*cnt[<span class="number">2</span>]+<span class="number">1ll</span>*cnt[<span class="number">0</span>]*cnt[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=esum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>纯思维</tag>
        <tag>图上染色</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC020C</title>
    <url>/2023/12/02/AGC020C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_agc020_c">[AGC020C]
Median Sum</a></p>
<span id="more"></span>
<p>看上去像是DP。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数能否组成 <span
class="math inline">\(j\)</span>。</p>
<p>显然有 <span class="math inline">\(f[i][j]=f[i-1][j]\cup
f[i-1][j-a[i]]\)</span></p>
<p>滚掉第一维，发现后面是一个整体位移后做按位与，可以用bitset优化。</p>
<p>如何求中位数？</p>
<p>似乎不太能直接扫，因为不知道每个数到底能被多少个子集拼出来。</p>
<p>但真的需要知道吗？</p>
<p>如果所有子集和序列中，<span class="math inline">\(x\)</span> 有 <span
class="math inline">\(m\)</span> 个，那么 <span
class="math inline">\(\sum a[i]-x\)</span> 也有个 <span
class="math inline">\(m\)</span>，选和不选是对称的，左边有 <span
class="math inline">\(m\)</span> 个右边也一定有对应的 <span
class="math inline">\(m\)</span> 个。</p>
<p>所以我们并不需要知道具体有多少个，从 <span
class="math inline">\(\lceil\frac{\sum a[i]}{2}\rceil\)</span>
开始扫，遇到第一个可以拼出来的就是答案了。</p>
<p>时间复杂度 <span
class="math inline">\(O(\frac{n^2A}{w})\)</span>，<span
class="math inline">\(10^8\)</span> 左右，常数很小，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2005</span>)</span></span>;</span><br><span class="line">bitset&lt;N*N&gt; f;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f|=f&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,(sum+<span class="number">1</span>)/<span class="number">2</span>,sum)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i])&#123;</span><br><span class="line">            <span class="built_in">write</span>(i,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC074F</title>
    <url>/2023/12/01/ARC074F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc074_d">[ARC074F]
Lotus Leaves</a></p>
<span id="more"></span>
<p>看到数据范围和方格图题面，想到网络流。</p>
<p>发现一个 <span class="math inline">\(o\)</span>
的作用是连接一行和一列。所以我们只需要对行和列建点，表格中的每个位置作为一条边。</p>
<p>很显然，题目可以转化为：最少去掉多少个 <span
class="math inline">\(o\)</span> 边，可以不连通。</p>
<p>也就是最小割的模板。</p>
<p>那么关于连边的部分也就出来了。</p>
<p>具体的，如果是 <span
class="math inline">\(o\)</span>，让对应的行和列连流量为 <span
class="math inline">\(1\)</span>
的边；如果是起点的话，源点和行，列分别连不限流的边，如果是终点的话，行，列分别和汇点连不限流的边。</p>
<p>代码写的<code>dinic</code>，时间复杂度上界为 <span
class="math inline">\(O(HW(H+W)^3)\)</span>，可以说是完全没有参考意义，实际跑的很快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">105</span>)</span>,<span class="title">rN</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,st,ed;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,fl;</span><br><span class="line">&#125;e[rN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[rN],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].fl=fl;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFl</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,fl);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lev[rN],cur[rN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    <span class="built_in">memset</span>(lev,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(lev));</span><br><span class="line">    lev[st]=<span class="number">0</span>;q.<span class="built_in">push</span>(st);</span><br><span class="line">    cur[st]=head[st];</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(lev[v]==inf&amp;&amp;e[i].fl)&#123;</span><br><span class="line">                lev[v]=lev[u]+<span class="number">1</span>;</span><br><span class="line">                cur[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lev[ed]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==ed)<span class="keyword">return</span> flw;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,v=<span class="number">0</span>,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i&amp;&amp;flw&gt;<span class="number">0</span>;i=e[i].nxt)&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(lev[v]!=lev[u]+<span class="number">1</span>||e[i].fl&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].fl,flw));</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>)lev[v]=inf;</span><br><span class="line">        flw-=c,e[i].fl-=c,e[i^<span class="number">1</span>].fl+=c,res+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    st=<span class="number">0</span>,ed=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;(s[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123; </span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">ae</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">ae</span>(j+n,i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">addFl</span>(st,i,inf);</span><br><span class="line">                <span class="built_in">addFl</span>(st,j+n,inf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">addFl</span>(i,ed,inf);</span><br><span class="line">                <span class="built_in">addFl</span>(j+n,ed,inf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(st,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=inf)cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最大流最小割</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC100E</title>
    <url>/2023/12/01/ARC100E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc100_c">[ARC100E] Or
Plus Max</a></p>
<span id="more"></span>
<p>首先发现直接每次找 <span class="math inline">\(i or j\le k\)</span>
的答案并不好找。</p>
<p>所以对答案做转化：设 <span class="math inline">\(f_k\)</span>
为恰好的最大 <span class="math inline">\(i or j=k\)</span> 的最大 <span
class="math inline">\(a_i+a_j\)</span>。</p>
<p><span class="math inline">\(ans_k=\max\limits_{i=1}^kf_i\)</span></p>
<p>现在的问题转化为求 <span class="math inline">\(f_k\)</span></p>
<p>如果将每个数看做一个集合 会发现:</p>
<p><span class="math inline">\(f_k=\max\limits_{i,j\subseteq
k}a_i+a_j\)</span>。</p>
<p>显然 <span class="math inline">\(f_k\)</span> 一定是取所有 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 中的最大值和次大值。</p>
<p>可以用高维前缀和（子集和DP）在<span
class="math inline">\(O(n2^n)\)</span>的复杂度内
求出最大值和次大值。</p>
<p>此类求<span class="math inline">\(\le K\)</span>不好做，<span
class="math inline">\(=K\)</span>好做的问题，都可以转化成求<span
class="math inline">\(=K\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">((<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    m=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        f[i][<span class="number">1</span>]=-inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(s,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[s][<span class="number">0</span>]&gt;f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>])&#123;</span><br><span class="line">                    f[s][<span class="number">1</span>]=<span class="built_in">max</span>(f[s][<span class="number">1</span>],f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[s][<span class="number">1</span>]=<span class="built_in">max</span>(f[s][<span class="number">0</span>],f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">1</span>]);</span><br><span class="line">                    f[s][<span class="number">0</span>]=f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][<span class="number">0</span>]+f[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>子集和DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC022E</title>
    <url>/2023/12/02/AGC022E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_agc022_e">[AGC022E]
Median Replace</a></p>
<span id="more"></span>
<p>看起来很奇妙的题。</p>
<p>像这种把某些字符合并的题目似乎都有套路</p>
<p>就是确定消去的优先顺序然后用栈来维护消去的情况</p>
<p>最后用DP的状态来确定栈的情况，做转移。</p>
<p>先想想怎么判断字符串可以被消成 <span
class="math inline">\(1\)</span>。</p>
<p>用一个栈维护，然后分讨，设新加入的字符为 <span
class="math inline">\(c\)</span>：</p>
<ul>
<li><p>若 <span class="math inline">\(c=0\)</span>：由于三个 <span
class="math inline">\(0\)</span> 抵消为一个 <span
class="math inline">\(0\)</span> 严格不劣，因此若原来栈顶有两个 <span
class="math inline">\(0\)</span> 则抵消为一个，否则加一个 <span
class="math inline">\(0\)</span>。</p></li>
<li><p>若 <span class="math inline">\(c=1\)</span>：如果栈顶是 <span
class="math inline">\(0\)</span>，可以直接将这个 <span
class="math inline">\(0\)</span> 与新加的 <span
class="math inline">\(1\)</span>
抵消（因为无论和另外哪个数取中位数，答案都是另外那个数）；如果栈顶为
<span
class="math inline">\(1\)</span>，若已经有两个了，那么这个串一定合法，因此直接忽略掉这个
<span class="math inline">\(1\)</span> 就可以了，否则加一个 <span
class="math inline">\(1\)</span>。</p></li>
</ul>
<p>这其实是一种优先级。</p>
<p>根据这个过程，可以发现栈内 <span class="math inline">\(0\)</span> 和
<span class="math inline">\(1\)</span> 的个数都在 <span
class="math inline">\([0,2]\)</span> 内，放进DP状态。</p>
<p>设 <span class="math inline">\(f[i][a][b]\)</span> 为当前处理到前
<span class="math inline">\(i\)</span> 个字符，栈内 <span
class="math inline">\(a\)</span> 个 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(b\)</span> 个 <span
class="math inline">\(0\)</span> 的答案。</p>
<p>接下来考虑怎么转移，当然需要分讨。</p>
<p>如果加入 <span class="math inline">\(0\)</span>： <span
class="math display">\[
\begin{aligned}
&amp;f[i][a][1]=f[i-1][a][0]+f[i-1][a][2]\\
&amp;f[i][a][2]=f[i-1][a][1]
\end{aligned}
\]</span> 如果加入 <span class="math inline">\(1\)</span>： <span
class="math display">\[
\begin{aligned}
&amp;f[i][a][b]=f[i-1][a][b+1]\\
&amp;f[i][1][0]=f[i-1][0][0]\\
&amp;f[i][2][0]=f[i-1][1][0]+f[i-1][2][0]
\end{aligned}
\]</span> 如果是问号，两个都跑一遍。</p>
<p>（上文所有 <span class="math inline">\(=\)</span>
都应该为加等于）</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ll f[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adm</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=(x+y)%Mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">pe</span>(i,n)s[i]=s[i<span class="number">-1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">2</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">2</span>],f[i<span class="number">-1</span>][a][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">0</span>],f[i<span class="number">-1</span>][a][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">2</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">2</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,i)&#123;</span><br><span class="line">            <span class="built_in">adm</span>(ans,f[n][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC169B</title>
    <url>/2023/12/15/ARC169B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc169_b">[ARC169B]
Subsegments with Small Sums</a></p>
<span id="more"></span>
<p>求每个子区间的和。</p>
<p>显然 <span class="math inline">\(f\)</span> 的值可以直接贪心。</p>
<p>考虑弱化问题，如何求 <span class="math inline">\(\sum_{i=1}^n
f(A_1,A_2,\cdots,A_i)\)</span>，也就是每个前缀的和。</p>
<p>所有前缀的开头一样，所以他们的划分大部分都是相同的，可以从头做 <span
class="math inline">\(f(A_1,\cdots,A_n)\)</span> 的划分，设划分成了
<span class="math inline">\(m\)</span> 段（<span
class="math inline">\(f(A_1,\cdots,A_n)=m\)</span>），段与段的分界点集合为
<span class="math inline">\(P\)</span>，<span
class="math inline">\(g[i],i\in[1,n]\)</span> 为前缀 <span
class="math inline">\(i\)</span> 的答案，有 <span
class="math inline">\(g[i]=g[i-1]+[i\in P]\)</span>。</p>
<p>现在前缀答案可以 <span class="math inline">\(O(n)\)</span>
得到，枚举后缀，后缀的前缀就是子区间，是 <span
class="math inline">\(O(n^2)\)</span> 的，不够快。</p>
<p>在 <span class="math inline">\(g\)</span> 的前缀和中，<span
class="math inline">\([i\in P]\)</span> 如果为真，是对前缀和数组做 <span
class="math inline">\(i\)</span> 后缀整体 <span
class="math inline">\(+1\)</span>。</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为后缀 <span
class="math inline">\(i\)</span> 的每个前缀的答案之和，<span
class="math inline">\(p_i\)</span> 是 <span
class="math inline">\(i\)</span> 开始向后走，最长能划分到哪里，有 <span
class="math inline">\(f[i]=f[p_i+1]+n-i+1\)</span>，（<span
class="math inline">\(n-i+1\)</span> 是后缀整体加一的贡献）。</p>
<p>双指针预处理 <span class="math inline">\(p\)</span>
即可，做完了，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>小小总结：</p>
<p>这种全部区间之和的问题，可以从单个区间到前缀求值，再到对每个后缀做前缀求值，中间各种拆贡献，最后优化复杂度。</p>
<p>也可以考虑一些图论算法，事实上将 <span
class="math inline">\(p_i\)</span>
看作父亲，就是在一个DAG上转移，这种想法常用于序列上子区间的贡献。</p>
<blockquote>
<p>对任意区间的划分，一定都是无缝<strong>首尾相接</strong>的，而且以点
<span class="math inline">\(l\)</span>
开头划分一段，一定会划分到<strong>唯一对应</strong>的 <span
class="math inline">\(r\)</span>，这两个性质，让我们联想到图论问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">250005</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll s,a[N],f[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(l,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n&amp;&amp;a[r+<span class="number">1</span>]+sum&lt;=s)sum+=a[++r];</span><br><span class="line">        p[l]=r;</span><br><span class="line">        sum-=a[l];</span><br><span class="line">        <span class="keyword">if</span>(r==n)f[l]=n-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        f[i]=f[p[i]+<span class="number">1</span>]+n-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        ans+=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1009F</title>
    <url>/2023/12/09/CF1009F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1009F">Dominant
Indices</a></p>
<span id="more"></span>
<p>三种做法，思想相同，它们本质上都是启发式合并。</p>
<h2 id="长剖优化dp">长剖优化DP</h2>
<p>题意：求以 <span class="math inline">\(u\)</span> 为根子树内，到点
<span class="math inline">\(u\)</span>
的距离众数，且尽可能最小化这个众数，输出每个 <span
class="math inline">\(u\)</span> 的答案。</p>
<p>有一个很简单的朴素<code>DP</code>，设 <span
class="math inline">\(f[u][i]\)</span> 为 <span
class="math inline">\(u\)</span> 子树内距离 <span
class="math inline">\(u\)</span> 为 <span
class="math inline">\(i\)</span> 的节点个数，有：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[u][0]=1\\
&amp;f[u][i]=\sum_{v\in son(u)}f[v][i-1]\\
&amp;S=\{i\,|\,i=max_{j=1}^nf[u][j]\}\\
&amp;ans[u]=\min_{i\in S}i
\end{aligned}
\]</span></p>
<p>考虑优化这个过程，使用长链剖分。</p>
<p>因为 <span class="math inline">\(f[u][i]\)</span> 和 <span
class="math inline">\(f[v][i-1]\)</span> 在下标 <span
class="math inline">\(i,i-1\)</span> 上的区分和深度相关，所以可以先将
<span class="math inline">\(u\)</span>
的长链的结果<code>DP</code>出来，通过指针，使长链中<code>DP</code>出的结果快速累加到
<span class="math inline">\(u\)</span> 上，或者说是直接放到了 <span
class="math inline">\(f[u]\)</span>
上。再将其他短儿子的结果暴力合并到长链上，也就是将 <span
class="math inline">\(f[v]\)</span> 从 <span
class="math inline">\(v\)</span> 到叶子的所有 <span
class="math inline">\(f[v][i-1]\)</span> 都暴力加到 <span
class="math inline">\(f[u][i]\)</span> 上。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<p>关于复杂度：长儿子部分的<code>DP</code>显然线性，关于暴力合并部分，枚举
<span class="math inline">\(i\)</span> 也可以看作是在遍历 <span
class="math inline">\(v\)</span> 的长儿子，而 <span
class="math inline">\(v\)</span> 又是 <span
class="math inline">\(u\)</span> 的短儿子，也就是说 <span
class="math inline">\(v\)</span>
一定是长链的链底（深度最浅的），所以说每个长链也只会被遍历一次，依然是线性的。</p>
<h2 id="树上启发式合并">树上启发式合并</h2>
<p>很符合我们对树上启发式合并的要求。</p>
<ul>
<li>只有查询</li>
<li>只和子树相关</li>
</ul>
<p>然后就没啥好说的了，纯纯的板子。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>，稍劣。</p>
<h2 id="线段树合并">线段树合并</h2>
<p>建权值线段树维护每个 <code>dep</code>
的个数，没啥好说的，基本是板子，其实也是对线段树做启发式合并。</p>
<p>要写内存回收，不然非常容易
<code>MLE</code>，写内存回收空间复杂度就降到 <span
class="math inline">\(O(n)\)</span> 了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>，稍劣。</p>
<p>长剖代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> n,len[N],top[N],lson[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">predfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">predfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(len[v]&gt;len[lson[u]])&#123;</span><br><span class="line">            lson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len[u]=len[lson[u]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> buf[N],ans[N];</span><br><span class="line"><span class="type">int</span> *f[N],*g[N],*now=buf;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lson[u])&#123;</span><br><span class="line">        f[lson[u]]=f[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(lson[u],u);</span><br><span class="line">        ans[u]=ans[lson[u]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==lson[u]||v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[v]=now,now+=len[v];</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="built_in">re</span>(i,len[v])&#123;</span><br><span class="line">            f[u][i]+=f[v][i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(f[u][i]&gt;f[u][ans[u]]||(f[u][i]==f[u][ans[u]]&amp;&amp;i&lt;ans[u]))&#123;</span><br><span class="line">                ans[u]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[u][ans[u]]==<span class="number">1</span>)ans[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">predfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(len[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    f[<span class="number">1</span>]=now,now+=len[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面这两个就都不是我写的了。</p>
<p>树上启发式合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Len = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> Mx,Dis,n,m,Cnt[Len],head[Len],cnt,Print[Len],dep[Len],siz[Len],son[Len],Son;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> next,to;</span><br><span class="line">&#125;edge[Len &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++ cnt].to = to;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[x] ; e ; e = edge[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = edge[e].to;</span><br><span class="line">        <span class="keyword">if</span>(to == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to , x);</span><br><span class="line">        siz[x] += siz[to];</span><br><span class="line">        <span class="keyword">if</span>(siz[to] &gt; maxson) maxson = siz[to] , son[x] = to; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> val,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cnt[dep[x]] += val;</span><br><span class="line">    <span class="keyword">if</span>(Cnt[dep[x]] &gt; Mx || (Cnt[dep[x]] == Mx &amp;&amp; dep[x] -  dep[now] &lt; Dis - dep[now])) Mx = Cnt[dep[x]] , Dis = dep[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[x] ; e ; e = edge[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = edge[e].to;</span><br><span class="line">        <span class="keyword">if</span>(to == f || to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(to , x , val , now);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[x] ; e ; e = edge[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = edge[e].to;</span><br><span class="line">        <span class="keyword">if</span>(to == f || to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(to , x , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) <span class="built_in">dfs2</span>(son[x] , x , <span class="number">1</span>) , Son = son[x];</span><br><span class="line">    <span class="built_in">add</span>(x , f , <span class="number">1</span> , x) , Son = <span class="number">0</span>;</span><br><span class="line">    Print[x] = Dis;</span><br><span class="line">    <span class="keyword">if</span>(!opt) <span class="built_in">add</span>(x , f , <span class="number">-1</span> , x) , Mx = Dis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x , y) , <span class="built_in">add</span>(y , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span> , <span class="number">0</span> , <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Print[i] - dep[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线段树合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,cnt,cntt,h[<span class="number">1000005</span>],root[<span class="number">1000005</span>],ans[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">4000005</span>],top;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,maxx,maxp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ls=rs=maxx=maxp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[<span class="number">4000005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Que</span>&#123;</span><br><span class="line">    <span class="type">int</span> k,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NewNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top)<span class="keyword">return</span> st[top--];</span><br><span class="line">    <span class="keyword">return</span> ++cntt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=y;</span><br><span class="line">    e[cnt].next=h[x];</span><br><span class="line">    h[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=t[p].ls,r=t[p].rs;</span><br><span class="line">    <span class="keyword">if</span>(t[l].maxx==t[r].maxx)&#123;</span><br><span class="line">        t[p].maxx=t[l].maxx,t[p].maxp=t[l].maxp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[l].maxx&gt;t[r].maxx)&#123;</span><br><span class="line">        t[p].maxx=t[l].maxx,t[p].maxp=t[l].maxp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        t[p].maxx=t[r].maxx,t[p].maxp=t[r].maxp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)p=<span class="built_in">NewNode</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[p].maxx++,t[p].maxp=l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">Update</span>(t[p].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Update</span>(t[p].rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="built_in">Pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)&#123;</span><br><span class="line">        p=p+q;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[p].maxx+=t[q].maxx;</span><br><span class="line">        t[q].<span class="built_in">Clear</span>(),st[++top]=q;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Merge</span>(t[p].ls,t[q].ls,l,mid);</span><br><span class="line">    <span class="built_in">Merge</span>(t[p].rs,t[q].rs,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">Pushup</span>(p);</span><br><span class="line">    t[q].<span class="built_in">Clear</span>(),st[++top]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    root[now]=++cntt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[now];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Solve</span>(y,now,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Merge</span>(root[now],root[y],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Update</span>(root[now],<span class="number">1</span>,n,dep);</span><br><span class="line">    ans[now]=t[root[now]].maxp-dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,x,y;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">Add_Edge</span>(x,y);</span><br><span class="line">        <span class="built_in">Add_Edge</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Solve</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>树形DP</tag>
        <tag>树上启发式合并</tag>
        <tag>启发式合并</tag>
        <tag>长链剖分</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1023F</title>
    <url>/2023/12/01/CF1023F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1023F">Mobile Phone
Network</a></p>
<span id="more"></span>
<p>先将题面翻译成能看的版本：</p>
<p>有 <span class="math inline">\(k\)</span> 个边权待定的边，还有 <span
class="math inline">\(m\)</span> 条已经确定的边。</p>
<p>在为 <span class="math inline">\(k\)</span>
条边确定权值后，使图的最小生成树包括全部 <span
class="math inline">\(k\)</span> 条边，最大化 <span
class="math inline">\(k\)</span> 条边的边权和。</p>
<p>生成树相关的题一般是分树边和非树边讨论。</p>
<p>有一个比较容易得到的思路：</p>
<p>先把 <span class="math inline">\(k\)</span>
条边都加到图里，然后仿照<code>Kruskal</code>的思想，将 <span
class="math inline">\(m\)</span>
条边排序，如果能连接两个不同连通块，就加边。</p>
<p>而加入的这些边对 <span class="math inline">\(k\)</span>
条边的边权是没有约束的，因为它们都是生成树上的边。</p>
<p>而对于不在生成树上的边：<span
class="math inline">\((u,v,w)\)</span>，对 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 路径上的未定边权都有边权要 <span
class="math inline">\(\le w\)</span> 的约束，</p>
<p>这个性质较为重要，所有约束完成后就是非树边不在生成树中的条件。</p>
<p>这个可以用树链剖分+线段树（可以写吉司机）做区间覆盖。</p>
<p>这道题就做完了，调题用了快1h。</p>
<p>为了方便写，所有未定边权初始边权都为极大值，复杂度 <span
class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>其实有更优的并查集做法：可以将区间<span
class="math inline">\(\min\)</span>覆盖的操作按覆盖的值排序，从小往大覆盖，用并查集维护已经被更新的部分，复杂度降到
<span class="math inline">\(O(n\log n)\)</span>，瓶颈在排序了。</p>
<p>下面有两份代码。</p>
<p>树剖：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w,nxt;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edg</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;be[N];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> added[N];</span><br><span class="line"><span class="type">int</span> hd[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hd[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> hd[x]=<span class="built_in">findfa</span>(hd[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x),y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    hd[x]=y;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],top[N],dfn[N],idx[N],dfcnt,siz[N],hson[N];</span><br><span class="line"><span class="type">int</span> ini[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dep[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        ini[v]=e[i].w;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp,dfn[u]=++dfcnt;</span><br><span class="line">    idx[dfcnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(hson[u]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(top[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tcp</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> mx,lz;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mx=ini[idx[l]];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].mx=v;</span><br><span class="line">        t[rt].lz=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mx&gt;=t[rt].lz)<span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">rs</span>(rt)].mx&gt;=t[rt].lz)<span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;t[rt].mx)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modPath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            ans[idx[l]]=t[rt].mx;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)hd[i]=i;</span><br><span class="line">    <span class="built_in">re</span>(i,k)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">ae</span>(u,v,inf);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,inf);</span><br><span class="line">        hd[<span class="built_in">findfa</span>(u)]=<span class="built_in">findfa</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;be[i].u&gt;&gt;be[i].v&gt;&gt;be[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(be+<span class="number">1</span>,be+m+<span class="number">1</span>,[](Edg a,Edg b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        u=be[i].u,v=be[i].v;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">merge</span>(u,v))&#123;</span><br><span class="line">            <span class="built_in">ae</span>(u,v,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ae</span>(v,u,<span class="number">0</span>);</span><br><span class="line">            added[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> lca=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(added[i])<span class="keyword">continue</span>;</span><br><span class="line">        u=be[i].u,v=be[i].v,w=be[i].w;</span><br><span class="line">        lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">        t.<span class="built_in">modPath</span>(lca,u,w);</span><br><span class="line">        t.<span class="built_in">modPath</span>(lca,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==inf)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是并查集，是题解区复制的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1110000</span>;</span><br><span class="line"><span class="type">int</span> n,k,m1,m2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu_edge</span>&#123;<span class="type">int</span> x,y,w;&#125;dsu_e[N];</span><br><span class="line"><span class="type">int</span> dsu_fa[N],mst_e[N],mst_top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dsu_cmp</span><span class="params">(dsu_edge a,dsu_edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dsu_find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x==dsu_fa[x]?x:dsu_fa[x]=<span class="built_in">dsu_find</span>(dsu_fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_dsu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a = dsu_e[i].x,b = dsu_e[i].y;</span><br><span class="line">    a = <span class="built_in">dsu_find</span>(a);</span><br><span class="line">    b = <span class="built_in">dsu_find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">continue</span>;</span><br><span class="line">    mst_e[i] = <span class="number">1</span>;</span><br><span class="line">    dsu_fa[a] = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLE</span>&#123;</span><br><span class="line">  <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> fuck = <span class="number">0</span>,head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++fuck].to = y;</span><br><span class="line">  e[fuck].nxt = head[x];</span><br><span class="line">  e[fuck].w = w;</span><br><span class="line">  head[x] = fuck;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_mst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(mst_e[i])</span><br><span class="line">    &#123;</span><br><span class="line">      dsu_edge a = dsu_e[i];</span><br><span class="line">      <span class="built_in">add</span>(a.x,a.y,a.w);</span><br><span class="line">      <span class="built_in">add</span>(a.y,a.x,a.w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N],d[N],cost[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[x] = fa;d[x] = dep;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x];i;i = e[i].nxt)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">    cost[y] = e[i].w;</span><br><span class="line">    <span class="built_in">dfs</span>(y,x,dep+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>();m1 = <span class="built_in">read</span>();m2 = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dsu_fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dsu_e[i].x = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].y = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].w = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = m1+<span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    dsu_e[i].x = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].y = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].w = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dsu_e+<span class="number">1</span>,dsu_e+m1+m2+<span class="number">1</span>,dsu_cmp);</span><br><span class="line">  <span class="built_in">solve_dsu</span>();</span><br><span class="line">  <span class="built_in">solve_mst</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dsu_fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = m1+<span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(mst_e[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">dsu_find</span>(dsu_e[i].x),b = <span class="built_in">dsu_find</span>(dsu_e[i].y),c = dsu_e[i].w;</span><br><span class="line">    <span class="keyword">while</span>(a != b)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[a]&lt;d[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">      <span class="keyword">if</span>(cost[a] &lt;= <span class="number">0</span>) ans += c,num++;</span><br><span class="line">      <span class="type">int</span> fa = <span class="built_in">dsu_find</span>(f[a]);</span><br><span class="line">      dsu_fa[a] = fa;</span><br><span class="line">      a = <span class="built_in">dsu_find</span>(a); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; m1) ans=<span class="number">-1</span>;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>并查集</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1114F</title>
    <url>/2023/12/01/CF1114F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1114F">Please, another
Queries on Array?</a></p>
<span id="more"></span>
<p>看起来非常线段树。</p>
<p>首先 考虑欧拉函数 <span class="math inline">\(\varphi\)</span>
的形式化式子：</p>
<p><span class="math inline">\(\varphi(n)=n\times \prod\limits_{p\in
P}\dfrac{p-1}{p}\)</span></p>
<p><span class="math inline">\(P\)</span> 为 <span
class="math inline">\(n\)</span> 的质因子组成的集合。</p>
<p><span class="math inline">\(n\)</span>
可以用线段树维护区间乘解决，后面的质因子如何处理？</p>
<p>可以发现 我们不关心每种质因子的数量，只需要记录是否存在即可。</p>
<p>值域很小，<span class="math inline">\(300\)</span> 内的质数只有 <span
class="math inline">\(62\)</span> 个。</p>
<p>暴力用数组记录 会大大增加复杂度；<span
class="math inline">\(62\)</span> 个状态，正好可以状压。</p>
<p>线段树维护每一个区间内的乘积 和 乘积的所有质因子状态。</p>
<p>时间复杂度，<span class="math inline">\(O(62(n+q)+q\log^2
n)\)</span>（两个 <span class="math inline">\(\log\)</span>
是区间乘的快速幂），可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4e5</span>+<span class="number">5</span>)</span>,<span class="title">V</span><span class="params">(<span class="number">305</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span>,<span class="title">pN</span><span class="params">(<span class="number">62</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> prm[pN+<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,Q,a[N];</span><br><span class="line">ll inv[V],f[pN+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,V<span class="number">-5</span>)inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">        f[i]=(prm[i]<span class="number">-1</span>)*inv[prm[i]]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll sta=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;prm[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(x%prm[i]==<span class="number">0</span>)sta|=(<span class="number">1ll</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">    ll mul,sta;</span><br><span class="line">    <span class="built_in">dat</span>(ll _m=<span class="number">0</span>,ll _s=<span class="number">0</span>)&#123;</span><br><span class="line">        mul=_m,sta=_s;</span><br><span class="line">    &#125;</span><br><span class="line">    dat <span class="keyword">operator</span>+(<span class="type">const</span> dat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        dat c;</span><br><span class="line">        c.mul=mul*b.mul%Mod;</span><br><span class="line">        c.sta=sta|b.sta;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        dat v,lz;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].v=t[<span class="built_in">ls</span>(rt)].v+t[<span class="built_in">rs</span>(rt)].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].lz.mul=<span class="number">1</span>,t[rt].len=r-l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].v=<span class="built_in">dat</span>(a[l],<span class="built_in">calc</span>(a[l]));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,dat val)</span></span>&#123;</span><br><span class="line">        t[rt].lz=t[rt].lz+val;</span><br><span class="line">        val.mul=<span class="built_in">qpow</span>(val.mul,t[rt].len);</span><br><span class="line">        t[rt].v=t[rt].v+val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz.sta==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="built_in">dat</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,dat val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,val);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">dat <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> t[rt].v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr)+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,Q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">12</span>];</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    dat ans;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r,x);</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,<span class="built_in">dat</span>(x,<span class="built_in">calc</span>(x)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r);</span><br><span class="line">            ans=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.sta&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    ans.mul=ans.mul*f[i]%Mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write</span>(ans.mul,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1140F</title>
    <url>/2023/12/08/CF1140F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1140F">Extending Set of
Points</a></p>
<span id="more"></span>
<p>年轻人的第一道线段树分治。</p>
<blockquote>
<p>线段树分治是一种按时间分治的方法，其实叫线段树分治不如叫时间分治，由于其结构类似线段树，被称为线段树分治。</p>
</blockquote>
<p>先发掘 拓展操作 的性质。</p>
<p>首先，这种拓展的要求让人很难不想到二分图。</p>
<p>将 <span class="math inline">\(x,y\)</span>
分别作为二分图的两个点集，点 <span class="math inline">\((x,y)\)</span>
是边。</p>
<p>发现，如果存在形如 <span class="math inline">\(x_0\leftrightarrow
y_1\leftrightarrow x_1\leftrightarrow y_0\)</span> 的一条链，那么 <span
class="math inline">\(x_0\)</span> 和 <span
class="math inline">\(y_0\)</span>
就可以连边，也就是说，将一个四个点的链连成四元环。考虑一个连通块内，如果出现一个四元环，那么连接到四元环上的点就可以通过四元环中某三个点组成新的链，再次成环。</p>
<p>所以，一个连通块最终可以连成一个完全二分图，那么对答案的贡献也就是左边的点数乘上右边的点数，只需要动态维护连通块内左/右点数即可。</p>
<p>并查集难以直接维护加边断边，但是这个题可以离线。（其实可以<code>LCT</code>直接维护，但是常数巨大码量巨大，不是最优选择）</p>
<p>将所有加边/删边操作离线下来，在时间轴上，处理出每个边存在于图上的一些时间段。</p>
<p>变成了线段树分治板子。</p>
<p>将时间段放到线段树上，切成线段树上的若干个区间（优化建图的思想），在这些区间节点上挂上
<span class="math inline">\((x,y)\)</span>（也可以看作对这个点连边）</p>
<p>在线段树上搜索，将当前区间挂着的点都在并查集内 <code>merge</code>
上，对答案做贡献，并用栈存下 <code>merge</code>
以前的数据，处理完子树内之后再利用栈对并查集和答案做撤销。</p>
<p>并查集当然没有路径压缩了，要写启发式合并，保证并查集树高不超过 <span
class="math inline">\(\log n\)</span>。</p>
<p>每个询问会被拆成 <span class="math inline">\(\log n\)</span>
个区间，每个区间要用 <span class="math inline">\(O(\log n)\)</span>
的复杂度求并查集<code>fa</code>，总复杂度 <span
class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>总结。</p>
<p>只要一个数据结构的复杂度不是均摊的，理论上都支持撤销，也就支持线段树分治。</p>
<p>线段树分治<strong>一般</strong>是在询问序列上建线段树的。</p>
<p>一些应用：P5227，P4585，CF576E。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> q,n=<span class="number">3e5</span>;</span><br><span class="line"><span class="type">int</span> fa[N*<span class="number">2</span>],hei[N*<span class="number">2</span>],c1[N*<span class="number">2</span>],c2[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;<span class="type">int</span> x,y,c1,c2,ad;ll ans;&#125;sta[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">vector&lt;pii&gt; G[N*<span class="number">8</span>];</span><br><span class="line">map&lt;pii,<span class="type">int</span>&gt; tim;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=x)x=fa[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(hei[x]&gt;hei[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    sta[++top]=&#123;x,y,c1[y],c2[y],hei[x]==hei[y],ans&#125;;</span><br><span class="line">    ans-=<span class="number">1ll</span>*c1[x]*c2[x]+<span class="number">1ll</span>*c1[y]*c2[y];</span><br><span class="line">    c1[y]+=c1[x];</span><br><span class="line">    c2[y]+=c2[x];</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    <span class="keyword">if</span>(hei[x]==hei[y])hei[y]++;</span><br><span class="line">    ans+=<span class="number">1ll</span>*c1[y]*c2[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">const</span> pii x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        G[rt].<span class="built_in">pb</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">connect</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,x);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">connect</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> las=top;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(v.fi),y=<span class="built_in">find</span>(v.se);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)<span class="built_in">merge</span>(v.fi,v.se);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="built_in">write</span>(ans,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">ls</span>(u),l,mid);</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">rs</span>(u),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&gt;las)&#123;</span><br><span class="line">        hei[fa[sta[top].x]]-=sta[top].ad;</span><br><span class="line">        c1[sta[top].y]=sta[top].c1;</span><br><span class="line">        c2[sta[top].y]=sta[top].c2;</span><br><span class="line">        fa[sta[top].x]=sta[top].x;</span><br><span class="line">        ans=sta[top].ans;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        y+=n;</span><br><span class="line">        <span class="keyword">if</span>(tim.<span class="built_in">count</span>(&#123;x,y&#125;))&#123;</span><br><span class="line">            <span class="built_in">connect</span>(<span class="number">1</span>,<span class="number">1</span>,q,tim[&#123;x,y&#125;],i<span class="number">-1</span>,&#123;x,y&#125;);</span><br><span class="line">            tim.<span class="built_in">erase</span>(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> tim[&#123;x,y&#125;]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)&#123;</span><br><span class="line">        fa[i]=i,hei[i]=<span class="number">1</span>;</span><br><span class="line">        c1[i]=(i&lt;=n),c2[i]=(i&gt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">each</span>(i,tim)&#123;</span><br><span class="line">        <span class="built_in">connect</span>(<span class="number">1</span>,<span class="number">1</span>,q,i.se,q,i.fi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1149B</title>
    <url>/2023/12/01/CF1149B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1149B">Three
Religions</a></p>
<span id="more"></span>
<p>有点罕见的DP。</p>
<p>可能会先想到一个贪心——枚举三个串的全排列，每个串都从贪心匹配到，标记匹配过的字符。稍加思考会发现这是假的（母串：<code>acacbc</code>，子串：<code>ac,bc,ca</code>）</p>
<p>所以考虑DP。</p>
<p>发现一共只有 <span class="math inline">\(k=3\)</span> 个串—— <span
class="math inline">\(k\)</span> 极小。且小串的长度最长也只有 <span
class="math inline">\(250\)</span>，所以可以直接记录 <span
class="math inline">\(k\)</span> 个状态。</p>
<p>设 <span class="math inline">\(f[i][j][k]\)</span> 为三个串分别匹配到
<span class="math inline">\(i\)</span>, <span
class="math inline">\(j\)</span> ,<span class="math inline">\(k\)</span>
位，最短需要在母串中匹配的前缀长度。</p>
<p><span class="math inline">\(nxt[i][c]\)</span> 为 母串中第 <span
class="math inline">\(i\)</span> 个位置以及后面的位置中，第一次出现字符
<span class="math inline">\(c\)</span> 的位置。 <span
class="math display">\[
\begin{aligned}
f[i]&amp;[j][k]=\min\{\\
    &amp;nxt[f[i-1][j][k]][s[1][i]],\\
    &amp;nxt[f[i][j-1][k]][s[2][j]],\\
    &amp;nxt[f[i][j][k-1]][s[3][k]]\\
\}
\end{aligned}
\]</span> 然而这是静态的，考虑加入/删除怎么做。</p>
<p>加入一个新字符时，新加入的状态最多只有 <span
class="math inline">\(1\times 250\times 250\)</span> 个。</p>
<p>删除字符直接 <span
class="math inline">\(len[id]-1\)</span>，加入字符时顺便覆盖之前减掉的状态就好了。</p>
<p>总复杂度 <span class="math inline">\(O(q\times
250^2\)</span>)，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">L</span><span class="params">(<span class="number">255</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,Q;</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>][L],f[L][L][L],nxt[N][<span class="number">27</span>],len[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;Q;</span><br><span class="line">    cin&gt;&gt;(t+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)nxt[n+<span class="number">1</span>][i]=nxt[n+<span class="number">2</span>][i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==j+<span class="string">&#x27;a&#x27;</span>)nxt[i][j]=i;</span><br><span class="line">            <span class="keyword">else</span> nxt[i][j]=nxt[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op,c;</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;id&gt;&gt;c;</span><br><span class="line">            s[id][++len[id]]=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i,((id==<span class="number">1</span>)?len[<span class="number">1</span>]:<span class="number">0</span>),len[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,((id==<span class="number">2</span>)?len[<span class="number">2</span>]:<span class="number">0</span>),len[<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="built_in">rep</span>(k,((id==<span class="number">3</span>)?len[<span class="number">3</span>]:<span class="number">0</span>),len[<span class="number">3</span>])&#123;</span><br><span class="line">                        <span class="type">int</span> &amp;sta=f[i][j][k];sta=n+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i)sta=<span class="built_in">min</span>(sta,nxt[f[i<span class="number">-1</span>][j][k]+<span class="number">1</span>][s[<span class="number">1</span>][i]]);</span><br><span class="line">                        <span class="keyword">if</span>(j)sta=<span class="built_in">min</span>(sta,nxt[f[i][j<span class="number">-1</span>][k]+<span class="number">1</span>][s[<span class="number">2</span>][j]]);</span><br><span class="line">                        <span class="keyword">if</span>(k)sta=<span class="built_in">min</span>(sta,nxt[f[i][j][k<span class="number">-1</span>]+<span class="number">1</span>][s[<span class="number">3</span>][k]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;id;</span><br><span class="line">            len[id]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[len[<span class="number">1</span>]][len[<span class="number">2</span>]][len[<span class="number">3</span>]]&lt;=n)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1142C</title>
    <url>/2023/12/01/CF1142C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1142C">U2</a></p>
<span id="more"></span>
<p>小思维 + 二维凸包模板。</p>
<p>题意：给 <span class="math inline">\(n\)</span> 个点，过 <span
class="math inline">\(n\)</span> 个点中任意两点做二次函数 <span
class="math inline">\(y=x^2+bx+c\)</span>，问有多少种二次函数满足图像上方没有点。</p>
<p>上方没有点，可以想到上凸壳。</p>
<p>如果没有 <span
class="math inline">\(x^2\)</span>，显然合法情况为：直线 <span
class="math inline">\(bx+c\)</span> 过上凸壳上的相邻两点。</p>
<p>可以将所有点的坐标转为 <span
class="math inline">\((x,y_1)\)</span>：<span
class="math inline">\((x,y-x^2)\)</span>，这样就没有 <span
class="math inline">\(x^2\)</span> 了。</p>
<p>对新的点求上凸壳，答案也就是上凸壳上的边数，因为每条边都对应了一种一次函数
<span class="math inline">\(y_1=bx+c\)</span>。</p>
<p>直接跑 Graham 即可，时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-b.x,y-b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sta[N],tp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> mny=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[i].y-=p[i].x*p[i].x;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].y&lt;p[mny].y||(p[i].y==p[mny].y&amp;&amp;p[i].x&lt;p[mny].x))&#123;</span><br><span class="line">                mny=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(p[<span class="number">1</span>],p[mny]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        p[i].x-=p[<span class="number">1</span>].x;</span><br><span class="line">        p[i].y-=p[<span class="number">1</span>].y;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">2</span>,p+n+<span class="number">1</span>,[](Point a,Point b)&#123;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">cross</span>(a-p[<span class="number">1</span>],b-p[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>&amp;&amp;<span class="built_in">dist</span>(p[<span class="number">0</span>],a)&lt;<span class="built_in">dist</span>(p[<span class="number">0</span>],b))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cross</span>(p[sta[tp]]-p[sta[tp<span class="number">-1</span>]],p[i]-p[sta[tp]])&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tp--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[tp+<span class="number">1</span>]=sta[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,tp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[sta[i+<span class="number">1</span>]].x&lt;p[sta[i]].x)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1156E</title>
    <url>/2023/12/01/CF1156E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1156E">Special Segments
of Permutation</a></p>
<span id="more"></span>
<p><strong>注意，单调栈求左侧右侧第一个大于自己的位置，如果数列内有相同元素，要写左开右闭或者左闭右开（比如左侧找第一个大于等于的，右侧找第一个大于的），因为需要不重不漏的覆盖</strong></p>
<p>我觉得是好题。</p>
<p>同类题：CF1175F,P4755</p>
<p>题意：给定一个排列 <span class="math inline">\(p\)</span>，求满足
<span class="math inline">\(p_l+p_r=\max_{i=l}^rp_i\)</span> 的 <span
class="math inline">\((l,r)\)</span> 个数。</p>
<p>数区间的题，要么枚举端点，要么分治。</p>
<p>容易有一个枚举 <span
class="math inline">\(r\)</span>，在枚举过的前缀中数 <span
class="math inline">\(\max_{i=l}^rp_i-p_l\)</span>
出现了几次的想法，这个题面看起来就很单调栈。</p>
<p>但是不太可做。</p>
<p>尝试另一种枚举思路：枚举 <span class="math inline">\(i\)</span>。</p>
<p>设 <span class="math inline">\(l_i,r_i\)</span> 为 <span
class="math inline">\(i\)</span> 左边和右边第一个大于 <span
class="math inline">\(p_i\)</span> 的位置。</p>
<p>可以发现，以 <span class="math inline">\(p_i\)</span> 为最大值的
<span class="math inline">\((l,r)\)</span>，一定满足 <span
class="math inline">\(l\in[l_i+1,i),r\in(i,r_i-1]\)</span>。</p>
<p>现在有了一个十分朴素的 <span class="math inline">\(O(n^3)\)</span>
算法，枚举 <span class="math inline">\(i,l,r\)</span> 判断是否合法。</p>
<p>显然可以加速这个过程，因为是排列，可以直接处理出每个数的位置 。</p>
<p>枚举 <span class="math inline">\(l\)</span>，判断 <span
class="math inline">\(pos[p_i-p_l]\)</span> 是否在 <span
class="math inline">\((i,r_i-l]\)</span> 内，时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>似乎要在这里结束了？</p>
<p>但如果尝试了一个看似玄学的优化：在 <span
class="math inline">\(l,r\)</span>
对应区间中选短的那个去枚举，可以直接AC。</p>
<p>为什么呢？</p>
<p>考虑对 <span class="math inline">\(p\)</span>
建立笛卡尔树，深度越小，数越大，根为最大值。</p>
<p>对排列建笛卡尔树，有：排列上一段区间对应树上的一个子树的关键性质。</p>
<p>更进一步的，树上的 <span class="math inline">\(p_i\)</span>
对应的子树区间就是 <span
class="math inline">\([l_i+1,r_i-1]\)</span>，证明就略了（<del>OI不需要证明</del>）</p>
<p>那么我们每次找短的区间枚举，就相当于找两个儿子中<code>size</code>小的子树，统计答案。</p>
<p>这是启发式合并的逆过程，是一种“启发式分裂”。</p>
<p>如果在笛卡尔树上从底到根做，就是一种启发式合并的过程。</p>
<p>可以发现，直接从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
枚举子树的根和启发式合并，要遍历的总大小是一样的，只是处理每棵子树的顺序变了而已。</p>
<p>所以本题也有很多写法：</p>
<ul>
<li>建笛卡尔树，用set启发式合并，复杂度 <span
class="math inline">\(O(n\log^2 n)\)</span>。</li>
<li>不建笛卡尔树，分治模拟出虚拟笛卡尔树，ST表查区间最大值位置（找区间内左右儿子的分界），复杂度
<span class="math inline">\(O(n\log n)\)</span>。</li>
<li>直接模拟前面写的那个过程，复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</li>
</ul>
<p>代码写的最后一种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],pos[N],lm[N],rm[N];</span><br><span class="line"><span class="type">int</span> sta[N],tp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>]=inf,sta[tp=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&amp;&amp;a[sta[tp]]&lt;a[i])tp--;</span><br><span class="line">        lm[i]=sta[tp];</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    a[n+<span class="number">1</span>]=inf,sta[tp=<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&amp;&amp;a[sta[tp]]&lt;a[i])tp--;</span><br><span class="line">        rm[i]=sta[tp];</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        l=lm[i]+<span class="number">1</span>,r=rm[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;i&amp;&amp;i&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-l&lt;r-i)&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,l,i<span class="number">-1</span>)&#123;</span><br><span class="line">                    p=pos[a[i]-a[j]];</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;p&amp;&amp;p&lt;=r)ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,i+<span class="number">1</span>,r)&#123;</span><br><span class="line">                    p=pos[a[i]-a[j]];</span><br><span class="line">                    <span class="keyword">if</span>(l&lt;=p&amp;&amp;p&lt;i)ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>笛卡尔树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1175F</title>
    <url>/2023/12/01/CF1175F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1175F">The Number of
Subpermutations</a></p>
<span id="more"></span>
<p>和 CF1156E 是同类题，也是 [<a
href="https://h01yshhmy.github.io/2023/11/25/CF1156E/">CF1156E |
h01yshhmy</a>] 中的第二个做法，个人觉得这种做法很有拓展性。</p>
<p>对题意的合法条件做转化：</p>
<ul>
<li><span class="math inline">\([l,r]\)</span> 中没有重复数字。</li>
<li><span class="math inline">\([l,r]\)</span> 中最大值为 <span
class="math inline">\(r-l+1\)</span>。</li>
</ul>
<p>都很显然。</p>
<p>对于第一个条件，设 <span class="math inline">\(pre[i]\)</span> 为
<span class="math inline">\(i\)</span> 前面第一个和 <span
class="math inline">\(a[i]\)</span> 相等的位置。</p>
<p>那么 <span class="math inline">\(\max_{i=l}^rpre[i]&lt;l\)</span>
和第一个条件是等价的。</p>
<p>当然这里可以直接写ST表，不过 <span
class="math inline">\(\max_{i=1}^lpre[i]&lt;l\)</span>
一定成立，所以只需要将 <span class="math inline">\(pre\)</span> 改为
<span class="math inline">\(pre\)</span> 的前缀最大值，判断 <span
class="math inline">\(pre[r]&lt;l\)</span> 即可。</p>
<p>对于第二个条件，ST表即可。</p>
<p>如何寻找区间呢？可以在笛卡尔树上分治。</p>
<p>但是没必要建出笛卡尔树，直接分治是一样的。</p>
<p>对于当前分治区间 <span
class="math inline">\([l,r]\)</span>，找到区间内最大值位置 <span
class="math inline">\(p\)</span>，对于 <span
class="math inline">\([l,p-1\)</span>,<span
class="math inline">\([p+1,r]\)</span> 的子问题显然可以递归。</p>
<p>对于跨过 <span class="math inline">\(p\)</span> 的区间，长度为 <span
class="math inline">\(a[p]\)</span> 才能合法，考虑枚举所有长度为 <span
class="math inline">\(a[p]\)</span> 的跨过 <span
class="math inline">\(p\)</span> 的区间。</p>
<p>要么枚举左端点，要么枚举右端点。</p>
<p>枚举短的那一边就可以保证复杂度，因为枚举的长度每递归一层都至少减半，或者倒过来看，从底向上每次长度至少翻倍。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],pre[N],lg[N],ans;</span><br><span class="line">pii fval[N][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qryPos</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(fval[l][k],fval[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]).se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pos=<span class="built_in">qryPos</span>(l,r),len=a[pos];</span><br><span class="line">    <span class="built_in">solve</span>(l,pos<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(pos+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">if</span>(pos-l&lt;=r-pos)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+len<span class="number">-1</span>&lt;=r&amp;&amp;i+len<span class="number">-1</span>&gt;=pos&amp;&amp;pre[i+len<span class="number">-1</span>]&lt;i)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,pos,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-len+<span class="number">1</span>&gt;=l&amp;&amp;i-len+<span class="number">1</span>&lt;=pos&amp;&amp;pre[i]&lt;i-len+<span class="number">1</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        fval[i][<span class="number">0</span>]=&#123;a[i],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pre[i]=pos[a[i]];</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pre[i]=<span class="built_in">max</span>(pre[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j,<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>)&#123;</span><br><span class="line">            fval[i][j]=<span class="built_in">max</span>(fval[i][j<span class="number">-1</span>],fval[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1192B</title>
    <url>/2023/12/01/CF1192B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1192B">Dynamic
Diameter</a></p>
<span id="more"></span>
<p>首先对题目做形式化的转化。</p>
<p>修改 <span class="math inline">\(q\)</span>
次一条边的边权，每次修改后输出 <span
class="math inline">\(\max\limits_{u,v\in
V}dis[u]+dis[v]-2dis[lca(u,v)]\)</span>，强制在线。（<span
class="math inline">\(dis\)</span> 为到点 <span
class="math inline">\(1\)</span> 带权距离）</p>
<p>树上动态问题可能会想到LCT，这题的确有LCT写法：用矩阵优化朴素求带权直径的DP，然后用LCT维护矩阵（树上DDP）。</p>
<p>不过确实是太矢了。</p>
<p>有另一个做法：欧拉序+线段树。</p>
<p>我们先求出原树的欧拉序 <span class="math inline">\(eu\)</span>。设
<span class="math inline">\(L[u]\)</span>
为在欧拉序中第一次出现位置，<span class="math inline">\(R[u]\)</span>
为最后一次出现位置（注意，欧拉序中一个点可能出现多次）</p>
<p>发现有两个很好的性质：</p>
<ol type="1">
<li><p><span class="math inline">\(lca(u,v)\)</span> 在欧拉序中一定在
<span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间。</p></li>
<li><p>如果在 <span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间有比 <span
class="math inline">\(lca(u,v)\)</span> 深度更浅的节点，那么对于 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的其中一棵树的访问已经结束了，与该点在
<span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间矛盾，也就是说 <span
class="math inline">\(lca(u,v)\)</span>
一定是最浅的点，而此题边权非负，深度换为 <span
class="math inline">\(dis\)</span> 不影响结论。</p></li>
</ol>
<p>形式化一下：</p>
<p><span class="math display">\[
\begin{aligned}
dis[lca(u,v)]=\min\limits_{i=L[u]}^{L[v]}dis[eu[i]]
\end{aligned}
\]</span></p>
<p>（上述其实是ST表+欧拉序 <span class="math inline">\(O(n\log
n)-O(1)\)</span> 求<code>LCA</code>的原理）</p>
<p>那么就可以用线段树维护欧拉序。</p>
<p>如何才能得到最大直径？</p>
<p>可以类比线段树维护连续段的做法。</p>
<p>我们分别维护：</p>
<ol type="1">
<li>区间内最大 <span class="math inline">\(dis\)</span> ，设为 <span
class="math inline">\(w\)</span>。</li>
<li>区间内最大 <span class="math inline">\(-2dis\)</span> ，设为 <span
class="math inline">\(m\)</span>。</li>
<li>区间内 左儿子区间内的 <span class="math inline">\(w\)</span>
减去右儿子内的 <span class="math inline">\(m\)</span> 的最大值（<span
class="math inline">\(dis[u]-2dis[lca]\)</span> 的最大值）设为 <span
class="math inline">\(lm\)</span>。</li>
<li>区间内 右儿子区间内的 <span class="math inline">\(w\)</span>
减去左儿子内的 <span class="math inline">\(m\)</span> 的最大值（<span
class="math inline">\(dis[v]-2dis[lca]\)</span> 的最大值）设为 <span
class="math inline">\(mr\)</span>。</li>
<li>区间内的答案（<span
class="math inline">\(dis[u]+dis[v]-2dis[lca]\)</span> 的最大值）设为
<span class="math inline">\(lmr\)</span> 。</li>
</ol>
<p>考虑怎么合并信息。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;w_u=\max\{w_l,w_r\}\\
&amp;m_u=\max\{m_l,m_r\}\\
&amp;lm_u=\max\{lm_l,lm_r,w_l+m_r\}\\
&amp;mr_u=\max\{mr_l,mr_r,m_l+w_r\}\\
&amp;lmr_u=\max\{lmr_l,lmr_r,lm_l+w_r,w_l+mr_r\}
\end{aligned}
\]</span></p>
<p>对于修改，修改一条边的边权会影响子树内全部 <span
class="math inline">\(dis\)</span>，区间修改即可。</p>
<p>答案就是全局 <span class="math inline">\(lmr\)</span>。</p>
<p>这种思维方式是比较有一般性的，直径的柿子和区间最大子段和 <span
class="math inline">\(\max\limits_{L-1\le l&lt;r\le R}
sum[r]-sum[l]\)</span> 本质相同，动态维护的方法也十分类似。</p>
<p>都是用线段树完成：求一个能拆成上述特殊形式的齐次式子的，二元的最值，此题无非是换成了欧拉序上。</p>
<p>因为线段树维护的是欧拉序，所以4倍空间的线段树要开8倍。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,ll&gt; &gt; G[N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">ll V,val[N],dis[N];</span><br><span class="line"><span class="type">int</span> dfn[N*<span class="number">2</span>],fa[N],tL[N],tR[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dfn[++dfncnt]=u;</span><br><span class="line">    tL[u]=dfncnt;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.fi==f)<span class="keyword">continue</span>;</span><br><span class="line">        dis[v.fi]=dis[u]+v.se;</span><br><span class="line">        <span class="built_in">dfs</span>(v.fi,u);</span><br><span class="line">        dfn[++dfncnt]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    tR[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        ll w,m,lm,mr,lmr,lz;</span><br><span class="line">    &#125;t[N*<span class="number">8</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].w=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].w,t[<span class="built_in">rs</span>(rt)].w);</span><br><span class="line">        t[rt].m=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].m,t[<span class="built_in">rs</span>(rt)].m);</span><br><span class="line">        t[rt].lm=<span class="built_in">max</span>(&#123;t[<span class="built_in">ls</span>(rt)].lm,t[<span class="built_in">rs</span>(rt)].lm,t[<span class="built_in">ls</span>(rt)].w+t[<span class="built_in">rs</span>(rt)].m&#125;);</span><br><span class="line">        t[rt].mr=<span class="built_in">max</span>(&#123;t[<span class="built_in">ls</span>(rt)].mr,t[<span class="built_in">rs</span>(rt)].mr,t[<span class="built_in">ls</span>(rt)].m+t[<span class="built_in">rs</span>(rt)].w&#125;);</span><br><span class="line">        t[rt].lmr=<span class="built_in">max</span>(&#123;</span><br><span class="line">            t[<span class="built_in">ls</span>(rt)].lmr,t[<span class="built_in">rs</span>(rt)].lmr,</span><br><span class="line">            t[<span class="built_in">ls</span>(rt)].w+t[<span class="built_in">rs</span>(rt)].mr,t[<span class="built_in">ls</span>(rt)].lm+t[<span class="built_in">rs</span>(rt)].w</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].w=dis[dfn[l]];</span><br><span class="line">            t[rt].m=<span class="number">-2</span>*dis[dfn[l]];</span><br><span class="line">            t[rt].lm=t[rt].mr=-dis[dfn[l]];</span><br><span class="line">            t[rt].lmr=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,ll v)</span></span>&#123;</span><br><span class="line">        t[rt].w+=v;</span><br><span class="line">        t[rt].m-=<span class="number">2</span>*v;</span><br><span class="line">        t[rt].lm-=v;t[rt].mr-=v;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">            t[rt].lz=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">&#125;E[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;V;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;E[i].u&gt;&gt;E[i].v&gt;&gt;val[i];</span><br><span class="line">        G[E[i].u].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(E[i].v,val[i]));</span><br><span class="line">        G[E[i].v].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(E[i].u,val[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,dfncnt);</span><br><span class="line">    <span class="type">int</span> d=<span class="number">0</span>,u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        d=(d+ans)%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        e=(e+ans)%V;</span><br><span class="line">        u=E[d].u;v=E[d].v;</span><br><span class="line">        <span class="keyword">if</span>(fa[v]==u)<span class="built_in">swap</span>(u,v);</span><br><span class="line">        t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,dfncnt,tL[u],tR[u],e-val[d]);</span><br><span class="line">        val[d]=e;</span><br><span class="line">        ans=t.t[<span class="number">1</span>].lmr;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>欧拉序</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1270G</title>
    <url>/2024/01/14/CF1270G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1270G">Subset with Zero
Sum</a></p>
<span id="more"></span>
<p>非常凭直觉，非常智慧的一道题，没有逻辑。</p>
<p>将式子变形。 <span class="math display">\[
i-n\le a_i\le i-1\Leftrightarrow 1\le i-a_i\le n
\]</span> 建立一个 <span class="math inline">\(n\)</span>
个点的有向图。</p>
<p>对于每个点 <span class="math inline">\(i\)</span>，连边 <span
class="math inline">\(i\to i-a_i\)</span>，记录 <span
class="math inline">\(o_i=i-a_i\)</span>。</p>
<p>出度均为一，图是一个<strong>内向基环树森林</strong>。</p>
<p>容易发现，对于一个环，有： <span class="math display">\[
\begin{aligned}
&amp;\sum_i i=\sum_i o_i\\
&amp;\sum_i i=\sum_{i}i-\sum_ia_i\\
&amp;\sum_{i}a_i=0
\end{aligned}
\]</span> 满足条件。</p>
<p>随便找一个环即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, x, fa[N], vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        fa[i] = i - x, vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!vis[x])</span><br><span class="line">        vis[x] = <span class="number">1</span>, x = fa[x];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    ans.<span class="built_in">pb</span>(x), x = fa[x];</span><br><span class="line">    <span class="keyword">while</span> (x != ans[<span class="number">0</span>])</span><br><span class="line">        ans.<span class="built_in">pb</span>(x), x = fa[x];</span><br><span class="line">    <span class="built_in">write</span>(ans.<span class="built_in">size</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1313E</title>
    <url>/2023/12/22/CF1313E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1313E">Concatenation with
intersection</a></p>
<span id="more"></span>
<p>串串题，只要发现题目和前后缀相关，就要想想前后缀的思路方向好不好写。</p>
<p>发现还挺好写的，不过这题应该是字符串还是DS呢？</p>
<p>定义 <span class="math inline">\(S[l,r]\)</span> 为 <span
class="math inline">\(S\)</span> 中 <span
class="math inline">\(l\)</span> 到 <span
class="math inline">\(r\)</span> 的子串，<span
class="math inline">\(S[:i]\)</span> 为 <span
class="math inline">\(i\)</span> 结尾的前缀，<span
class="math inline">\(S[i:]\)</span> 为 <span
class="math inline">\(i\)</span> 开头的后缀。</p>
<p>有 <span class="math inline">\(a[l_1,r_1]+b[l_2,r_2]=s\)</span>，设
<span class="math inline">\(r_1-l_1+1=x\)</span>，那么 <span
class="math inline">\(r_2-l_2+1=m-x\)</span>。</p>
<p>对于条件一，<span class="math inline">\([l_1,r_1]\cap[l_2,r_2]\ne
\varnothing\)</span>，可得 <span class="math inline">\(r_1\le l_2\land
r_2\ge l_1\)</span>，化简，得到 <span class="math inline">\(l_1\le
r_2\le
l_1+m-2\)</span>（式一），注意这里化简要和下文有<strong>统一性</strong>，留下
<span class="math inline">\(l_1,r_2\)</span> 两点。</p>
<p><span class="math inline">\(a[l_1,r_1]\)</span> 是 <span
class="math inline">\(s\)</span> 的前缀，<span
class="math inline">\(b[l_2,r_2]\)</span> 是 <span
class="math inline">\(s\)</span> 的后缀；这也就意味着 <span
class="math inline">\(1\le x\le\textrm{LCP}(a[l_1:],s)\)</span>，<span
class="math inline">\(1\le m-x\le \textrm{LCS}(b[:r_2],s)\)</span>。</p>
<p>设 <span
class="math inline">\(p_i=\textrm{LCP}(a[i:],s)\)</span>，<span
class="math inline">\(q_i=\textrm{LCS}(b[:i],s)\)</span>，<span
class="math inline">\(p,q\)</span> 均可以通过<span
class="math inline">\(\textrm{exKMP}\)</span>（<span
class="math inline">\(\textrm{Z}\)</span> 函数）在线性复杂度内求出。</p>
<p>有 <span class="math inline">\(1\le x\le p_{l_1},1\le m-x\le
q_{r_2}\)</span>，合并这一共四个不等式，可以得到：<span
class="math inline">\(\max(1,m-q_{r_2})\le x\le
\min(p_{l_1},m-1)\)</span>，做 <span class="math inline">\(p_i\leftarrow
\min(p_i,m-1),q_i\leftarrow\min(q_i,m-1)\)</span>，现在式子变为 <span
class="math inline">\(m-q_{r_2}\le x\le p_{l_1}\)</span>（式二），<span
class="math inline">\(x\)</span> 的个数为 <span
class="math inline">\(p_{l_1}-(m-q_{r_2})+1\)</span>。</p>
<p>综上，我们将两个条件，转化为：对于 <span
class="math inline">\((l_1,r_2)\)</span> 满足 <span
class="math inline">\(l_1\le r_2\le l_1+m-2\land p_{l_1}\ge
m-q_{r_2}\)</span>，合法四元组 <span
class="math inline">\((l_1,r_1,l_2,r_2)\)</span> 的个数是 <span
class="math inline">\(p_{l_1}-(m-q_{r_2})+1\)</span>，求全部个数之和，简单扫描线就可以解决。</p>
<p>具体的，因为下标不太统一，写两个树状数组分别记录 <span
class="math inline">\(p_{l_1}\)</span> 之和的<strong>系数</strong>，
<span class="math inline">\(-(m-q_{r_2})+1\)</span>
的和。记录系数是因为我们扫到谁就要乘谁，不能直接记录和。倒着扫 <span
class="math inline">\(i\)</span>，将 <span
class="math inline">\(i=r_2\)</span>
的贡献<strong>后缀加</strong>到树状数组上（查询直接单点查询），然后对答案贡献
<span class="math inline">\(i=l_1+m-1\)</span>
的部分，如果不越界，再差分，答案减去 <span
class="math inline">\(i=l_1\)</span> 的部分，因为 <span
class="math inline">\(p,q\)</span>
值域和整体不协调，所以代码中树状数组下标做了整体 <span
class="math inline">\(+1\)</span>。</p>
<p>可以发现，每次统计到的 <span
class="math inline">\(r_2\)</span>，都大于对应的 <span
class="math inline">\(l_1\)</span>，且满足 <span
class="math inline">\(p_{l_1}\ge
m-q_{r_2}\)</span>，没有贡献的次序问题。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N], s[N];</span><br><span class="line"><span class="type">int</span> z[N], p[N], q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exKMP</span><span class="params">(<span class="type">int</span> z[], <span class="type">int</span> p[], <span class="type">char</span> t[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r)</span><br><span class="line">            z[i] = <span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            z[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + z[i] &lt;= m &amp;&amp; s[z[i] + <span class="number">1</span>] == s[i + z[i]]) z[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) r = i + z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p[i] &lt; m &amp;&amp; i + p[i] &lt;= n &amp;&amp; s[p[i] + <span class="number">1</span>] == t[i + p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] - <span class="number">1</span> &gt; r) r = i + p[i] - <span class="number">1</span>, l = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll c[N];</span><br><span class="line">    <span class="built_in">BIT</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (x++; x &lt;= n + <span class="number">1</span>; x += <span class="built_in">lowbit</span>(x)) c[x] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (x++; x; x -= <span class="built_in">lowbit</span>(x)) res += c[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t1, t2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; (a + <span class="number">1</span>) &gt;&gt; (b + <span class="number">1</span>) &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exKMP</span>(z, p, a);</span><br><span class="line">    <span class="built_in">reverse</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(s + <span class="number">1</span>, s + m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exKMP</span>(z, q, b);</span><br><span class="line">    <span class="built_in">reverse</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        p[i] = <span class="built_in">min</span>(p[i], m - <span class="number">1</span>), q[i] = <span class="built_in">min</span>(q[i], m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i, n) &#123;</span><br><span class="line">        t1.<span class="built_in">add</span>(m - q[i], <span class="number">1</span>);</span><br><span class="line">        t2.<span class="built_in">add</span>(m - q[i], -m + q[i] + <span class="number">1</span>);</span><br><span class="line">        ans += t1.<span class="built_in">ask</span>(p[i]) * p[i] + t2.<span class="built_in">ask</span>(p[i]);</span><br><span class="line">        <span class="keyword">if</span> (i - m + <span class="number">1</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l = i - m + <span class="number">1</span>;</span><br><span class="line">            ans -= t1.<span class="built_in">ask</span>(p[l]) * p[l] + t2.<span class="built_in">ask</span>(p[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>树状数组</tag>
        <tag>Z函数</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1416D</title>
    <url>/2023/12/01/CF1416D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1416D">Graph and
Queries</a></p>
<span id="more"></span>
<p>重构树好题。</p>
<p>读完题一头雾水，想不到无边权的题竟然是Kruskal重构树。</p>
<p>删边看起来很困难，所以要离线，倒着做，删转加，现在暂时是比较经典的。</p>
<p>但是操作 <span class="math inline">\(1\)</span>
是要正着做的，倒着做的时候无法知道哪些 <span
class="math inline">\(u\)</span> 满足 <span
class="math inline">\(p_u=0\)</span>。</p>
<p>如何解决？先将删边倒着做，按倒序的加边顺序建立重构树，注意对边的处理可以不写边权不排序，实质上是以操作时间戳为关键字排序。</p>
<p>先将没有操作到的边都加进去，再倒着做删边，以加边顺序打时间戳。</p>
<p>因为我们是按照时间戳从小到大排序的，所以重构树满足 <span
class="math inline">\(\forall v\in subtree(u),w[v]\le
w[u]\)</span>（这是重构树性质），<span class="math inline">\(w\)</span>
为重构树上点权，也是操作时间戳，时间戳 <span class="math inline">\(\le
i\)</span> 说明这次merge是第 <span class="math inline">\(i\)</span>
次询问前执行的。</p>
<p>又因为和点 <span class="math inline">\(u\)</span>
有关系的所有并查集merge操作都在 <span class="math inline">\(u\)</span>
到根的链上。</p>
<p>那么对于节点 <span class="math inline">\(u\)</span>，时间戳在 <span
class="math inline">\(u\)</span> 的时间戳 之后 且 和 <span
class="math inline">\(u\)</span> 连通的点构成的点集，恰好是以重构树上
<span class="math inline">\(u\)</span> 的某个祖先 <span
class="math inline">\(v\)</span> 为根的子树。</p>
<p>可以通过重构树上倍增找 <span
class="math inline">\(v\)</span>，倍增找到祖先中深度最浅的时间戳 <span
class="math inline">\(\le\)</span> 当前操作序号的点即可。</p>
<p>也就是说，我们可以快速获得答案的分布区域了。</p>
<p>现在回到正向的时间线，正序处理所有操作 。</p>
<p>问题转化为：查找子树的叶子节点中最大值位置，并将其权值改为 <span
class="math inline">\(0\)</span>。</p>
<p>子树问题转为区间问题，线段树维护重构树叶子序列的最大值位置即可。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m+q)\log
n)\)</span>。</p>
<p>总结。</p>
<p>重构树在做 边权和连通性相关
的问题上，有奇效，但要注意，构建重构树的过程中会丢失边的端点的具体信息，只保留连通性，这类问题如果需要重构树的话，要用其他手段，如线段树等数据结构去具体维护信息。</p>
<p>删边操作要么考虑倒序操作，要么考虑分块询问。</p>
<p>对于前者，可以把倒序的性质用一些数据结构保存下来，在正序操作时利用起来（比如重构树）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">Q</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,q,p[N],totn;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N*<span class="number">2</span>];</span><br><span class="line">pii qr[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tim[Q],ntim[N];</span><br><span class="line"><span class="keyword">namespace</span> buildT&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">    &#125;e[M],buc[M];</span><br><span class="line">    <span class="type">int</span> inG[M];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="built_in">read</span>(buc[i].u,buc[i].v);</span><br><span class="line">            inG[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">            <span class="built_in">read</span>(qr[i].fi,qr[i].se);</span><br><span class="line">            <span class="keyword">if</span>(qr[i].fi==<span class="number">2</span>)&#123;</span><br><span class="line">                inG[qr[i].se]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inG[i])&#123;</span><br><span class="line">                e[++cnt]=buc[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pe</span>(i,q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(qr[i].fi==<span class="number">2</span>)&#123;</span><br><span class="line">                e[++cnt]=buc[qr[i].se];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tim[i]=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">prework</span>();</span><br><span class="line">        <span class="built_in">re</span>(i,n)fa[i]=i;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">        totn=n;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            u=<span class="built_in">findfa</span>(e[i].u);</span><br><span class="line">            v=<span class="built_in">findfa</span>(e[i].v);</span><br><span class="line">            <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">                totn++;</span><br><span class="line">                fa[totn]=totn;</span><br><span class="line">                fa[u]=fa[v]=totn;</span><br><span class="line">                ntim[totn]=i;</span><br><span class="line">                G[totn].<span class="built_in">pb</span>(u);</span><br><span class="line">                G[totn].<span class="built_in">pb</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> anc[N][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> tL[N],tR[N],rev[N],leafc;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,<span class="number">20</span>)&#123;</span><br><span class="line">        anc[u][i]=anc[anc[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tL[u]=n*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        anc[v][<span class="number">0</span>]=u;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        tL[u]=<span class="built_in">min</span>(tL[u],tL[v]);</span><br><span class="line">        tR[u]=<span class="built_in">max</span>(tR[u],tR[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(G[u].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++leafc;</span><br><span class="line">        tL[u]=tR[u]=leafc;</span><br><span class="line">        rev[leafc]=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAnc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">20</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i]&amp;&amp;ntim[anc[u][i]]&lt;=x)&#123;</span><br><span class="line">            u=anc[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    pii t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt]=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)],t[<span class="built_in">rs</span>(rt)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt]=&#123;p[rev[l]],l&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].fi=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pii <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> t[rt];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;pii res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    buildT::<span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,totn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)==i)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qr[i].fi==<span class="number">1</span>)&#123;</span><br><span class="line">            u=qr[i].se;</span><br><span class="line">            v=<span class="built_in">getAnc</span>(u,tim[i]);</span><br><span class="line">            pii res=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,tL[v],tR[v]);</span><br><span class="line">            <span class="built_in">write</span>(res.fi,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(res.fi)&#123;</span><br><span class="line">                t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,res.se);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>离线</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1418G</title>
    <url>/2023/12/11/CF1418G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1418G">Three
Occurrences</a></p>
<span id="more"></span>
<p>数区间。</p>
<ol type="1">
<li>考虑每个位置的贡献范围</li>
<li>分治</li>
<li>枚举端点</li>
</ol>
<p>经典三选一，尝试枚举端点。</p>
<p>先想如何判断一个区间合法。</p>
<p>如果能对每种数都建一个模 <span class="math inline">\(3\)</span>
意义下的前缀个数和 <span
class="math inline">\(s\)</span>，那么每种数都要满足 <span
class="math inline">\(s_{l-1}=s_r\)</span>——注意这是必要不充分的。</p>
<p>发现 <span class="math inline">\(a\)</span> 的值域为 <span
class="math inline">\([1,n]\)</span>，求出 <span
class="math inline">\(s\)</span>：<span
class="math inline">\(s_i=x\times B^{a[i]}\mod P\)</span>，<span
class="math inline">\(x\)</span> 为模三意义下 <span
class="math inline">\(a[i]\)</span>
在前缀中出现次数，此题要写双哈希，将两种 <span
class="math inline">\(s\)</span> 拼起来即可。</p>
<p>现在思考怎么让判断变得充分。</p>
<p>回到枚举端点的部分，使用双指针的写法，可以枚举左端点，让右端点<strong>尽可能</strong>向右拓展，直到有出现次数大于三的数，这样在当前
<span class="math inline">\([l,r]\)</span> 内，只要出现 <span
class="math inline">\(s_{i-1}=s_j,i&lt;j\)</span>，那么 <span
class="math inline">\([i,j]\)</span>
一定合法，显然，右端点不可能返回，这样扫是正确的。</p>
<p>当然我们并不需要（且不能）数 <span
class="math inline">\([l,r]\)</span>
中的每一个合法区间——枚举左端点的目的就是利用左端点做不重不漏的计数，只计算
<span class="math inline">\(i=l\)</span>
的即可，动态用桶记录当前双指针内出现的每种 <span
class="math inline">\(s\)</span> 的个数，并对答案贡献 <span
class="math inline">\(cnt(s_{l-1})\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">mod1</span><span class="params">(<span class="number">998244353</span>)</span>,<span class="title">mod2</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span>,<span class="title">B</span><span class="params">(<span class="number">13331</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],s[N],s1[N],s2[N],b1[N],b2[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; c1,c2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    x+=b;<span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    b1[<span class="number">0</span>]=b2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        b1[i]=b1[i<span class="number">-1</span>]*B%mod1;</span><br><span class="line">        b2[i]=b2[i<span class="number">-1</span>]*B%mod2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        c1[a[i]]++;</span><br><span class="line">        s1[i]=(s1[i<span class="number">-1</span>]+b1[a[i]])%mod1;</span><br><span class="line">        s2[i]=(s2[i<span class="number">-1</span>]+b2[a[i]])%mod2;</span><br><span class="line">        <span class="keyword">if</span>(c1[a[i]]==<span class="number">3</span>)&#123;</span><br><span class="line">            c1[a[i]]=<span class="number">0</span>;</span><br><span class="line">            s1[i]=((s1[i]<span class="number">-3</span>*b1[a[i]])%mod1+mod1)%mod1;</span><br><span class="line">            s2[i]=((s2[i]<span class="number">-3</span>*b2[a[i]])%mod2+mod2)%mod2;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]=s2[i]*<span class="number">1000000011</span>+s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(l,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n&amp;&amp;c1[a[r+<span class="number">1</span>]]&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            c1[a[r]]++;</span><br><span class="line">            c2[s[r]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=c2[s[l<span class="number">-1</span>]];</span><br><span class="line">        c1[a[l]]--;</span><br><span class="line">        c2[s[l]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1671E</title>
    <url>/2023/12/01/CF1671E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1671E">Preorder</a></p>
<span id="more"></span>
<p>考虑DP，设 <span class="math inline">\(f_u\)</span> 为以 <span
class="math inline">\(u\)</span> 为根子树内答案。</p>
<p>基础的想法是 <span class="math inline">\(f_u=2\times f_{lson}\times
f_{rson}\)</span> 乘法原理</p>
<p>但考虑到可能两个子树是“AB同构”的：存在一种交换方式
使得左子树与右子树的先序遍历产生AB串相同。</p>
<p>这种情况下 就不能乘2了。因为它们本质相同——交换过来后
每一种方案都在交换前出现过。</p>
<p>问题在于怎么判断两个子树是否同构。</p>
<p>直接判断先序遍历是否相等是不妥的，可能出现同构但遍历序列内有顺序颠倒。</p>
<p>所以我们可以直接钦定顺序
取子树内字典序最小的遍历方法判断同构就好了。</p>
<p>递归边界不是严格 <span
class="math inline">\([1,n]\)</span>，记得开双倍空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,f[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">string has[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rs</span>(rt)&gt;n)&#123;</span><br><span class="line">        f[rt]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">ls</span>(rt));</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">rs</span>(rt));</span><br><span class="line">    has[rt]=s[rt];</span><br><span class="line">    f[rt]=f[<span class="built_in">ls</span>(rt)]*<span class="number">1ll</span>*f[<span class="built_in">rs</span>(rt)]%Mod;</span><br><span class="line">    <span class="keyword">if</span>(has[<span class="built_in">ls</span>(rt)]!=has[<span class="built_in">rs</span>(rt)])f[rt]=f[rt]*<span class="number">2ll</span>%Mod;</span><br><span class="line">    <span class="keyword">if</span>(has[<span class="built_in">ls</span>(rt)]&lt;has[<span class="built_in">rs</span>(rt)])has[rt]+=has[<span class="built_in">ls</span>(rt)]+has[<span class="built_in">rs</span>(rt)];</span><br><span class="line">    <span class="keyword">else</span> has[rt]+=has[<span class="built_in">rs</span>(rt)]+has[<span class="built_in">ls</span>(rt)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        has[i]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1687C</title>
    <url>/2023/12/01/CF1687C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1687C">Sanae and Giant
Robot</a></p>
<span id="more"></span>
<p>比较思维的题。</p>
<p>题目看起来很难做。</p>
<p>在题意描述的过程中没有找到性质，就尝试写数学式子。</p>
<p>区间之和相同看起来比较有用。</p>
<p>由 <span
class="math inline">\(\sum\limits_{i=l}^ra[i]=\sum\limits_{i=l}^rb[i]\)</span>
可得：<span class="math inline">\(\sum\limits_{i=l}^r
a[i]-b[i]=0\)</span>。（所以说合并下标相同的项是重要的）</p>
<p>设 <span class="math inline">\(c[i]=a[i]-b[i]\)</span>，发现要求变为
<span class="math inline">\(\sum\limits_{i=l}^rc[i]=0\)</span>。</p>
<p>回到将 <span class="math inline">\(b\)</span> 覆盖到 <span
class="math inline">\(a\)</span> 上的操作中，执行操作 <span
class="math inline">\((l,r)\)</span> 本质上是对 这一段的 <span
class="math inline">\(c\)</span> 整体赋值为 <span
class="math inline">\(0\)</span>，操作目标也就转化为 <span
class="math inline">\(\forall i\in[1,n],c[i]=0\)</span>。</p>
<p>对 <span class="math inline">\(c\)</span> 求前缀和 <span
class="math inline">\(s\)</span>，<span
class="math inline">\(s[r]-s[l-1]=0\)</span> 和
可以执行操作互为充要条件，且操作的本质变为对 <span
class="math inline">\([l,r]\)</span> 这一段的 <span
class="math inline">\(s\)</span> 整体赋值为 <span
class="math inline">\(s[l-1]\)</span>。</p>
<p>操作目标变为 <span class="math inline">\(\forall
i\in[1,n],s[i]=0\)</span>。</p>
<p>但是我们对执行操作的策略依然是一头雾水。</p>
<p>可以感性理解一下：每次选择 <span
class="math inline">\(s[l-1]=s[r]=0\)</span> 的 <span
class="math inline">\((l,r)\)</span> 一定更优，否则一定不会更优。</p>
<p>因为能对 <span class="math inline">\(s\)</span> 中 <span
class="math inline">\(0\)</span> 个数产生贡献的操作只能是 <span
class="math inline">\(s[r]=s[l-1]=0\)</span>
的，其他任何操作即使让一个不能匹配的 <span
class="math inline">\((l,r)\)</span> 找到了 <span
class="math inline">\(a\)</span> 中的匹配位置，也没有意义，因为不能增加
<span
class="math inline">\(0\)</span>。（不会严谨证明，只能这么说了）</p>
<p>思考怎么快速找到 <span class="math inline">\(s[r]=s[l-1]=0\)</span>
的 <span class="math inline">\((l,r)\)</span>。</p>
<p>发现 <span class="math inline">\((l,r)\)</span>
变多肯定是因为我们做了操作，也就是要在做操作的过程中，处理是否会制造更多
<span
class="math inline">\((l,r)\)</span>，这些区间是在“向外扩展”的，这很像是在广搜。</p>
<p>转成图论问题。</p>
<p>在所有 <span class="math inline">\(l-1\)</span> 和 <span
class="math inline">\(r\)</span>
连双向边，用<code>BFS</code>遍历整个图，初始在队列里加入 <span
class="math inline">\(\{i|s[i]=0\}\)</span>。</p>
<p>用<code>set</code>动态维护 <span class="math inline">\(\{i|s[i]\ne
0\}\)</span>，如果遍历到一条边 <span
class="math inline">\((u,v)\)</span> 满足 <span
class="math inline">\(s[v]=0\)</span>，直接暴力遍历set中位于 <span
class="math inline">\((u,v)\)</span> 之间的位置，把这些位置都覆盖上
<span class="math inline">\(0\)</span>，加入BFS队列，从set中删除。</p>
<p>答案只需要判断 <code>set.empty()</code> 即可。</p>
<p>容易发现每条边都只会被遍历两次，一个点也只会入队一次，出队一次，在<code>set</code>中同理。</p>
<p>多测别忘了清空。不要忘了点编号从 <span
class="math inline">\(0\)</span> 开始。（因为 <span
class="math inline">\(l-1\ge 0\)</span>，调了好久）</p>
<p>时间复杂度 <span class="math inline">\(O(T(n+m)\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T,n,m,a[N],b[N];</span><br><span class="line">ll sum[N],c[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            c[i]=a[i]-b[i];</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i])s.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n)G[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r);</span><br><span class="line">            G[l<span class="number">-1</span>].<span class="built_in">pb</span>(r);</span><br><span class="line">            G[r].<span class="built_in">pb</span>(l<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[v])<span class="keyword">continue</span>;</span><br><span class="line">                l=<span class="built_in">min</span>(u,v),r=<span class="built_in">max</span>(u,v);</span><br><span class="line">                <span class="keyword">auto</span> it=s.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">while</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;(*it)&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> p=*it;</span><br><span class="line">                    sum[p]=<span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(p);</span><br><span class="line">                    <span class="keyword">auto</span> era=it;it++;</span><br><span class="line">                    s.<span class="built_in">erase</span>(era);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1753C</title>
    <url>/2023/12/01/CF1753C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1753C">Wish I Knew How to
Sort</a></p>
<span id="more"></span>
<p>这种过程较为复杂难以计数的题 考虑最终状态的性质。</p>
<p>最终一定是 <code>000...111</code>，所以考虑对 <span
class="math inline">\(0\)</span> 的个数做<code>DP</code>。</p>
<p>设一共有 <span class="math inline">\(cnt\)</span> 个 <span
class="math inline">\(0\)</span>，<span
class="math inline">\(f_i\)</span> 为前 <span
class="math inline">\(i\)</span> 个位置中放了 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span>。</p>
<p><span
class="math inline">\(f_i=f_{i-1}+\dfrac{C_n^2}{(cnt-i+1)^2}\)</span></p>
<p>这是为什么呢？</p>
<p>考虑期望的线性性，每次我们是在算 <span
class="math inline">\(i-1\)</span> 个 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span> 状态的期望。全部的操作方案为 <span
class="math inline">\(C_n^2\)</span>，而需要的操作方案是前 <span
class="math inline">\(cnt\)</span> 个位置中 <span
class="math inline">\(1\)</span> 的个数 <span
class="math inline">\(\times\)</span> 后 <span
class="math inline">\(n-cnt+1\)</span> 个位置中 <span
class="math inline">\(0\)</span> 的个数。</p>
<p>对于当前 <span class="math inline">\(i-1\)</span> 个 <span
class="math inline">\(0\)</span> 的状态来说，这两个个数都是 <span
class="math inline">\(cnt-i+1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T,n,a[N],cnt,f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n)cnt+=(a[i]==<span class="number">0</span>);</span><br><span class="line">        pre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,cnt)pre+=(a[i]==<span class="number">0</span>);</span><br><span class="line">        f[pre]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,pre+<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            f[i]=(f[i<span class="number">-1</span>]+(n*(n<span class="number">-1</span>)/<span class="number">2</span>)%Mod*<span class="built_in">qpow</span>((cnt-i+<span class="number">1</span>)*(cnt-i+<span class="number">1</span>),Mod<span class="number">-2</span>)%Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[cnt]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1793F</title>
    <url>/2023/12/29/CF1793F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1793F">Rebrending</a></p>
<span id="more"></span>
<p>三倍经验：<a
href="https://www.luogu.com.cn/problem/CF765F">CF765F</a>，<a
href="https://www.luogu.com.cn/problem/P5926">P5926</a>。</p>
<p>这东西其实是支配对。</p>
<p>首先离线全部询问，对当前右端点考虑每个左端点的答案，最后答案点对显然有两种，对前大后小和前小后大分类讨论，前者可以通过后者反转值域来做，所以只需要考虑前者。</p>
<p>考虑对于当前的 <span class="math inline">\(a_x\)</span>
有哪些点的答案可能发生变化，假设在 <span
class="math inline">\(x\)</span> 前面第一个比 <span
class="math inline">\(a_x\)</span> 小的位置是 <span
class="math inline">\(y\)</span>，那么 <span
class="math inline">\(a_y\)</span> 可能会有贡献，再往前走，显然比 <span
class="math inline">\(a_y\)</span> 小的数是没有贡献的，因为它们和 <span
class="math inline">\(a_y\)</span> 的差值一定小于和 <span
class="math inline">\(a_x\)</span> 的差值，所以要找的数满足 <span
class="math inline">\(a_z\in[a_y,a_x],z\in[y,x-1]\)</span>。</p>
<p>这样的 <span class="math inline">\(z\)</span>
显然有很多。但是发现由于 <span class="math inline">\(y\)</span>
的存在，如果 <span
class="math inline">\(a_z&lt;\frac{a_x+a_y}{2}\)</span>，那么 <span
class="math inline">\(z\)</span> 在 <span
class="math inline">\(y\)</span> 处更新一定比 <span
class="math inline">\(x\)</span> 更优，显然在值域上 <span
class="math inline">\(a_z\)</span> 距离 <span
class="math inline">\(a_y\)</span> 更近。所以需要更新的 <span
class="math inline">\(z\)</span> 一定满足 <span
class="math inline">\(a_z\ge
\frac{a_x+a_y}{2}\)</span>，值域被缩小了一半，不断用树状数组维护答案，每次单点改，查询后缀最小值。找
<span class="math inline">\(z\)</span>
的过程需要写一个值域线段树，维护当前前缀上每个 <span
class="math inline">\(a_i\)</span> 的<span
class="math inline">\(i\)</span>，在 <span
class="math inline">\([0,a_x]\)</span> 中找出现过的最大下标即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n+q\log
n)\)</span>，细节见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;wh)</span></span>&#123;</span><br><span class="line">    wh=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> w=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(w&lt;<span class="string">&#x27;0&#x27;</span>||w&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(w==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;w=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(w&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;w&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;wh=wh*<span class="number">10</span>+w-<span class="string">&#x27;0&#x27;</span>;w=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    wh*=f;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m,n,root,a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aa&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> lowbit (wh&amp;-wh)</span></span><br><span class="line">  <span class="type">int</span> t[N];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> wh,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;wh;wh-=lowbit)t[wh]=<span class="built_in">min</span>(t[wh],val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> wh)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> an=inf;<span class="keyword">for</span>(;wh&lt;=m;wh+=lowbit)an=<span class="built_in">min</span>(an,t[wh]);<span class="keyword">return</span> an;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(t,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(t));&#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> lowbit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> bb&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> lc t[wh].left</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rc t[wh].right</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> left,right,data;&#125;t[N&lt;&lt;<span class="number">6</span>];<span class="type">int</span> cnt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)t[i]=t[<span class="number">0</span>];cnt=root=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;wh,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pl,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wh==<span class="number">0</span>)wh=++cnt;t[wh].data=<span class="built_in">max</span>(t[wh].data,val);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pl&lt;=mid)<span class="built_in">ins</span>(lc,l,mid,pl,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(rc,mid+<span class="number">1</span>,r,pl,val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> wh,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> wl,<span class="type">int</span> wr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wh==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(wl&lt;=l&amp;&amp;r&lt;=wr)<span class="keyword">return</span> t[wh].data;</span><br><span class="line">    <span class="type">int</span> an=<span class="number">0</span>;<span class="keyword">if</span>(wl&lt;=mid)an=<span class="built_in">max</span>(an,<span class="built_in">work</span>(lc,l,mid,wl,wr));</span><br><span class="line">    <span class="keyword">if</span>(wr&gt;mid)an=<span class="built_in">max</span>(an,<span class="built_in">work</span>(rc,mid+<span class="number">1</span>,r,wl,wr));<span class="keyword">return</span> an;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> an[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;<span class="type">int</span> l,r,id;&#125;q[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(query s1,query s2)&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.r&lt;s2.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> pl=bb::<span class="built_in">work</span>(root,<span class="number">0</span>,inf,<span class="number">0</span>,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(pl)&#123;</span><br><span class="line">      aa::<span class="built_in">change</span>(pl,a[i]-a[pl]);<span class="keyword">if</span>(a[i]==a[pl])<span class="keyword">break</span>;</span><br><span class="line">      pl=bb::<span class="built_in">work</span>(root,<span class="number">0</span>,inf,(a[pl]+a[i]+<span class="number">1</span>)/<span class="number">2</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    bb::<span class="built_in">ins</span>(root,<span class="number">0</span>,inf,a[i],i);</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=n&amp;&amp;q[j].r==i)&#123;</span><br><span class="line">      an[q[j].id]=<span class="built_in">min</span>(an[q[j].id],aa::<span class="built_in">work</span>(q[j].l));++j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(m);<span class="built_in">read</span>(n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(q[i].l),<span class="built_in">read</span>(q[i].r),q[i].id=i;</span><br><span class="line">  <span class="built_in">memset</span>(an,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(an));<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">  aa::<span class="built_in">init</span>();<span class="built_in">solve</span>();aa::<span class="built_in">init</span>();bb::<span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]=inf-a[i];<span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,an[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
        <tag>树状数组</tag>
        <tag>二分</tag>
        <tag>支配对</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1806E</title>
    <url>/2023/12/01/CF1806E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1806E">Tree
Master</a></p>
<span id="more"></span>
<p>此题有很多做法：树分块，随机撒点，树上莫队。</p>
<p>但是都不如根号分治记搜好写。</p>
<p>所以写记搜。</p>
<p>发现这个题虽然一股数据结构味道，但是并不带修。</p>
<p>所以可以做很多预处理。</p>
<p>可能会想到优化 <span class="math inline">\(O(qn)\)</span>
暴力跳父亲的过程。</p>
<p>但不太好优化，转换思路——更直接一点，设 <span
class="math inline">\(f[u][v]\)</span> 为询问 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的答案。</p>
<p>不过记不下来这么多，所以改成 <span
class="math inline">\(f[u][i]\)</span> 为点 <span
class="math inline">\(u\)</span> 和这一层中第 <span
class="math inline">\(i\)</span> 个点的答案，且只记点数 <span
class="math inline">\(\le \sqrt{n}\)</span> 的层。</p>
<p>直接在暴力上跳的过程中记 <span class="math inline">\(f\)</span>
即可，就是记忆化搜索。</p>
<p>复杂度分析：</p>
<p>对于节点个数 <span class="math inline">\(\ge \sqrt{n}\)</span>
的层，一共 <span class="math inline">\(&lt; \sqrt{n}\)</span>
个，每一层跳的次数最多有 <span class="math inline">\(q\)</span>
次（询问都经过这一层），所以复杂度为 <span
class="math inline">\(O(q\sqrt{n})\)</span>。</p>
<p>对于节点个数 <span class="math inline">\(\le \sqrt{n}\)</span>
的层，设这一层有 <span class="math inline">\(m\)</span>
个点，最劣情况在当前层向上跳要跳 <span
class="math inline">\(m^2\)</span> 次（对当前层所有 <span
class="math inline">\(f[u][i]\)</span> 都记了一遍答案），一共最多有
<span class="math inline">\(\frac{n}{m}\)</span> 个这样的层，复杂度
<span class="math inline">\(m^2\times \frac{n}{m}=nm\)</span>，因为
<span class="math inline">\(m\le \sqrt{n}\)</span>，所以复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>总复杂度 <span
class="math inline">\(O((q+n)\sqrt{n})\)</span>，可以通过。</p>
<p>注：代码中 <span class="math inline">\(idx[u]\)</span> 是 <span
class="math inline">\(u\)</span>
在它那一层中的编号（当然，这一层的点数应该是 <span
class="math inline">\(\le \sqrt{n}\)</span>
的），这样写方便塞到连续的一段数组内，上述全部的“层”都是深度相关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,q,a[N],d[N],c[N],p[N],fa[N];</span><br><span class="line">ll f[N][<span class="number">500</span>];</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==y)<span class="keyword">return</span> s[x];</span><br><span class="line">  <span class="keyword">if</span>(c[d[x]]&lt;<span class="number">500</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][p[y]])<span class="keyword">return</span> f[x][p[y]];</span><br><span class="line">    <span class="keyword">return</span> f[x][p[y]]=<span class="built_in">solve</span>(fa[x],fa[y])+(ll)a[x]*a[y];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(fa[x],fa[y])+(ll)a[x]*a[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n,q);</span><br><span class="line">  <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">2</span>,n)<span class="built_in">read</span>(fa[i]);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    s[i]=s[fa[i]]+(ll)a[i]*a[i];</span><br><span class="line">    d[i]=d[fa[i]]+<span class="number">1</span>;</span><br><span class="line">    p[i]=++c[d[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="built_in">read</span>(x,y);</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">solve</span>(x,y),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>我会根号</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1814D</title>
    <url>/2023/12/01/CF1814D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1814D">Balancing
Weapons</a></p>
<span id="more"></span>
<p>求最小调整次数，使得极差 <span class="math inline">\(\le
k\)</span></p>
<p>我们需要让调整次数尽量少，尽可能集中在一起。</p>
<p>显然，一定有一个 <span class="math inline">\(p_x\)</span>
是不动的，枚举这个 <span class="math inline">\(x\)</span>。</p>
<p>对于其他的，贪心的想，一共就只有三种取值：</p>
<ol type="1">
<li><span class="math inline">\(p_i=f_i\times d_i\)</span></li>
<li><span class="math inline">\(p_i=f_i\times
\lfloor\frac{p_x}{f_i}\rfloor\)</span></li>
<li><span class="math inline">\(p_i=f_i\times
\lceil\frac{p_x}{f_i}\rceil\)</span></li>
</ol>
<p>对所有的 <span class="math inline">\(p_i\)</span>
算出全部三种取值，以取值为关键字排序，用双指针找尽可能长的极差 <span
class="math inline">\(\le k\)</span>
的区间即可，区间越长越有可能包括全部 <span
class="math inline">\(n\)</span> 个。</p>
<p>在双指针扫描过程中，动态维护区间内包含的不同 <span
class="math inline">\(i\)</span> 的个数，如果区间内包括了全部 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(i\)</span> 的至少一种取值，就更新答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2\log
n)\)</span>，瓶颈在排序。</p>
<p>官方题解有更优复杂度：，被爆了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3005</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> node = <span class="keyword">struct</span> &#123;<span class="type">int</span> val, id, typ;&#125;;</span><br><span class="line"><span class="type">int</span> n, k, f[N], d[N], p[N], cnt[N];</span><br><span class="line"><span class="type">int</span> now, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> node&amp; x)</span> </span>&#123;</span><br><span class="line">  now -= x.typ;</span><br><span class="line">  cnt[x.id]++;</span><br><span class="line">  <span class="keyword">if</span> (cnt[x.id] == <span class="number">1</span>) tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">const</span> node&amp; x)</span> </span>&#123;</span><br><span class="line">  now += x.typ;</span><br><span class="line">  cnt[x.id]--;</span><br><span class="line">  <span class="keyword">if</span> (cnt[x.id] == <span class="number">0</span>) tot--;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  vec.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    cnt[i] = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&#123;p[i], i, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="type">int</span> tmp = x / f[i] * f[i];</span><br><span class="line">    <span class="keyword">if</span> (tmp) vec.<span class="built_in">push_back</span>(&#123;tmp, i, <span class="number">0</span>&#125;);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&#123;tmp + f[i], i, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">range</span>(vec), [](node x, node y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.val &lt; y.val;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>, res = n, len = vec.<span class="built_in">size</span>();</span><br><span class="line">  now = n, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (pos + <span class="number">1</span> &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[pos + <span class="number">1</span>].val &lt;= vec[i].val + k) &#123;</span><br><span class="line">      <span class="built_in">add</span>(vec[++pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)<span class="built_in">del</span>(vec[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (tot == n)res = <span class="built_in">min</span>(res, now);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">read</span>(T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">read</span>(n, k);</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      <span class="built_in">read</span>(f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      <span class="built_in">read</span>(d[i]);</span><br><span class="line">      p[i] = f[i] * d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, <span class="built_in">solve</span>(p[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1830D</title>
    <url>/2023/12/23/CF1830D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1830D">Mex Tree</a></p>
<span id="more"></span>
<p>首先，<span class="math inline">\(\textrm{mex}\)</span> 显然最大只有
<span class="math inline">\(2\)</span>。</p>
<p>在一条路径上，只要 <span class="math inline">\(0,1\)</span>
都出现了，就可以贡献 <span
class="math inline">\(2\)</span>。有一个简单的贪心是按照深度间隔染色，这样任意
<span class="math inline">\((i,j),i\ne
j\)</span>之间都有两种颜色，设点权为 <span
class="math inline">\(w\)</span>，答案为 <span
class="math inline">\(n(n+1)-\sum[w_u=0]-2\sum[w_u=1]=n(n+1)-n-\sum[w_u=1]\)</span>。</p>
<p>这种贪心是显然错误的，我们可以使大量的点集中在某一个染 <span
class="math inline">\(1\)</span>
的层上，这样就需要做一些调整，使一些边的两端颜色相同。</p>
<p>但是，这个贪心为我们提供了一个答案下界，且下界是较为接近答案的。</p>
<p>这个时候需要换一个角度，从反方向上想，发现贡献小于 <span
class="math inline">\(2\)</span>
的条件是十分苛刻的：当且仅当路径上只有一种颜色，这启发我们逆向思考，对每种颜色的连通块分别考虑，假设全部都可以取
<span class="math inline">\(2\)</span>，算最小损失。</p>
<p>初始情况设 <span
class="math inline">\(ans=n(n+1)\)</span>，对于一个大小为 <span
class="math inline">\(i\)</span>，颜色为 <span
class="math inline">\(j\in\{0,1\}\)</span> 的连通块，会使答案减小 <span
class="math inline">\(\frac{i(i+1)}{2}\times (j+1)\)</span>。</p>
<p>考虑DP，求 <span class="math inline">\(ans\)</span>
要减去的最小值。</p>
<p>设 <span class="math inline">\(f(u,c,i)\)</span> 为：以 <span
class="math inline">\(u\)</span> 为根的子树，<span
class="math inline">\(u\)</span> 所在连通块大小为 <span
class="math inline">\(i\)</span>，颜色为 <span
class="math inline">\(c\)</span> 的最小负贡献。</p>
<p>注意到我们前面的贪心给出了上界，也就是 <span
class="math inline">\(n+\sum[c_u=1]\)</span>，这是 <span
class="math inline">\(O(n)\)</span> 级别的。</p>
<p>又注意到连通块的大小也是 <span class="math inline">\(O(n)\)</span>
的，而对答案的贡献是 <span class="math inline">\(\frac{i(i+1)}{2}\times
(j+1)\)</span>，<span class="math inline">\(O(n^2)\)</span> 级别，所以
<span class="math inline">\(i\)</span> 只需要枚举到 <span
class="math inline">\(O(\sqrt{n})\)</span>，超出上界的部分是不需要的。</p>
<p>这个状态设计是十分背包的，遍历到 <span
class="math inline">\(u\)</span> 和一个儿子 <span
class="math inline">\(v\)</span> 时，计算两个枚举上界 <span
class="math inline">\(Bu=\sqrt{siz[u]-1}\)</span> 和 <span
class="math inline">\(Bv=\sqrt{siz[v]-1}\)</span>，枚举 <span
class="math inline">\(j\in [1,Bu],k\in[1,Bv]\)</span>，做 <span
class="math inline">\(f(u,c&#39;,j+k)=\min(f(u,c&#39;,j+k),f(u,c&#39;,j)+f(v,c,k)+W)\)</span>
的转移。如果 <span class="math inline">\(c\ne c&#39;\)</span>，<span
class="math inline">\(W=0\)</span>，否则 <span
class="math inline">\(c=c&#39;=0\)</span>，<span
class="math inline">\(W=j\times k\)</span>；<span
class="math inline">\(c=c&#39;=1\)</span>，<span
class="math inline">\(W=2\times j\times k\)</span>。</p>
<p>朴素实现会被卡空间，用 <code>vector&lt;int&gt;</code>
做DP数组，及时清空，清空一定要写
<code>vector&lt;int&gt;().swap(f)</code> 的形式，可以释放空间。</p>
<p>时间复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，树上背包，不再证明了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, sqN = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> n, siz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], f[N][<span class="number">2</span>], g[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">0</span>].<span class="built_in">clear</span>(), g[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1</span>) f[u][i].<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>] = f[u][<span class="number">1</span>][<span class="number">0</span>] = inf;</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, f[u][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="type">int</span> B = <span class="built_in">min</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(siz[u] + siz[v] - <span class="number">1</span>) + <span class="number">1</span>, sqN);</span><br><span class="line">        <span class="type">int</span> Bu = <span class="built_in">min</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(siz[u] - <span class="number">1</span>) + <span class="number">1</span>, sqN);</span><br><span class="line">        <span class="type">int</span> Bv = <span class="built_in">min</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(siz[v] - <span class="number">1</span>) + <span class="number">1</span>, sqN);</span><br><span class="line">        g[<span class="number">0</span>].<span class="built_in">resize</span>(B + <span class="number">1</span>), g[<span class="number">1</span>].<span class="built_in">resize</span>(B + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1</span>) <span class="built_in">fill</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>(), inf);</span><br><span class="line">        <span class="built_in">re</span>(i, Bu) &#123;</span><br><span class="line">            <span class="built_in">re</span>(j, Bv) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; B) &#123;</span><br><span class="line">                    g[<span class="number">0</span>][i + j] = <span class="built_in">min</span>(g[<span class="number">0</span>][i + j], f[u][<span class="number">0</span>][i] + f[v][<span class="number">0</span>][j] + i * j);</span><br><span class="line">                    g[<span class="number">1</span>][i + j] = <span class="built_in">min</span>(g[<span class="number">1</span>][i + j], f[u][<span class="number">1</span>][i] + f[v][<span class="number">1</span>][j] + <span class="number">2</span> * i * j);</span><br><span class="line">                &#125;</span><br><span class="line">                g[<span class="number">0</span>][i] = <span class="built_in">min</span>(g[<span class="number">0</span>][i], f[u][<span class="number">0</span>][i] + f[v][<span class="number">1</span>][j]);</span><br><span class="line">                g[<span class="number">1</span>][i] = <span class="built_in">min</span>(g[<span class="number">1</span>][i], f[u][<span class="number">1</span>][i] + f[v][<span class="number">0</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1</span>) f[u][i] = g[i], <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(f[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i, n) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v), G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : f[<span class="number">1</span>][<span class="number">0</span>]) ans = <span class="built_in">min</span>(ans, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : f[<span class="number">1</span>][<span class="number">1</span>]) ans = <span class="built_in">min</span>(ans, i);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1ll</span> * n * (n + <span class="number">1</span>) - ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1856E2</title>
    <url>/2023/12/10/CF1856E2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1856E2">PermuTree (hard
version)</a></p>
<span id="more"></span>
<h2 id="easy-ver">Easy ver</h2>
<p>考虑一个局部的贪心。</p>
<p>填数字的方式要类似于二叉查找树，显然 <span
class="math inline">\(u\)</span> 的儿子 <span
class="math inline">\(v\)</span> 中子树内不需要填和 <span
class="math inline">\(u\)</span>
偏序关系不同的点，这样<code>lca</code>不是 <span
class="math inline">\(u\)</span>，一定不会更优。</p>
<p>对于 <span class="math inline">\(u\)</span> 有两个儿子 <span
class="math inline">\(v,w\)</span> 的情况，可以让 <span
class="math inline">\(v\)</span> 子树中权值均小于 <span
class="math inline">\(w\)</span> 子树中权值，这样 <span
class="math inline">\(u\)</span> 造成的贡献是 <span
class="math inline">\(siz[v]\times siz[w]\)</span>，显然是最优的。</p>
<p>推广到多个儿子的情况，可以将儿子分成两个集合 <span
class="math inline">\(A,B\)</span>，最大化 <span
class="math inline">\(\sum\limits_{i\in A}siz[i]\times \sum\limits_{i\in
B}siz[i]\)</span>。</p>
<p>考虑做 <span class="math inline">\(siz[u]\)</span> 的 01
背包，如果能将 <span class="math inline">\(siz[u]\)</span> 中分出总
<code>siz</code> 为 <span class="math inline">\(x\)</span> 的集合，那么
<span class="math inline">\(u\)</span> 对答案的贡献就是 <span
class="math inline">\(x\times (siz[u]-x-1)\)</span>。</p>
<p>暴力 01 背包即可。</p>
<h2 id="hard-ver">Hard ver</h2>
<p>考虑优化。</p>
<p>背包是判断可行性的，可以用<code>bitset</code>。</p>
<p>进一步观察，发现 <span class="math inline">\(1+\sum\limits_{v\in
son(u)}siz[v]=siz[u]\)</span>，<span
class="math inline">\(siz[v]\)</span> 的种类为 <span
class="math inline">\(O(\sqrt{n})\)</span> 量级，将 01
背包转化为多重背包，对每一个种类的个数做二进制分组，最终复杂度为 <span
class="math inline">\(O(\frac{n\sqrt{n}}{w})\)</span>，不带 <span
class="math inline">\(\log\)</span>。</p>
<p>复杂度证明：</p>
<ul>
<li>首先，复杂度上界看起来像是 <span
class="math inline">\(O(\frac{n\sqrt{n}\log n}{\omega})\)</span>
的，而实际上是 <span
class="math inline">\(O(\frac{n\sqrt{n}}{\omega})\)</span> 的。</li>
<li>设 <span class="math inline">\(w_i\)</span> 为背包中原始权值，一共有
<span class="math inline">\(\sqrt{n}\)</span> 种 <span
class="math inline">\(w\)</span>
的取值。多重背包中每个物品的权值都是形如 <span
class="math inline">\(k\times w_i\)</span> 的，容易发现最多只有 <span
class="math inline">\(\sqrt{n}\)</span> 个 <span
class="math inline">\(k\)</span> 不是二的整数次幂。我们将同一个系数
<span class="math inline">\(k\)</span> 的下标 <span
class="math inline">\(i\)</span> 放进集合 <span
class="math inline">\(S_k\)</span> 中。</li>
<li>以系数为标准分开来看，设 <span
class="math inline">\(\sum\limits_{k=2^z}|S_k|=O(T(n))\)</span>，那么总物品数
<span class="math inline">\(\sum\limits_{k\ge
1}|S_k|=O(T(n)+\sqrt{n})\)</span>。</li>
<li>显然 <span class="math inline">\(\sum\limits_{i\in S_k}kw_i\le
n\)</span>，有 <span class="math inline">\(\sum\limits_{i\in S_k}w_i\le
\frac{n}{k}\)</span>，因为在同一个 <span
class="math inline">\(k\)</span> 的 <span
class="math inline">\(S_k\)</span> 内，所有 <span
class="math inline">\(w\)</span> 显然不重复，那么左边的 <span
class="math inline">\(w\)</span> 都尽可能取最小值时，总和是 <span
class="math inline">\(\frac{|S_k|\times(|S_k|+1)}{2}\)</span>（这样
<span class="math inline">\(|S_k|\)</span>
会变得最大，这正是我们想要的），那么就有 <span
class="math inline">\(|S_k|\le \sqrt{\frac{n}{k}}\)</span>。</li>
<li>进一步的，<span class="math inline">\(\sum\limits_{k=2^z}|S_k|&lt;
\sum\limits_{z=1}^{\infty}\sqrt{\frac{n}{2^z}}=\sqrt{n}\times
\sum\limits_{z=1}^{\infty}\sqrt{\frac{1}{2^z}}=\frac{\sqrt{n}}{\sqrt{2}-1}=O(\sqrt{n})\)</span>。</li>
<li>那么总物品数为 <span class="math inline">\(O(\sqrt{n})\)</span>
量级，复杂度 <span
class="math inline">\(O(\frac{n\sqrt{n}}{\omega})\)</span>，得证。</li>
<li>参考：<a href="https://codeforces.com/blog/entry/98663">[Tutorial]
Knapsack, Subset Sum and the (max,+) Convolution</a></li>
</ul>
<p>注意 <code>bitset</code> 不能直接开
<code>bitset&lt;N&gt;</code>，要用到一些 <code>template</code>
的小技巧来减少内存开销。</p>
<p>Easy ver。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, sz[maxn];</span><br><span class="line"><span class="type">bool</span> f[maxn];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        vc.<span class="built_in">pb</span>(sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vc) &#123;</span><br><span class="line">        s += x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = s; j &gt;= x; --j) &#123;</span><br><span class="line">            f[j] |= f[j - x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, <span class="number">1LL</span> * i * (s - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += mx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, p; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        G[p].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;T);</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hard ver。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,fa[N],siz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">ll ans,closest;</span><br><span class="line">vector&lt;ll&gt; itm;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len=<span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DP</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=len)&#123;</span><br><span class="line">        <span class="built_in">DP</span>&lt;<span class="built_in">min</span>(len*<span class="number">2</span>,N)&gt;(n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitset&lt;len&gt; f;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x:itm)&#123;</span><br><span class="line">        f|=(f&lt;&lt;x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll mn=n;</span><br><span class="line">    closest=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&amp;&amp;<span class="built_in">abs</span>(i-(n-i))&lt;mn)&#123;</span><br><span class="line">            closest=i;</span><br><span class="line">            mn=<span class="built_in">abs</span>(i-(n-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;ll&gt; &amp;buc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(buc.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(buc.<span class="built_in">rbegin</span>(),buc.<span class="built_in">rend</span>());</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x:buc)s+=x;</span><br><span class="line">    <span class="keyword">if</span>(buc[<span class="number">0</span>]*<span class="number">2</span>&gt;=s)<span class="keyword">return</span> buc[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n=buc.<span class="built_in">size</span>(),pi=<span class="number">0</span>;</span><br><span class="line">    buc.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    itm.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buc[i]!=buc[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ll cnt=i-pi,x=buc[i<span class="number">-1</span>],j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;cnt)&#123;</span><br><span class="line">                itm.<span class="built_in">pb</span>(x*j);</span><br><span class="line">                cnt-=j;</span><br><span class="line">                j*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            itm.<span class="built_in">pb</span>(x*cnt);</span><br><span class="line">            pi=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DP</span>(s);</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vector&lt;ll&gt; buc;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        buc.<span class="built_in">pb</span>(siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=<span class="built_in">solve</span>(buc);</span><br><span class="line">    ans+=x*(siz[u]-x<span class="number">-1</span>);</span><br><span class="line">    buc.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(fa[i]);</span><br><span class="line">        G[fa[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>bitset</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1895D</title>
    <url>/2023/12/02/CF1895D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1895D">XOR
Construction</a></p>
<span id="more"></span>
<p>观察 <span class="math inline">\(b\)</span> 和 <span
class="math inline">\(a\)</span> 的关系。</p>
<p>对 <span class="math inline">\(a_i=b_i\oplus b_{i+1}\)</span>
变形，得 <span class="math inline">\(b_{i+1}=b_i\oplus a_i\)</span></p>
<p>发现是一个前缀和的形式，可以从 <span
class="math inline">\(b_1\)</span> 开始递推到 <span
class="math inline">\(b_n\)</span>。</p>
<p>但我们不知道 <span class="math inline">\(b_1\)</span> 的值。</p>
<p>问题转化成：找到一个首项 <span class="math inline">\(b_1\)</span>
，使得递推出的 <span class="math inline">\(b\)</span> 是一个 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(n-1\)</span> 的排列。</p>
<p>显然，对于一个排列，每个二进制位上的 <span
class="math inline">\(0\)</span> 个数一定大于等于 <span
class="math inline">\(1\)</span> 的个数，如果将排列塞到一个
<code>01Trie</code> 内，所有数一定是尽可能“靠左”（靠0）的。</p>
<p>先求出来 <span class="math inline">\(a\)</span> 的前缀和 <span
class="math inline">\(s_i=\oplus_{j=1}^i a_j\)</span>，有 <span
class="math inline">\(b_i=s_{i-1}\oplus b_1\)</span></p>
<p>可以通过对 <span class="math inline">\(b_1\)</span> 的调整，调整
<span class="math inline">\(s\)</span> 中所有数的二进制位上 <span
class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 的个数的大小关系。</p>
<p>时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i+<span class="number">1</span>]=b[i]^a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)&#123;</span><br><span class="line">        cnt1=cnt0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&gt;cnt0)&#123;</span><br><span class="line">            b[<span class="number">1</span>]|=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]^=b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1909G</title>
    <url>/2023/12/25/CF1909G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1909G">Pumping
Lemma</a></p>
<span id="more"></span>
<p>串串题。</p>
<p>首先，求出 <span
class="math inline">\(sl=\textrm{LCS}(s,t)\)</span>，对于 <span
class="math inline">\(s[1,n-sl]\)</span>，显然必须作为 <span
class="math inline">\(x\)</span> 的一部分，是定死的，于是可以让这部分和
<span class="math inline">\(y\)</span> 的前缀匹配（为了判断答案是否为
<span class="math inline">\(0\)</span>）后删掉，设 <span
class="math inline">\(x&#39;\)</span> 为 <span
class="math inline">\(x\)</span> 删去 <span
class="math inline">\(s[1,n-sl]\)</span> 后剩下的部分。</p>
<p>此时，<strong><span class="math inline">\(s\)</span> 是 <span
class="math inline">\(t\)</span> 的后缀</strong>，<span
class="math inline">\(s=x&#39;yz,t=x&#39;y^kz\)</span>，容易发现串 <span
class="math inline">\(x&#39;=y_Sy^{k&#39;}\)</span>，<span
class="math inline">\(y_S\)</span> 是 <span
class="math inline">\(y\)</span> 的某个后缀，也就是说，<strong>整个
<span class="math inline">\(x&#39;y^k\)</span> 有周期 <span
class="math inline">\(|y|\)</span>。</strong></p>
<p>枚举 <span class="math inline">\(|y|\)</span> 满足 <span
class="math inline">\((m-n)\;\textrm{mod}\;|y|=0\)</span>，考虑 <span
class="math inline">\(t\)</span> 的后缀 <span
class="math inline">\(t[|y|+1,n]\)</span> 和 <span
class="math inline">\(t\)</span> 的 <span
class="math inline">\(\textrm{LCP}\)</span>（这是周期的思考方式），设为
<span class="math inline">\(pl\)</span>，那么 <span
class="math inline">\(t[1,l+|y|]\)</span> 是具有周期 <span
class="math inline">\(|y|\)</span>
的串（画图理解，是很自然的），同时这是最长的有周期 <span
class="math inline">\(|y|\)</span> 的串（因为是 <span
class="math inline">\(\textrm{LCP}\)</span>），那么 <span
class="math inline">\(x&#39;y^k\)</span> 必然是这个串的前缀。</p>
<p>考虑 <span class="math inline">\(|x|\)</span> 的取值范围，<span
class="math inline">\(|x|+k|y|\le pl+|y|\)</span>，因为 <span
class="math inline">\(k|y|=|y|+m-n\)</span>，有 <span
class="math inline">\(|x|\in
[1,pl-m+n]\)</span>，容易发现，任何一个在范围内的 <span
class="math inline">\(|x|\)</span> 都对应一种方案。</p>
<p><span class="math inline">\(pl\)</span> 是 <span
class="math inline">\(t\)</span> 的每个后缀和 <span
class="math inline">\(t\)</span> 的 <span
class="math inline">\(\textrm{LCP}\)</span>，<span
class="math inline">\(\textrm{Z}\)</span> 函数模板，直接做。</p>
<p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,z[N];</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;(s+<span class="number">1</span>)&gt;&gt;(t+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> lcs=n;</span><br><span class="line">    <span class="keyword">while</span>(s[lcs]==t[m-(n-lcs)])lcs--;</span><br><span class="line">    <span class="built_in">re</span>(i,lcs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]!=s[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,lcs+<span class="number">1</span>,n)s[i-lcs]=s[i];</span><br><span class="line">    <span class="built_in">rep</span>(i,lcs+<span class="number">1</span>,m)t[i-lcs]=t[i];</span><br><span class="line">    n-=lcs,m-=lcs;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        z[i]=(i&gt;r)?<span class="number">0</span>:<span class="built_in">min</span>(r-i+<span class="number">1</span>,z[i-l+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;=m&amp;&amp;t[<span class="number">1</span>+z[i]]==t[i+z[i]])z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m-n)%i)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">max</span>(<span class="number">0</span>,z[i+<span class="number">1</span>]-m+n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Z函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF246E</title>
    <url>/2023/12/01/CF246E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF246E">Blood Cousins
Return</a></p>
<span id="more"></span>
<p>看起来比较像 dsu on tree。</p>
<p>首先先对询问离线，挂到树上。</p>
<p>暴力做法当然是对每个询问都查一遍子树，考虑优化。</p>
<p>我们需要一个数据结构，查询子树内某个深度中有多少种名字，为了保证复杂度，还需要支持快速合并儿子和父亲的信息。</p>
<p>可以用动态开点线段树，每棵线段树上维护每个深度上的信息，合并就直接线段树合并。</p>
<p>在线段树的每个节点上放一个<code>set</code>，存放名字，线段树合并的时候对两个<code>set</code>做启发式合并，查询直接查对应<code>set</code>的<code>size</code>。</p>
<p>做法非常暴力。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，如果将set换成支持有序插入均摊 <span
class="math inline">\(O(1)\)</span> 的<code>splay</code>树，可以做到
<span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n,q,val[N],idxcnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    dep[u]=d;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pii&gt; qry[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    &#125;t[N*<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> ncnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt)rt=++ncnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].s.<span class="built_in">insert</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span>&amp; v,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u||!v)&#123;</span><br><span class="line">            u+=v,v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[u].s.<span class="built_in">size</span>()&lt;t[u].s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[u].s,t[v].s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">each</span>(i,t[v].s)t[u].s.<span class="built_in">insert</span>(i);</span><br><span class="line">            t[v].s.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">merge</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v),l,mid);</span><br><span class="line">        <span class="built_in">merge</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> t[rt].s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> rot[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    t.<span class="built_in">modify</span>(rot[u],<span class="number">1</span>,n,dep[u],val[u]);</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">solve</span>(v);</span><br><span class="line">        t.<span class="built_in">merge</span>(rot[u],rot[v],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">each</span>(i,qry[u])&#123;</span><br><span class="line">        ans[i.se]=t.<span class="built_in">query</span>(rot[u],<span class="number">1</span>,n,i.fi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;str&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(str))val[i]=mp[str];</span><br><span class="line">        <span class="keyword">else</span> mp[str]=val[i]=++idxcnt;</span><br><span class="line">        G[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]+k&lt;=n)&#123;</span><br><span class="line">            qry[x].<span class="built_in">pb</span>(&#123;dep[x]+k,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>线段树合并</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1903F</title>
    <url>/2023/12/21/CF1903F/</url>
    <content><![CDATA[<p><a
href="https://www.luogu.com.cn/problem/CF1903F">Babysitting</a></p>
<span id="more"></span>
<p>最小值最大，二分。</p>
<p>现在要判断是否有一种方案，可以让点覆盖中 <span
class="math inline">\(\forall i\in [1,k-1],a_{i+1}-a_i\ge
mid\)</span>。</p>
<blockquote>
<p>点覆盖：对于图 <span
class="math inline">\(G=(V,E)\)</span>，一个点覆盖是一个点集 <span
class="math inline">\(S\subseteq V\)</span>，使得 <span
class="math inline">\(\forall i\in E\)</span>，<span
class="math inline">\(i\)</span> 至少有一个端点在 <span
class="math inline">\(S\)</span> 中。</p>
</blockquote>
<p>可以得出一些点和点的约束关系。</p>
<ol type="1">
<li>对于一条边 <span class="math inline">\((u,v)\)</span>，如果 <span
class="math inline">\(u\)</span> 不在点覆盖中，<span
class="math inline">\(v\)</span> 就必须在点覆盖中。</li>
<li>对于一个点 <span class="math inline">\(u\)</span>，如果点 <span
class="math inline">\(u\)</span> 在点覆盖中，因为最小值是 <span
class="math inline">\(mid\)</span>，所以 <span
class="math inline">\(|u-v|&lt;mid\)</span> 的 <span
class="math inline">\(v\)</span> 都不能在点覆盖中。</li>
</ol>
<p>这是一个 2-SAT 问题。</p>
<p>对于一般的 2-SAT
问题，将一个点拆成两个点，分别代表“它在点覆盖中”和“它不在点覆盖中”（以下称它们为白点和黑点），对所有“如果那么”的关系连边，求强连通分量，分量内的点对应的命题要么都为真，要么都为假，最后判断是否存在白点黑点在同一个分量内。</p>
<p>边数过多，发现每次连边是对单点或一段连续区间（<span
class="math inline">\([u-mid+1,u-1]\cup[u+1,u+mid-1]\)</span>）连边，线段树优化建图即可。</p>
<p>注意线段树上只连从上到下的外向边，容易发现这不影响强连通分量的正确性。</p>
<p>注意约束关系都形如“如果，那么不"的形式，连的边的端点颜色均相反，除了线段树的节点需要统一颜色。</p>
<p>时间复杂度 <span class="math inline">\(O(Tn\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">&#125; E[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> lev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">4</span> * n + n * lev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        G[rt].<span class="built_in">pb</span>(<span class="built_in">id</span>(l, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    G[rt].<span class="built_in">pb</span>(<span class="built_in">ls</span>(rt)), G[rt].<span class="built_in">pb</span>(<span class="built_in">rs</span>(rt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ml, <span class="type">int</span> mr, <span class="type">int</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= l &amp;&amp; r &lt;= mr) &#123;</span><br><span class="line">        G[<span class="built_in">id</span>(tar, <span class="number">1</span>)].<span class="built_in">pb</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= mid) <span class="built_in">connect</span>(<span class="built_in">ls</span>(rt), l, mid, ml, mr, tar);</span><br><span class="line">    <span class="keyword">if</span> (mr &gt; mid) <span class="built_in">connect</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ml, mr, tar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], vis[N], bel[N], sta[N], tp, dfncnt, sccnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++dfncnt;</span><br><span class="line">    sta[++tp] = u, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            bel[sta[tp]] = u, vis[sta[tp]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (sta[tp--] == u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, <span class="number">6</span> * n) &#123;</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">        dfn[i] = low[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tp = dfncnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">re</span>(i, m) &#123;</span><br><span class="line">        G[<span class="built_in">id</span>(E[i].u, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(E[i].v, <span class="number">1</span>));</span><br><span class="line">        G[<span class="built_in">id</span>(E[i].v, <span class="number">0</span>)].<span class="built_in">pb</span>(<span class="built_in">id</span>(E[i].u, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="number">1</span>, i - x + <span class="number">1</span>), r = <span class="built_in">min</span>(n, i + x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; l) <span class="built_in">connect</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, i - <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r) <span class="built_in">connect</span>(<span class="number">1</span>, <span class="number">1</span>, n, i + <span class="number">1</span>, r, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n * <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bel[<span class="built_in">id</span>(i, <span class="number">0</span>)] == bel[<span class="built_in">id</span>(i, <span class="number">1</span>)]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">re</span>(i, m) &#123;</span><br><span class="line">        cin &gt;&gt; E[i].u &gt;&gt; E[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n, mid = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>2-SAT</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>CF258E</title>
    <url>/2023/12/01/CF258E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF258E">Little Elephant and
Tree</a></p>
<span id="more"></span>
<p>有“数据结构”思维。</p>
<p>题目翻译：给 <span class="math inline">\(m\)</span>
次操作，每次对两个子树添加一种颜色。<span
class="math inline">\(m\)</span> 次操作后输出 <span
class="math inline">\(i\)</span> 个数：和点 <span
class="math inline">\(i\)</span> 有至少一个相同颜色的点数。</p>
<p>两种思考方向：</p>
<ol type="1">
<li><p>点 <span class="math inline">\(i\)</span> 会被点 <span
class="math inline">\(i\)</span> 到根上的点覆盖，用线段树维护当前点
<span class="math inline">\(i\)</span>
到根这条路径上，挂上去的修改集合的并集的颜色拥有情况，计算线段树中非
<span class="math inline">\(0\)</span>
位置个数。结束这棵子树的处理后，再回溯，在线段树上减去集合的颜色贡献，比较自然。</p></li>
<li><p>将子树问题转为dfs序上的区间问题，设 <span
class="math inline">\(id[u]\)</span> 为点 <span
class="math inline">\(u\)</span> 在dfs序中位置，<span
class="math inline">\(f[id[i]][id[j]]\)</span> 为 第 <span
class="math inline">\(i\)</span> 个点和第 <span
class="math inline">\(j\)</span> 个点共有颜色个数，<span
class="math inline">\(L,R\)</span> 分别为子树在dfs序上的左右端点。</p>
<p>那么一次 <span class="math inline">\((u,v)\)</span> 操作等价于在
<span class="math inline">\(f\)</span> 上将 <span
class="math inline">\((L[u],L[v]),(R[u],R[v])\)</span> 这两个点对应的
矩形加 <span
class="math inline">\(1\)</span>，现在是一个二维区间问题，可以在一维上差分，另一维线段树维护。具体的，当前扫描到
的第 <span class="math inline">\(i\)</span> 行，处理在第 <span
class="math inline">\(i\)</span> 行上的修改（区间加差分后的 <span
class="math inline">\(+1/-1\)</span>），然后计算当前线段树的非
位置个数，得到答案。感觉这个过程是比较像扫描线的。</p></li>
</ol>
<p>写的是第二种思考方向，查询数列非 <span
class="math inline">\(0\)</span> 位置个数的写法在代码中。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mn,lz,cnt;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mn&lt;=t[<span class="built_in">rs</span>(rt)].mn)&#123;</span><br><span class="line">        t[rt].cnt+=t[<span class="built_in">ls</span>(rt)].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mn&gt;=t[<span class="built_in">rs</span>(rt)].mn)&#123;</span><br><span class="line">        t[rt].cnt+=t[<span class="built_in">rs</span>(rt)].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    t[rt].mn+=v;</span><br><span class="line">    t[rt].lz+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    t[rt].cnt=r-l+<span class="number">1</span>;</span><br><span class="line">    t[rt].mn=t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        <span class="built_in">update</span>(rt,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tL[N],tR[N],dfn[N],dfncnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    tL[u]=++dfncnt;</span><br><span class="line">    dfn[dfncnt]=u;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)<span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tR[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line">vector&lt;pii&gt; ch[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        d[tL[u]]++,d[tR[u]+<span class="number">1</span>]--;</span><br><span class="line">        d[tL[v]]++,d[tR[v]+<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">auto</span> add=[](<span class="type">int</span> p,<span class="type">int</span> x)&#123;</span><br><span class="line">            ch[tL[p]].<span class="built_in">pb</span>(&#123;x,<span class="number">1</span>&#125;);</span><br><span class="line">            ch[tR[p]+<span class="number">1</span>].<span class="built_in">pb</span>(&#123;x,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">add</span>(u,u);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        <span class="built_in">add</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">each</span>(j,ch[i])&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,tL[j.fi],tR[j.fi],j.se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">1</span>].mn&gt;<span class="number">0</span>)ans[dfn[i]]=n;</span><br><span class="line">        <span class="keyword">else</span> ans[dfn[i]]=n-t[<span class="number">1</span>].cnt;</span><br><span class="line">        ans[dfn[i]]=<span class="built_in">max</span>(<span class="number">0</span>,ans[dfn[i]]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF294C</title>
    <url>/2023/12/01/CF294C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF294C">Shaass and
Lights</a></p>
<span id="more"></span>
<p>划分出未被点亮的灯的极长连续段。</p>
<p>考虑中间的某一长 <span class="math inline">\(len_i\)</span>
的段是如何贡献答案的。</p>
<p>每一次可以在左边点或右边点 贡献为 <span
class="math inline">\(2^{len_i-1}\)</span>,要减一是因为最后一次只剩一个灯
没有左右区分。</p>
<p>拓展到多个段 发现选择的段的编号序列方案
就是：一个可重序列的排列数。</p>
<p>这是非常经典的问题，设有 <span class="math inline">\(n\)</span>
种数，<span class="math inline">\(i\)</span> 的个数为 <span
class="math inline">\(a_i\)</span>。</p>
<p>答案为：<span
class="math inline">\(\dfrac{(\sum_{i=1}^na_i)!}{\prod_{i=1}^{n}a_i!}\)</span></p>
<p>在本题中也就是 <span
class="math inline">\(\dfrac{(n-m)!}{\prod_{i=1}^{cnt}len_i!}\)</span></p>
<p>注意头和尾上的段只有一种点亮方式，没有贡献。</p>
<p>所以最后要乘上 <span
class="math inline">\(\prod_{i=2}^{cnt-1}2^{len_i-1}\)</span>，得到答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1005</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],l[N],fac[N],inv[N],p2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            res=(res*a)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a=(a*a)%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        l[++cnt]=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l[++cnt]=n-a[m];</span><br><span class="line">    fac[<span class="number">1</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    p2[<span class="number">0</span>]=<span class="number">1</span>,p2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        p2[i]=p2[i<span class="number">-1</span>]*<span class="number">2</span>%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=fac[n-m];</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=ans*inv[l[i]]%Mod;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;i!=cnt)ans=ans*p2[l[i]<span class="number">-1</span>]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>CF321E</title>
    <url>/2024/01/03/CF321E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF321E">Ciel and
Gondolas</a></p>
<span id="more"></span>
<p>题意：将 <span class="math inline">\((1,2,3,\cdots,n)\)</span>分成
<span class="math inline">\(K\)</span> 段，<span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 分到一起的时候会产生 <span
class="math inline">\(u_{i,j}\)</span> 的贡献值，求最小贡献值的和。</p>
<p>设 <span class="math inline">\(f(i,j)\)</span> 表示序列前 <span
class="math inline">\(i\)</span> 项，分 <span
class="math inline">\(j\)</span> 段的最小贡献和。有转移方程： <span
class="math display">\[
f(i,j)=\min_{k=1}^{i-1}f(k,j-1)+W(k+1,i)
\]</span> <span class="math inline">\(W\)</span> 可以 <span
class="math inline">\(O(n^2)\)</span> 预处理。</p>
<p>需要一些优化。</p>
<p>注意到，固定 <span class="math inline">\(i\)</span>，<span
class="math inline">\(W(k,i)\)</span> 是单调递减的；固定 <span
class="math inline">\(k\)</span>，<span
class="math inline">\(W(k,i)\)</span> 是单调递增的。因为 <span
class="math inline">\(u_{i,j}\ge 0\)</span>。</p>
<p>可以采用决策单调性优化。用一个单调队列维护。</p>
<p>对于决策点 <span class="math inline">\(x,\,y;\,x&lt;
y\)</span>，可以通过二分找到：<span class="math inline">\(y\)</span>
第一次比 <span class="math inline">\(x\)</span> 更优的位置 <span
class="math inline">\(H(x,y)\)</span>（<code>findP(x,y)</code>）</p>
<p>如果 <span class="math inline">\(H(x,y)\le i\)</span>，说明 <span
class="math inline">\(y\)</span> 在当前就已经更优，可以扔掉 <span
class="math inline">\(x\)</span>。</p>
<p>而如果可以使队列内决策点位置单增，就只需要在队头进行不断扔 <span
class="math inline">\(x\)</span> 的操作。</p>
<p>每次加入新元素的时候保证一下决策点单增，不合法就弹队尾。</p>
<p><span class="math inline">\(x\)</span> 已经比 <span
class="math inline">\(y\)</span> 劣了，而且 <span
class="math inline">\(x\)</span> 还在前面，那 <span
class="math inline">\(x\)</span> 在未来一定不如 <span
class="math inline">\(y\)</span>，所以扔 <span
class="math inline">\(x\)</span> 没问题。</p>
<p>对于扔队尾，设目前队尾是 <span
class="math inline">\(b\)</span>，队尾的前一个是 <span
class="math inline">\(c\)</span>，要加入的新元素是 <span
class="math inline">\(a\)</span>。</p>
<p>考虑不合法情况 <span
class="math inline">\(H(c,b)&gt;H(b,a)\)</span>，在 <span
class="math inline">\(H(b,a)\)</span> 的时候 <span
class="math inline">\(a\)</span> 就已经比 <span
class="math inline">\(b\)</span> 优了，再到后面 <span
class="math inline">\(H(c,b)\)</span> 的位置 <span
class="math inline">\(b\)</span> 才比 <span
class="math inline">\(c\)</span> 优，<span
class="math inline">\(b\)</span>
当然没有保存的必要，所以不影响正确性。</p>
<p>现在得到了一个 <span class="math inline">\(O(kn\log n)\)</span>
的写法，可以通过。用分治写法也一样，可能分治更好写。</p>
<p>关于分治：暴力算 <span class="math inline">\(mid\)</span>
的最优决策点 <span
class="math inline">\(opt(mid)\)</span>，因为决策单调性，有：<span
class="math inline">\(opt(p)&lt;opt(mid),p\in[l,mid),\;opt(p)&gt;opt(mid),p\in(mid,r]\)</span>。</p>
<p>直接暴力做，每次枚举可能出现的最优决策点位置，容易证明复杂度 <span
class="math inline">\(O(kn\log n)\)</span>。</p>
<p>但是还能精益求精。</p>
<p>发现答案需要恰好 <span class="math inline">\(K\)</span> 段，而 <span
class="math inline">\(g(j)=f(n,j)\)</span>
是<strong>下凸</strong>的。所以可以 wqs 二分。</p>
<p>然后就是 wqs
二分经典流程，二分斜率，求切线截距，记录需要的段数，判断是否 <span
class="math inline">\(\le K\)</span>，调整斜率，求出答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n\log
V)\)</span>。</p>
<p><span class="math inline">\(g\)</span>
为什么是凸的？因为四边形不等式。</p>
<p>既然写到四边形不等式，就顺便写一下四边形不等式的写法。</p>
<p>容易证明，<span class="math inline">\(W\)</span>
满足四边形不等式。</p>
<p>而对于区间划分问题，这也意味着： <span class="math display">\[
opt(i,j-1)\le opt(i,j)\le opt(i+1,j)
\]</span> <span class="math inline">\(opt(i,j)\)</span> 为 <span
class="math inline">\(f(i,j)\)</span>
的最优转移点。这个式子是一个结论。</p>
<p>转移过程中记录一下 <span
class="math inline">\(opt\)</span>，直接暴力枚举 <span
class="math inline">\(p\in [opt(i,j-1),opt(i+1,j)]\)</span> 即可。</p>
<p>可以证明，时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>朴素决策单调性（分治写法）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">800</span>, MAXN = <span class="number">4000</span>;</span><br><span class="line"><span class="type">int</span> n, k, x, sum[MAXN + <span class="number">5</span>][MAXN + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dp[MAXK + <span class="number">5</span>][MAXN + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Calc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[v][v] - sum[v][u - <span class="number">1</span>] - sum[u - <span class="number">1</span>][v] + sum[u - <span class="number">1</span>][u - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> optl, <span class="type">int</span> optr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, opt;</span><br><span class="line">    dp[s][Mid] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = optl; i &lt;= <span class="built_in">min</span>(optr, Mid); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[s][Mid] &gt; dp[s - <span class="number">1</span>][i - <span class="number">1</span>] + <span class="built_in">Calc</span>(i, Mid))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[s][Mid] = dp[s - <span class="number">1</span>][i - <span class="number">1</span>] + <span class="built_in">Calc</span>(i, Mid);</span><br><span class="line">            opt = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s, L, Mid - <span class="number">1</span>, optl, opt);</span><br><span class="line">    <span class="built_in">dfs</span>(s, Mid + <span class="number">1</span>, R, opt, optr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Read</span>(n), <span class="built_in">Read</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">Read</span>(x), sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">Write</span>(dp[k][n] / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>决策单调性+ wqs 二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4005</span>;</span><br><span class="line"><span class="type">int</span> n,K,s[N][N],f[N],cnt[N];</span><br><span class="line"><span class="type">int</span> q[N],hd,tl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">W</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[y][y]-s[y][x<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findP</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=y+<span class="number">1</span>,r=n,mid=<span class="number">0</span>,t1=<span class="number">0</span>,t2=<span class="number">0</span>,res=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        t1=f[x]+<span class="built_in">W</span>(x+<span class="number">1</span>,mid),t2=f[y]+<span class="built_in">W</span>(y+<span class="number">1</span>,mid);</span><br><span class="line">        <span class="keyword">if</span>(t1&gt;t2||(t1==t2&amp;&amp;cnt[x]&gt;cnt[y]))&#123;</span><br><span class="line">            res=mid;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)f[i]=<span class="number">0</span>;</span><br><span class="line">    q[hd=tl=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hd&lt;tl&amp;&amp;<span class="built_in">findP</span>(q[hd],q[hd+<span class="number">1</span>])&lt;=i)hd++;</span><br><span class="line">        f[i]=f[q[hd]]+<span class="built_in">W</span>(q[hd]+<span class="number">1</span>,i)-d;</span><br><span class="line">        cnt[i]=cnt[q[hd]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hd&lt;tl&amp;&amp;<span class="built_in">findP</span>(q[tl<span class="number">-1</span>],q[tl])&gt;<span class="built_in">findP</span>(q[tl],i))tl--;</span><br><span class="line">        q[++tl]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[n]&lt;=K;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,K);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="built_in">read</span>(s[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;i)s[i][j]=<span class="number">0</span>;</span><br><span class="line">            sum+=s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">re</span>(j,i)s[i][j]+=s[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">re</span>(j,i)s[i][j]+=s[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> l=-sum,r=<span class="number">0</span>,res=<span class="number">0</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            res=mid;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(res);</span><br><span class="line">    <span class="type">int</span> ans=f[n]+res*K;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四边形不等式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4010</span>;</span><br><span class="line"><span class="type">int</span> sum[maxn][maxn],cost[maxn][maxn],dp[<span class="number">810</span>][maxn],pos[<span class="number">810</span>][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;K);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,K) <span class="built_in">rep</span>(j,<span class="number">0</span>,N) dp[i][j]=<span class="number">2000000000</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N) <span class="built_in">rep</span>(j,<span class="number">1</span>,N)&#123;</span><br><span class="line">        <span class="built_in">read</span>(sum[i][j]);</span><br><span class="line">        sum[i][j]=sum[i][j]+sum[i][j<span class="number">-1</span>]+sum[i<span class="number">-1</span>][j]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N) <span class="built_in">rep</span>(j,i+<span class="number">1</span>,N) cost[i][j]=(sum[j][j]+sum[i<span class="number">-1</span>][i<span class="number">-1</span>]-sum[j][i<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N) dp[<span class="number">1</span>][i]=cost[<span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,K)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=N;j&gt;=i;j--)&#123;</span><br><span class="line">         <span class="type">int</span> L=pos[i<span class="number">-1</span>][j]?pos[i<span class="number">-1</span>][j]:<span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> R=pos[i][j+<span class="number">1</span>]?pos[i][j+<span class="number">1</span>]:N;</span><br><span class="line">         <span class="built_in">rep</span>(k,L,R)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][k]+cost[k+<span class="number">1</span>][j]&lt;dp[i][j])&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][k]+cost[k+<span class="number">1</span>][j];</span><br><span class="line">                pos[i][j]=k;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[K][N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>分治</tag>
        <tag>DP优化</tag>
        <tag>决策单调性</tag>
        <tag>wqs二分</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>CF351E</title>
    <url>/2023/12/02/CF351E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF351E">Jeff and
Permutation</a></p>
<span id="more"></span>
<p>首先可以发现，做 <span class="math inline">\(a_i=|a_i|\)</span>
不会影响答案，统一正负再做会更方便，下文 <span
class="math inline">\(a_i\)</span> 都是 被绝对化 的。</p>
<p>继续发掘性质，发现比较难直接找。</p>
<p>写点分讨。</p>
<p>考虑 <span class="math inline">\((i,j),i&lt;j\)</span>
什么时候会成为逆序对。</p>
<ul>
<li>若 <span
class="math inline">\(a_i&lt;a_j\)</span>，那么想要产生逆序对，要么让
<span class="math inline">\(a_j\)</span> 取反，<span
class="math inline">\(a_i\)</span> 不变，要么就让 <span
class="math inline">\(a_i,a_j\)</span> 都取反。</li>
<li>若 <span
class="math inline">\(a_i&gt;a_j\)</span>，那么想要产生逆序对，要么让
<span class="math inline">\(a_j\)</span> 取反，<span
class="math inline">\(a_i\)</span> 不变，要么就让 <span
class="math inline">\(a_i,a_j\)</span> 都不变。</li>
</ul>
<p>综上，对于 <span class="math inline">\(i\)</span> 来说，<span
class="math inline">\(a_i\)</span> 如果取反，<span
class="math inline">\(a_j&lt;a_i,j\in[1,i-1]\)</span>
会产生贡献，否则就是 <span
class="math inline">\(a_j&lt;a_i,j\in[i+1,n]\)</span>。</p>
<p>暴力做即可，时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2005</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]=<span class="built_in">abs</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        L=R=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(j,i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])L++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])R++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=<span class="built_in">min</span>(L,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>纯思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF401D</title>
    <url>/2023/12/01/CF401D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF401D">Roman and
Numbers</a></p>
<span id="more"></span>
<p>（双倍经验）<a href="https://www.luogu.com.cn/problem/P4163">P4163
[SCOI2007] 排列</a></p>
<p>首先和整除相关 考虑记录每个同余类的状态</p>
<p><span class="math inline">\(n\)</span> 范围很大，考虑通过状压dp
从小的子问题合并到答案</p>
<p>先拆分： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">    a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 设 <span
class="math inline">\(f[s][i]\)</span> 为当前选了全集 <span
class="math inline">\(18\)</span> 位中的集合 <span
class="math inline">\(s\)</span> 重新排列 数字<span
class="math inline">\(=i\mod m\)</span>的 不同数字个数。</p>
<p>于是可以每次从比当前集合恰好少一个元素的状态转移过来
并直接计算要转移到哪个同余类： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!(s&gt;&gt;i&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">      f[s][(j*<span class="number">10</span>+a[i])%m]+=f[s^(<span class="number">1</span>&lt;&lt;i)][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但上述代码并不能考虑到前导零的影响 且还会数重。</p>
<p>比如 <span class="math inline">\(s=111_2\)</span> 可以从 <span
class="math inline">\(110_2\)</span> 和 <span
class="math inline">\(101_2\)</span> 转移过来，当 <span
class="math inline">\(n=122\)</span> 时，会被算重。</p>
<p>直接加入 <span class="math inline">\(vis\)</span>
数组去重，然后再加一点前导零判断，最终改为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">270000</span>)</span></span>;</span><br><span class="line">ll n,f[N][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> m,a[N],cnt,vis[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    ll x=n;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;i)&amp;&amp;!a[i])<span class="keyword">break</span>;<span class="comment">//前导零</span></span><br><span class="line">            <span class="keyword">if</span>(!(s&gt;&gt;i&amp;<span class="number">1</span>)||vis[a[i]])<span class="keyword">continue</span>;</span><br><span class="line">            vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                f[s][(j*<span class="number">10</span>+a[i])%m]+=f[s^(<span class="number">1</span>&lt;&lt;i)][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>][<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF487E</title>
    <url>/2023/12/01/CF487E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF487E">Tourists</a></p>
<span id="more"></span>
<p>圆方树上树剖，应该有点用处？</p>
<p>题意：两种操作，操作 <span class="math inline">\(1\)</span>
是单点修改点权，操作 <span class="math inline">\(2\)</span> 给定两个点
<span class="math inline">\(u,v\)</span>，求 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 所有路径中路径上最小值的最小值。</p>
<p>对操作 <span class="math inline">\(2\)</span> 进一步翻译：求最小的
<span class="math inline">\(w[c]\)</span> 满足 <span
class="math inline">\(c\)</span> 在 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>
的简单路径上（就是每个点最多经过一次的路径）。</p>
<p>转化到了和 <a
href="https://h01yshhmy.github.io/2023/12/02/P4630/">P4630 |
h01yshhmy</a> 相似的模型，关于圆方树性质也在链接内。</p>
<p>建立圆方树。</p>
<p>有结论：设 <span class="math inline">\(D\)</span> 为 圆点 <span
class="math inline">\(u\)</span> 到圆点 <span
class="math inline">\(v\)</span>
路径上方点的点集，方点点权为点双内圆点点权最小值，那么操作 <span
class="math inline">\(2\)</span> 答案是 <span
class="math inline">\(\min_{p\in D}w[p]\)</span>。</p>
<p>具体获得结论的过程在 <a
href="https://h01yshhmy.github.io/2023/12/02/P4630/">P4630 |
h01yshhmy</a>。</p>
<p>用树剖+线段树查询链上最值即可。</p>
<p>现在已经会做不带修的版本了，考虑加上操作 <span
class="math inline">\(1\)</span> 怎么办。</p>
<p>发现操作 <span class="math inline">\(1\)</span>
的困难之处在于，修改一个圆点，要修改所有点双包含这个圆点的方点的点权。</p>
<p>有一个比较好想，比较暴力的思路：对每个方点维护一个<code>multiset</code>，储存点双内点权，每次修改圆点时，遍历与这个圆点相连的方点，对他们的<code>multiset</code>删掉原点权，加入新点权，并更新方点点权。</p>
<p>但很显然，度数相关的复杂度是无法保证的，如果一个圆点连了一堆方点就爆了。</p>
<p>联想到树上问题中，父亲到儿子的操作太慢，可以转化成儿子到父亲，因为每个节点只有一个父节点。</p>
<p>注意到，在前面的暴力思路中，并没有把圆方树看做一个有根树，而我们可以把它变成有根树，选点
<span class="math inline">\(1\)</span> 为根即可。</p>
<p>现在将方点点权修改为：儿子中的点权最小值。</p>
<p>那么修改一个圆点只需要修改他的父亲方点的<code>multiset</code>，对这两个点都在线段树上更新一下点权即可。</p>
<p>查询的时候，如果两点的<code>lca</code>是方点，还要和<code>fa[lca]</code>的点权取个<code>min</code>，因为方点的父亲也在合法点双之内。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<p>总结：</p>
<p>圆方树对于 无向图上某两点之间全部简单路径中求值的问题 有奇效。</p>
<p>本质上是点双连通相关，圆点和方点的性质可以帮助我们快速建模和解题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> nid;</span><br><span class="line"><span class="keyword">namespace</span> TR&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to,nxt;</span><br><span class="line">    &#125;e[N*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N],ecnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        e[++ecnt].to=v;</span><br><span class="line">        e[ecnt].nxt=head[u];</span><br><span class="line">        head[u]=ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ae</span>(u,v);<span class="built_in">ae</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fa[N],dep[N],siz[N],hson[N],top[N],idx[N],dfn[N],dfncnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">        fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init1</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">                hson[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">        top[u]=tp;</span><br><span class="line">        dfn[idx[u]=++dfncnt]=u;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">init2</span>(hson[u],tp);</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init2</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt]=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)],t[<span class="built_in">rs</span>(rt)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[rt]=w[dfn[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[rt]=val;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt];</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qrypath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=inf;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,nid,idx[top[u]],idx[u]));</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,nid,idx[u],idx[v]));</span><br><span class="line">        <span class="keyword">if</span>(u&gt;n)res=<span class="built_in">min</span>(res,w[fa[u]]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> GR&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to,nxt;</span><br><span class="line">    &#125;e[N*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N],ecnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        e[++ecnt].to=v;</span><br><span class="line">        e[ecnt].nxt=head[u];</span><br><span class="line">        head[u]=ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ae</span>(u,v);<span class="built_in">ae</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dfn[N],low[N],dfncnt,sta[N],tp;</span><br><span class="line">    <span class="type">int</span> bel[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        dfn[u]=low[u]=++dfncnt;</span><br><span class="line">        sta[++tp]=u;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">                    <span class="type">int</span> o=<span class="number">0</span>;nid++;</span><br><span class="line">                    <span class="keyword">do</span>&#123;</span><br><span class="line">                        o=sta[tp--];</span><br><span class="line">                        bel[o]=nid;</span><br><span class="line">                        TR::<span class="built_in">add</span>(o,nid);</span><br><span class="line">                    &#125;<span class="keyword">while</span>(o!=v);</span><br><span class="line">                    TR::<span class="built_in">add</span>(u,nid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    nid=n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        GR::<span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!GR::dfn[i])&#123;</span><br><span class="line">            GR::<span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TR::<span class="built_in">init1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    TR::<span class="built_in">init2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        s[TR::fa[i]-n].<span class="built_in">insert</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,n+<span class="number">1</span>,nid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i-n].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            w[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> w[i]=*s[i-n].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TR::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,nid);</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            TR::<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,nid,TR::idx[u],v);</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">1</span>)&#123;</span><br><span class="line">                w[u]=v;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fa=TR::fa[u];</span><br><span class="line">            s[fa-n].<span class="built_in">erase</span>(s[fa-n].<span class="built_in">find</span>(w[u]));</span><br><span class="line">            s[fa-n].<span class="built_in">insert</span>(v);</span><br><span class="line">            <span class="type">int</span> mn=*s[fa-n].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(mn!=w[fa])&#123;</span><br><span class="line">                TR::<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,nid,TR::idx[fa],mn);</span><br><span class="line">                w[fa]=mn;</span><br><span class="line">            &#125;</span><br><span class="line">            w[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;TR::<span class="built_in">qrypath</span>(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>CF559C</title>
    <url>/2023/12/01/CF559C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF559C">Gerald and Giant
Chess</a></p>
<span id="more"></span>
<p>双倍经验：<a href="https://www.luogu.com.cn/problem/AT_dp_y">Grid
2</a></p>
<p>首先，对于无障碍的地图，从 <span
class="math inline">\((x_1,y_1)\)</span> 到 <span
class="math inline">\((x_2,y_2)\)</span> 的路径数为 <span
class="math inline">\(\dbinom{x_2-x_1+y_2-y_1}{x_2-x_1}\)</span>，这里保证
<span class="math inline">\(x_1\le x_2,y_1\le y_2\)</span>。</p>
<p>观察数据范围，发现 <span class="math inline">\(n\le
2000\)</span>，考虑对黑点<code>DP</code>。</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为走到第 <span
class="math inline">\(i\)</span>
个黑点，<strong>且左上方所有的黑点都未被走过</strong>的路径方案数。<span
class="math inline">\(g[i][j]\)</span> 为从第 <span
class="math inline">\(i\)</span> 个黑点到第 <span
class="math inline">\(j\)</span>
个黑点假定无障碍的路径方案数（也就是上面那个组合数）。</p>
<p><span
class="math inline">\(f[i]=g[0][i]-\sum\limits_{j=1}^{i-1}f[j]\times
g[j][i]\)</span></p>
<p><span class="math inline">\(g[0][i]\)</span>
就是从起点出发；当然，要先对黑点排序。</p>
<p>为什么是对的呢？</p>
<p>虽然 <span class="math inline">\(g\)</span>
的设计是假定无障碍，走黑点的方案数也被统计了，但是 <span
class="math inline">\(f\)</span> 钦定了必走 <span
class="math inline">\(i\)</span>
，且前面的黑点都未被走过，所以说后面的和式中每一种方案都是不能放在 <span
class="math inline">\(f[i]\)</span> 内的，且不重复。</p>
<p>我们只需要只走最后一个点的方案，这样做是不重不漏的。</p>
<p>题目要求走到 <span class="math inline">\((h,w)\)</span>
的方案数，添加上 <span class="math inline">\((h,w)\)</span>
为黑点就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2005</span>)</span>,<span class="title">V</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pnt</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line">ll f[N];</span><br><span class="line">ll fac[V],ifac[V];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(h,w,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].x,a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    a[++n].x=h;</span><br><span class="line">    a[n].y=w;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,[](Pnt u,Pnt v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u.x==v.x)<span class="keyword">return</span> u.y&lt;v.y;</span><br><span class="line">        <span class="keyword">return</span> u.x&lt;v.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">C</span>(a[i].x+a[i].y<span class="number">-2</span>,a[i].x<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">re</span>(j,i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].x&lt;a[j].x||a[i].y&lt;a[j].y)<span class="keyword">continue</span>;</span><br><span class="line">            f[i]=(f[i]-f[j]*<span class="built_in">C</span>(a[i].x-a[j].x+a[i].y-a[j].y,a[i].x-a[j].x)%Mod+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>CF55D</title>
    <url>/2023/12/07/CF55D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF55D">Beautiful
numbers</a></p>
<span id="more"></span>
<p>全文转自题解区
<code>hzoi_liuchang</code>，有思维方式类似的详细题解就不自己写了。</p>
<p>题意：有 <span class="math inline">\(T\)</span> 组询问，每次询问区间
<span class="math inline">\([l,r]\)</span> 中的
<code>beautiful number</code> 有多少。<code>beautiful number</code>
是指这个数可以被组成它的数字整除。</p>
<p>这道题数据范围达到了9e18，如果暴力枚举的话一定会<code>TLE</code>。</p>
<p>所以我们要借助一个神奇的东西-——数位DP</p>
<h2 id="x00-前置知识数位dp">0x00 前置知识：数位DP</h2>
<h3 id="定义">定义</h3>
<p>数位 <code>dp</code> 是一种计数用的
<code>dp</code>，一般就是要统计区间 <span
class="math inline">\([l,r]\)</span> 内满足一些条件的数的个数。所谓数位
<code>dp</code>，字面意思就是在数位上进行 <code>dp</code>。</p>
<h3 id="数位dp的思想">数位dp的思想</h3>
<p>数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了。</p>
<h3 id="模板">模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][state];   <span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> state,<span class="type">bool</span> lead,<span class="type">bool</span> limit)</span>       <span class="comment">//变量，状态，前导0，数位上界；注意不是每题都要判断前导零</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//递归边界，一般一种递归到结束只能产生一种情况</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][state];    <span class="comment">//记忆化</span></span><br><span class="line">    <span class="type">int</span> up=limit?a[pos]:<span class="number">9</span>;  <span class="comment">//枚举上界</span></span><br><span class="line">    ll ans=<span class="number">0</span>;               <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)  <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>() ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()...        <span class="comment">//一下条件</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">        <span class="comment">//state状态转移要保证i的合法性，比如不能有62，那么当pre==6&amp;&amp;i==2就不合法，这里用state记录pre是否为6即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++tot]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(tot<span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="literal">true</span>,<span class="literal">true</span>);<span class="comment">//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll le,ri;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;le,&amp;ri))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化dp数组为-1,这里还有更加优美的优化,后面讲</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(ri)-<span class="built_in">solve</span>(le<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="x01-特征">0x01 特征</h2>
<p>对于一个正整数，什么情况下它才能被组成它的非零数字整除呢</p>
<p>这个应该比较好想，只有当这个正整数能被它所有数位的最小公倍数整除时，它才能被每一个数位整除</p>
<p>而且，我们还知道<code>1,2,3,4,5,6,7,8,9</code>的最小公倍数是
<code>2520</code>（后面要用到）</p>
<h2 id="x02-数组定义">0x02 数组定义</h2>
<p>我们要进行 <code>DP</code> 的话，肯定要定义一个 <code>f</code>
数组存储我们计算过的值</p>
<p>因为这道题和数位有关，所以第一位我们要定义当前遍历到了第几位</p>
<p>而且我们还要判断当前的数是否能被它所有数位的最小公倍数整除</p>
<p>所以我们还要开两维记录当前的数和它所有数位的最小公倍数</p>
<p>所以，最后的 <code>f</code> 数组就是
<code>f[当前枚举到了第几位][当前的数][当前数所有数位的最小公倍数]</code></p>
<p>题目中给出的最大的数就是 <code>9e18</code>，所以最多有
<code>19</code>位，那么第一维我们开 <code>20</code> 就可以了</p>
<p>第二维我们显然不能开到 <code>9e18</code>，会超内存</p>
<p>因为我们最终统计的是这个数能否被它所有数位的最小公倍数整除，所以我们不必要记录原数的值</p>
<p>我们只需要记录原数对 <code>2520</code> 取模的结果就可以，因为
<code>2520</code> 是 <code>1</code> 到 <code>9</code>
的最小公倍数，所以取模之后不会有影响，<code>x</code> 与
<code>x%2520</code> 是等效的</p>
<p>这时我们算一下内存 <code>2025202520</code> ，还是不行。</p>
<p>所以我们考虑减省一下第三维，由于第三维记录的是所有数位的最小公倍数，所以有很多数并不会出现</p>
<p>比如11、13、17、19……它们并不是1到9中任意几个数的最小公倍数</p>
<p>所以我们只需要记录2520的因数就可以了，这样的数有48个，所以我们开50就可以了</p>
<p>附48个数：</p>
<p><code>1 2 3 4 5 6 7 8 9 10 12 14 15 18 20 21 24 28 30 35 36 40 42 45 56 60 63 70 72 84 90 105 120 126 140 168 180 210 252 280 315 360 420 504 630 840 1260 2520</code></p>
<h2 id="x03-如何计算">0x03 如何计算</h2>
<p>asd(ll now,ll mod,ll gbs,ll jud)
它的四个参数分别为:当前处理到第now位； now位之前的数%2520；
now位之前的数的每一位数的最小公倍数；jud特判前一位是否为范围内的最大值</p>
<p>前三个参数比较好理解，我们着重来讲一下第四个参数jud</p>
<p>我们来举一个例子</p>
<p>比如说我们要求的数为5456</p>
<p>我们把它的千位设为第3位，百位设为第2位，十位设为第1位，个位设为第0位</p>
<p>当它的第三位为0、1、2、3、4时，它的第二位可以从0枚举到9</p>
<p>但是当它的第三位枚举到5时，第二位的数就只能枚举到4</p>
<p>所以我们用一个变量jud记录前一位能不能达到最大值，如果上一位达到了最大值，那么这一位就只能枚举到当前位上的数</p>
<p>如果上一位没有达到最大值，那么这一位就可以从0到9随便枚举</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">asd</span><span class="params">(ll now,ll mod,ll gbs,ll jud)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mod%gbs==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">0</span> &amp;&amp; f[now][mod][lcm[gbs]]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> f[now][mod][lcm[gbs]];</span><br><span class="line">    &#125;</span><br><span class="line">    ll mmax=<span class="number">9</span>,mans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">1</span>) mmax=num[now];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=mmax;i++)&#123;</span><br><span class="line">         mans+=<span class="built_in">asd</span>(now<span class="number">-1</span>,(mod*<span class="number">10</span>+i)%<span class="number">2520</span>,i!=<span class="number">0</span>?i*gbs/<span class="built_in">gcd</span>(i,gbs):gbs,jud&amp;&amp;i==mmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">0</span>) f[now][mod][lcm[gbs]]=mans;</span><br><span class="line">    <span class="keyword">return</span> mans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="x04-代码">0x04 代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll lcm[<span class="number">3000</span>],f[<span class="number">20</span>][<span class="number">3000</span>][<span class="number">55</span>],num[<span class="number">55</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">asd</span><span class="params">(ll now,ll mod,ll gbs,ll jud)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mod%gbs==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">0</span> &amp;&amp; f[now][mod][lcm[gbs]]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> f[now][mod][lcm[gbs]];</span><br><span class="line">    &#125;</span><br><span class="line">    ll mmax=<span class="number">9</span>,mans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">1</span>) mmax=num[now];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=mmax;i++)&#123;</span><br><span class="line">         mans+=<span class="built_in">asd</span>(now<span class="number">-1</span>,(mod*<span class="number">10</span>+i)%<span class="number">2520</span>,i!=<span class="number">0</span>?i*gbs/<span class="built_in">gcd</span>(i,gbs):gbs,jud&amp;&amp;i==mmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jud==<span class="number">0</span>) f[now][mod][lcm[gbs]]=mans;</span><br><span class="line">    <span class="keyword">return</span> mans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        num[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">asd</span>(cnt<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=<span class="number">2520</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2520</span>%i==<span class="number">0</span>)&#123;</span><br><span class="line">            lcm[i]=j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll aa,bb;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;aa,&amp;bb);</span><br><span class="line">        ll ans=<span class="built_in">solve</span>(bb)-<span class="built_in">solve</span>(aa<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF576E</title>
    <url>/2023/12/08/CF576E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF576E">Painting
Edges</a></p>
<span id="more"></span>
<p>数据结构脑筋急转弯。</p>
<p><span class="math inline">\(k\)</span>
很小，可以对每种颜色分别维护。</p>
<p>二分图的判断较为容易，拓展域并查集即可（二分图无奇环）。</p>
<p>类似于 <a href="https://www.luogu.com.cn/problem/P5787">P5787 二分图
/【模板】线段树分治</a>，我们可以用线段树分治来解决这个问题，有同类题题解：<a
href="https://h01yshhmy.github.io/2023/12/08/CF1140F/">CF1140F |
h01yshhmy</a>。</p>
<p>对于同一条边，考虑相邻的两个操作，编号分别为 <span
class="math inline">\(i,j\)</span>，那么操作 <span
class="math inline">\(i\)</span> 影响到其他操作的范围是 <span
class="math inline">\([i+1,j-1]\)</span>。</p>
<p>所以将操作 <span class="math inline">\(i\)</span> 覆盖到 <span
class="math inline">\([i+1,j-1]\)</span>
上，在分治到叶子节点的时候判断操作 <span
class="math inline">\(i\)</span>
能否执行，并查集判断是否为二分图，可以发现操作不被执行实际上也就是把上一次执行的染色操作重新执行了一遍，把
<span class="math inline">\(c[i]\)</span> 改为上一次操作的颜色即可。</p>
<p>时间复杂度 <span class="math inline">\(O(nk+n\log^2 n)\)</span>。</p>
<p>总结：</p>
<p>实际上和线段树分治的模板很相似，难点或启发之处在于：将操作是否可以执行的<code>check</code>部分后置，考虑每个操作的影响区间，先将影响区间放在结构上维护，在影响区间真正造成影响之前再做<code>check</code>检验是否可以操作。</p>
<p>其实有想到过这种处理方法，但自己的写法是在线段树上挂着的每一个“边存在区间”都存颜色本身，所以改一次就需要修改
<span class="math inline">\(\log n\)</span>
个分布未知的区间的颜色——所以直接给否了。但其实线段树上挂颜色数组的下标，统一改颜色数组就好了，主打一个铸币，警钟长鸣。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,K=<span class="number">55</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pos[N],top,u[N],v[N],a[N],c[N],n,m,k,q,f[K][N&lt;&lt;<span class="number">1</span>],height[K][N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[c][x]==x?x:<span class="built_in">find</span>(c,f[c][x]);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> c,x,y,add;&#125;stk[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(height[c][x]&gt;height[c][y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    stk[++top]=node&#123;c,x,y,height[c][x]==height[c][y]&#125;;</span><br><span class="line">    f[c][x]=y;height[c][y]+=height[c][x]==height[c][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)&#123;e[p].<span class="built_in">push_back</span>(k);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>,l,mid,nl,nr,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,nl,nr,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> back=top,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fx=<span class="built_in">find</span>(c[i],u[a[i]]),fy=<span class="built_in">find</span>(c[i],v[a[i]]);</span><br><span class="line">        <span class="built_in">merge</span>(c[i],<span class="built_in">find</span>(c[i],u[a[i]]),<span class="built_in">find</span>(c[i],v[a[i]]+n));</span><br><span class="line">        <span class="built_in">merge</span>(c[i],<span class="built_in">find</span>(c[i],u[a[i]]+n),<span class="built_in">find</span>(c[i],v[a[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(c[r],u[a[r]])==<span class="built_in">find</span>(c[r],v[a[r]])) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),c[r]=pos[a[r]]; </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>),pos[a[r]]=c[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">while</span>(top&gt;back)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=stk[top].c,x=stk[top].x,z=stk[top].add;top--;</span><br><span class="line">        height[c][f[c][x]]-=z;f[c][x]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[j][i]=i,f[j][i+n]=i+n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u[i],&amp;v[i]),pos[i]=q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;c[i]);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;pos[a[i]]) <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,q,i+<span class="number">1</span>,pos[a[i]]<span class="number">-1</span>,i);</span><br><span class="line">        <span class="comment">//i+1是因为如果判断i时直接把它加进来，这时的颜色是新的颜色，但后面撤销的就是原来的颜色，就会产生错误 </span></span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pos,<span class="number">0</span>,<span class="built_in">sizeof</span>(pos));</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CF600E</title>
    <url>/2023/12/02/CF600E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF600E">Lomsat
gelral</a></p>
<span id="more"></span>
<p>可以当做树上启发式合并的板子。</p>
<p>树上启发式合并的核心思想其实就是信息的多次利用，对重儿子的特殊操作保证了时间复杂度的正确性。</p>
<p>树上启发式合并的题当然要先想暴力。</p>
<p>暴力很好做，对每个颜色记个数，维护当前的众数和众数编号和即可。</p>
<p>树上启发式合并只是优化了这个过程，代码其实差不多就是板子了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> n,c[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],siz[N],hson[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">predfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">predfs</span>(v,u);</span><br><span class="line">    siz[u]+=siz[v];</span><br><span class="line">    <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">      hson[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cannot,cnt[N],resmx;</span><br><span class="line">ll nowans,ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  cnt[c[u]]+=k;</span><br><span class="line">  <span class="keyword">if</span>(cnt[c[u]]&gt;resmx)&#123;</span><br><span class="line">    resmx=cnt[c[u]];</span><br><span class="line">    nowans=c[u];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[c[u]]==resmx)&#123;</span><br><span class="line">    nowans+=c[u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==cannot)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">update</span>(v,k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==hson[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">solve</span>(v,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hson[u])<span class="built_in">solve</span>(hson[u],<span class="number">1</span>),cannot=hson[u];</span><br><span class="line">  <span class="built_in">update</span>(u,<span class="number">1</span>);</span><br><span class="line">  ans[u]=nowans,cannot=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">update</span>(u,<span class="number">-1</span>);</span><br><span class="line">    nowans=resmx=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">read</span>(c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">read</span>(u,v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">    G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">predfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树上启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF678E</title>
    <url>/2023/12/02/CF678E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF678E">Another Sith
Tournament</a></p>
<span id="more"></span>
<p>重点在于倒着做。</p>
<p>看到 <span class="math inline">\(n\le 18\)</span>，显然是要状压。</p>
<p>如果直接模拟题意，设 <span
class="math inline">\(f[s][\cdots]\)</span> 为当前还剩 <span
class="math inline">\(s\)</span> 内的骑士活着（外加一些状态）
的成功概率，其实并不好做（当然也能写）。</p>
<p>考虑一种“倒着做”的思想，设 <span class="math inline">\(f[s]\)</span>
为：最开始有 <span class="math inline">\(s\)</span>
内的人参加决斗，<span class="math inline">\(1\)</span>
号的最大胜利概率。</p>
<p>就有一个非常简单的式子：</p>
<p><span class="math display">\[
\begin{aligned}
f[s]=\max\limits_{i,j\in s}f[s/i]\times a[j][i]+f[s/j]\times a[i][j]
\end{aligned}
\]</span></p>
<p>初始 <span class="math inline">\(f[\{1\}]=1\)</span>。</p>
<p>原理很显然，想转移到 <span class="math inline">\(f[s]\)</span> ，要么
<span class="math inline">\(i\)</span> 赢了 <span
class="math inline">\(j\)</span>，要么 <span
class="math inline">\(j\)</span> 赢了 <span
class="math inline">\(i\)</span>
，分别乘上概率即可，不需要考虑其他的繁杂，状态设计保证了正确性。</p>
<p>时间复杂度 <span class="math inline">\(O(2^n\times
n^2)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N],f[(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">2</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s]=<span class="built_in">max</span>(f[s],f[s^(<span class="number">1</span>&lt;&lt;j)]*a[i][j]+f[s^(<span class="number">1</span>&lt;&lt;i)]*a[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF696D</title>
    <url>/2023/12/14/CF696D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF696D">Legen...</a></p>
<span id="more"></span>
<p>建出AC自动机，考虑到模式串的子串可能是另一个模式串，要处理出串内子串权值和，<span
class="math inline">\(ed[fail[u]]\to ed[u]\)</span>。</p>
<p>考虑DP，有转移：</p>
<p><span class="math display">\[
f(i+1,\delta(j,c))=\max_{j,c}f(i,j)+w(\delta(j,c))
\]</span></p>
<p>发现第一维多达 <span class="math inline">\(10^{14}\)</span>，但是
<span class="math inline">\(j,c\)</span> 均较小，<span
class="math inline">\(c\)</span> 不影响数值，<span
class="math inline">\(w\)</span>
<strong>不变</strong>，可以矩阵加速。</p>
<p>容易构造一个矩阵 <span class="math inline">\(T\)</span>，如果 <span
class="math inline">\(\exists c,\delta(i,c)=j\)</span>，那么 <span
class="math inline">\(T_{i,j}=w(j)\)</span>，否则 <span
class="math inline">\(T_{i,j}=-\infty\)</span>。</p>
<p>定义矩阵乘法：<span class="math inline">\(C=A \times B\Leftrightarrow
C_{i,j}=\max(A_{i,k}+B_{k,j})\)</span>。</p>
<p>答案为初始向量 <span class="math inline">\(v\times T^k\)</span>。</p>
<p>可以将 <span class="math inline">\(T\)</span> 看作邻接矩阵，<span
class="math inline">\(c\)</span> 与数值无关，所以只要 <span
class="math inline">\(\exists c,\delta(i,c)=j\)</span>，<span
class="math inline">\(i\)</span> 就能走到 <span
class="math inline">\(j\)</span>，<span class="math inline">\(w\)</span>
即为边权，而最终答案就是最长路。</p>
<p>时间复杂度为 <span class="math inline">\(O(\log l\times
|s|^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>, S = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx, go[N][S], fa[N];</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(string s, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">        <span class="type">int</span> c = i - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!go[u][c]) go[u][c] = ++idx;</span><br><span class="line">        u = go[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    w[u] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">if</span> (go[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(go[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        w[u] += w[fa[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (go[u][i]) fa[go[u][i]] = go[fa[u]][i], q.<span class="built_in">push</span>(go[u][i]);</span><br><span class="line">            <span class="keyword">else</span> go[u][i] = go[fa[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll a[N][N];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">matrix</span>() &#123;<span class="built_in">memset</span>(a, <span class="number">-0x3f3f</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125; base, ans;</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix x, matrix y) &#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.n = x.n;</span><br><span class="line">    z.m = y.m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= x.m; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x.n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= y.m; j++) z.a[i][j] = <span class="built_in">max</span>(z.a[i][j], x.a[i][k] + y.a[k][j]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">quick_pow</span><span class="params">(matrix a, ll k)</span> </span>&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">    res.n = res.m = a.n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.n; i++) res.a[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base.n = base.m = idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; S; j++) base.a[i][go[i][j]] = w[go[i][j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_ans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans.n = <span class="number">0</span>;</span><br><span class="line">    ans.m = idx;</span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll L, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;n, &amp;L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s, <span class="built_in">ins</span>(s, a[i]);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">init_base</span>();</span><br><span class="line">    <span class="built_in">init_ans</span>();</span><br><span class="line">    ans = ans * <span class="built_in">quick_pow</span>(base, L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i++) mx = <span class="built_in">max</span>(mx, ans.a[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, mx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>矩阵加速</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CF698C</title>
    <url>/2023/12/01/CF698C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF698C">LRU</a></p>
<span id="more"></span>
<p>题面看起来有点难写。</p>
<p>看到 <span class="math inline">\(n,k\le 20\)</span>，向状压考虑。</p>
<p>设 <span class="math inline">\(f[s]\)</span> 为最终队列内有 <span
class="math inline">\(s\)</span> 中物品的概率。</p>
<p>可以分个类：</p>
<ol type="1">
<li><p>队列最终被装满</p></li>
<li><p>队列最终未满。</p></li>
</ol>
<p>极大的操作次数和良心的样例#4给了我们提示：最终答案可以忽略队列未满的情况。</p>
<p>也就是说 不断的选同一个物品，导致最后队列没满
的概率可以忽略，因为操作次数实在是太多了。</p>
<p>只需要对第一种情况<code>DP</code>了。</p>
<p><span class="math inline">\(f\)</span>
的状态设计改为第一次状态为的概率。</p>
<p>设 <span class="math inline">\(g[s]=\sum_{i\in s}p[i]\)</span></p>
<p><span
class="math inline">\(f[s\cup\{u\}]=f[s]\times\sum\limits_{i=0}^{\infty}p[u]g[s]^i\)</span></p>
<p>注：<span class="math inline">\(u\not\in s，p[u]\not=
0\)</span>。</p>
<p>等号其实应该为加等于，为了美观后文都是等号。</p>
<p>意义是：现在就选了 <span
class="math inline">\(u\)</span>，先选了一次队列内的又选 <span
class="math inline">\(u\)</span> ，先选了两次队列内的又选 <span
class="math inline">\(u\)</span>……</p>
<p>注意，这里 <span class="math inline">\(|s|&lt;
k\)</span>，也就是说<strong>不需要考虑弹出</strong>的情况，队列满了之后就不再转移了。</p>
<p>为什么设成第一次状态为 <span
class="math inline">\(s\)</span>，不考虑弹出，是对的呢？</p>
<p>对于选数的序列，队列内的元素构成了整个序列上的一个长为的滑动窗口，在概率不变的随机序列上的滑动窗口。</p>
<p>因为操作次数过多，所以有重复元素不<code>push</code>不会对上述造成影响。</p>
<p>无论窗口放在哪里，对应状态的概率都应该不变，所以我们不如放在最开头。</p>
<p>式子显然不能到此为止。</p>
<p><span class="math display">\[
\begin{aligned}
f[s\cup\{u\}]&amp;=f[s]\times\sum\limits_{i=0}^{\infty}p[u]g[s]^i\\
&amp;=f[s]\times p[u]\sum\limits_{i=0}^{\infty}g[s]^i\\
&amp;=f[s]\times p[u]\times \dfrac{1}{1-g[s]}
\end{aligned}
\]</span></p>
<p>现在就可以转移了。</p>
<p>刷表法，代码中 <span class="math inline">\(\frac{1}{1-g[s]}\)</span>
是滞后乘上的。</p>
<p>有个小问题：要特判 <span
class="math inline">\(\sum\limits_{i=1}^n[p[i]&gt;0]&lt;k\)</span>
的情况，也就是说不可能放满，这样只要有概率就一定会存在于最终队列。</p>
<p>总结：
对于操作次数极大的题，忽略小概率事件，考虑整个状态序列上是否有“一般性”，不太好描述，大概就像是上文中：窗口在最后和最前面是一样的，因为概率一直相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">25</span>)</span>,<span class="title">vN</span><span class="params">(<span class="number">1.1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">double</span> p[N],f[vN],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">        cnt+=(p[i]&gt;eps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;k)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]&lt;=eps)cout&lt;&lt;<span class="string">&quot;0.0 &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;1.0 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cnt=__builtin_popcount(s);</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">            <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)ans[i]+=f[s];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)sum+=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        f[s]/=(<span class="number">1</span>-sum);</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(~s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s|(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]+=f[s]*p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF794D</title>
    <url>/2024/01/12/CF794D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF794D">Labelling
Cities</a></p>
<span id="more"></span>
<p>性质题。</p>
<p>首先读明白题，如果 <span class="math inline">\(|x_i-x_j|\le
1\)</span>，<span class="math inline">\(i,j\)</span> 之间一定有边，<span
class="math inline">\(i,j\)</span> 之间没有边，<span
class="math inline">\(|x_i-x_j|\le 1\)</span>
<strong>一定不</strong>成立。</p>
<p>如果存在两个点的邻居集合（包括自己）完全相同，那么让这两个点权值相同一定不劣，而且邻居集合不同的两点，权值相同一定不合法。</p>
<p>证明显然，略。</p>
<p>考虑按照邻居集合将点划分成一些点集，同一个点集内的 <span
class="math inline">\(x\)</span> 均相等。</p>
<p>将集合缩成一个点，我们只关心两种集合之间是否存在至少一条边，边也可以缩减。</p>
<p>对于处理后的图，相邻点必须相差 <span
class="math inline">\(1\)</span>，而且与其他点相差 <span
class="math inline">\(&gt;1\)</span>。</p>
<p>显然不能存在大于等于三度的点。</p>
<p>也就是说图全是链，对每个链判断是否能染成合法颜色即可。</p>
<p>构造方案较为容易，链上不断 <span
class="math inline">\(+1\)</span>，不同的链之间 <span
class="math inline">\(+2\)</span> 做区分。反正值域 <span
class="math inline">\(10^9\)</span> 很充足。</p>
<p>对于实现，判断邻居集合是否相等可以用异或哈希，中间还要开一些桶。</p>
<p>用 <code>map&lt;pair&lt;int,int&gt;,int&gt;</code> 做桶，时间复杂度
<span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],G2[N];</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">pii val[N],tot[N];</span><br><span class="line">map&lt;pii,<span class="type">int</span>&gt; mp,ed;</span><br><span class="line"><span class="type">int</span> ncnt,bel[N],deg[N];</span><br><span class="line"><span class="type">int</span> vis[N],ans[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        val[i]=&#123;<span class="built_in">rnd</span>(),<span class="built_in">rnd</span>()&#125;;</span><br><span class="line">        tot[i]=val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">        tot[u]=&#123;tot[u].fi^val[v].fi,tot[u].se^val[v].se&#125;;</span><br><span class="line">        tot[v]=&#123;tot[v].fi^val[u].fi,tot[v].se^val[u].se&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tot[i]))&#123;</span><br><span class="line">            mp[tot[i]]=++ncnt;</span><br><span class="line">        &#125;</span><br><span class="line">        bel[i]=mp[tot[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:G[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ed[&#123;bel[i],bel[j]&#125;]||bel[i]==bel[j])<span class="keyword">continue</span>;</span><br><span class="line">            G2[bel[i]].<span class="built_in">pb</span>(bel[j]),G2[bel[j]].<span class="built_in">pb</span>(bel[i]);</span><br><span class="line">            deg[bel[i]]++,deg[bel[j]]++;</span><br><span class="line">            ed[&#123;bel[i],bel[j]&#125;]=ed[&#123;bel[j],bel[i]&#125;]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mxdeg=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">re</span>(i,ncnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            ans[i]+=(cnt+=<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        mxdeg=<span class="built_in">max</span>(mxdeg,deg[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mxdeg&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        cnt+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> flg=<span class="number">0</span>;</span><br><span class="line">            vis[u]=<span class="number">1</span>,ans[u]=++cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:G2[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">                u=v,flg=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flg==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[bel[i]],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>哈希</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF802I</title>
    <url>/2023/12/13/CF802I/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF802I">Fake News
(hard)</a></p>
<span id="more"></span>
<p>一个典题，两种做法，三道同类。</p>
<p>同类题：<a
href="https://www.luogu.com.cn/problem/P4248">P4248</a>，<a
href="https://www.luogu.com.cn/problem/P3181">P3181</a></p>
<h2 id="sa单调栈">SA+单调栈</h2>
<p>拆贡献。</p>
<p>枚举全部子串，维护当前答案，每次对答案贡献为 <span
class="math inline">\((cnt(s,p)+1)^2-cnt(s,p)^2=2\times
cnt(s,p)+1\)</span>。</p>
<p>子串就是后缀的前缀，对 <span class="math inline">\(s\)</span>
后缀排序，求出后缀数组 <span class="math inline">\(sa\)</span> 和 <span
class="math inline">\(height\)</span> 数组（简记为 <span
class="math inline">\(h\)</span>）。</p>
<p>所求答案为 <span class="math inline">\(\sum_{i=1}^n\sum_{t\in
pre(sa_i)}2\times f(t)+1\)</span></p>
<p><span class="math inline">\(f(t)\)</span> 就是后缀排序后，前 <span
class="math inline">\(i\)</span> 个后缀中串 <span
class="math inline">\(t\)</span>
作为<strong>前缀</strong>出现的次数。</p>
<p>进一步得到 <span class="math inline">\(\frac{n(n+1)}{2}+2\times
\sum_{i=1}^n\sum_{t\in pre(sa_i)}f(t)\)</span>。</p>
<p>换个角度算答案（相当于拆 <span class="math inline">\(f\)</span>
的贡献后再重组），后缀排序后，枚举两个<strong>下标</strong> <span
class="math inline">\(i,j\,(i&lt;j)\)</span>，求 <span
class="math inline">\(sa_i,sa_j\)</span> 的LCP。LCP的每一个前缀 <span
class="math inline">\(t\)</span>，从 <span
class="math inline">\(j\)</span> 的角度上来讲，<span
class="math inline">\(t\)</span> 的出现次数多了一次，对答案造成了 <span
class="math inline">\(1\)</span> 的贡献，所以 <strong>LCP长度就是 <span
class="math inline">\(i,j\)</span> 对答案的贡献</strong>。</p>
<p>将LCP转为 <span class="math inline">\(h\)</span>
数组上区间最小值。</p>
<p>有式子 <span
class="math inline">\(\frac{n(n+1)}{2}+2\sum_{i=2}^n\sum_{j=2}^{i-1}\min_{height}(i,j)\)</span>。</p>
<p><span class="math inline">\(h[1]\)</span> 是未定义的，所以都从 <span
class="math inline">\(2\)</span> 开始。</p>
<p>求每个前缀的每个后缀的最小值之和，使用单调栈，记录当前前缀的栈内后缀最小值之和，不断延长前缀即可。</p>
<h2 id="sa并查集">SA+并查集</h2>
<p>后缀排序，以 <span class="math inline">\(height\)</span>
数组为关键字<strong>从大到小</strong>对下标排序，<strong>从大到小</strong>枚举重复出现的这个子串的长度
<span class="math inline">\(len\)</span>，用一个指针维护当前 <span
class="math inline">\(height\)</span>，如果当前 <span
class="math inline">\(height\ge
len\)</span>，指针右移，并将指针相邻位置在并查集上合并，代表“在之后的
<span class="math inline">\(len\)</span> 中，连通块内的LCP将恒 <span
class="math inline">\(\ge
len\)</span>”，也就是说它们可以贡献答案，且不再分开，维护连通块大小算答案即可。</p>
<p>事实上这个思路是有启发意义的，有一些题为了维护其他信息，需要用
启发式合并/线段树合并/重构树 来代替并查集做合并。</p>
<p>两种做法时间复杂度都是 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<p>单调栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsiz=<span class="number">130</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll T,n,m,sa[maxn],x[maxn],y[maxn],c[maxn],rnk[maxn],h[maxn],ans,tot,cnt;</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;ll v,cnt;&#125;;</span><br><span class="line">stack&lt;node&gt;st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);m=maxsiz<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)x[i]=s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[c[x[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>,cur;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-k;i--)y[++cur]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(sa[i]&gt;k)y[++cur]=sa[i]-k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)c[x[i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[c[x[y[i]]]--]=y[i];</span><br><span class="line">            cur=y[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a,b;</span><br><span class="line">                a=sa[i]+k&gt;n?<span class="number">-1</span>:x[sa[i]+k];</span><br><span class="line">                b=sa[i<span class="number">-1</span>]+k&gt;n?<span class="number">-1</span>:x[sa[i<span class="number">-1</span>]+k];</span><br><span class="line">                y[sa[i]]=(x[sa[i]]==x[sa[i<span class="number">-1</span>]])&amp;&amp;(a==b)?cur:(++cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;=n)<span class="keyword">break</span>;</span><br><span class="line">            m=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rnk[sa[i]]=i;</span><br><span class="line">        <span class="type">int</span> nww=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rnk[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nww)nww--;</span><br><span class="line">            <span class="keyword">while</span>(i+nww&lt;=n&amp;&amp;sa[rnk[i]<span class="number">-1</span>]+nww&lt;=n&amp;&amp;s[i+nww]==s[sa[rnk[i]<span class="number">-1</span>]+nww])nww++;</span><br><span class="line">            h[rnk[i]]=nww;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">top</span>().v&gt;=h[i])</span><br><span class="line">            cnt+=st.<span class="built_in">top</span>().cnt,</span><br><span class="line">            tot-=st.<span class="built_in">top</span>().v*st.<span class="built_in">top</span>().cnt,</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(&#123;h[i],cnt+<span class="number">1</span>&#125;);tot+=h[i]*(cnt+<span class="number">1</span>);</span><br><span class="line">            ans+=<span class="number">2</span>*tot; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并查集：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,sa[N],sa2[N],bin[N],rk[N],rk2[N],h[N],m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,m)bin[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)bin[rk[i]]++;</span><br><span class="line">    <span class="built_in">re</span>(i,m)bin[i]+=bin[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">pe</span>(i,n)sa[bin[rk[sa2[i]]]--]=sa2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m=<span class="number">128</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,sa2[i]=i;</span><br><span class="line">    <span class="built_in">Bsort</span>();</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        cur=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,n-k+<span class="number">1</span>,n)sa2[++cur]=i;</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="keyword">if</span>(sa[i]&gt;k)sa2[++cur]=sa[i]-k;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        rk2[sa[<span class="number">1</span>]]=cur=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rk[sa[i]]!=rk[sa[i<span class="number">-1</span>]]||rk[sa[i]+k]!=rk[sa[i<span class="number">-1</span>]+k])&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rk2[sa[i]]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(rk,rk2);</span><br><span class="line">        <span class="keyword">if</span>(cur==n)<span class="keyword">break</span>;</span><br><span class="line">        m=cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            k=h[<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])k++;</span><br><span class="line">        h[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N],p[N],siz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">getSA</span>();</span><br><span class="line">    <span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        fa[i]=p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> h[x]&gt;h[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,pos=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=n&amp;&amp;h[p[pos]]&gt;=i)&#123;</span><br><span class="line">            u=sa[p[pos]],v=sa[p[pos]<span class="number">-1</span>];</span><br><span class="line">            u=<span class="built_in">findfa</span>(u),v=<span class="built_in">findfa</span>(v);</span><br><span class="line">            sum-=<span class="number">1ll</span>*siz[u]*siz[u]+<span class="number">1ll</span>*siz[v]*siz[v];</span><br><span class="line">            siz[v]+=siz[u];</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            sum+=<span class="number">1ll</span>*siz[v]*siz[v];</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">0</span>;cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--&gt;<span class="number">0</span>)<span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>字符串</tag>
        <tag>SA</tag>
        <tag>SAM</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>CF825F</title>
    <url>/2023/12/02/CF825F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF825F">String
Compression</a></p>
<span id="more"></span>
<p>对这种 各个子段有操作 要求全局最优化
的问题，大多都是要写<code>DP</code>，且<code>DP</code>的计算过程一般都是
目前右端点是 <span
class="math inline">\(i\)</span>，向前枚举子段的左端点。</p>
<p>设 <span class="math inline">\(f[i]\)</span>：长度为 <span
class="math inline">\(i\)</span> 前缀的答案，显然 <span
class="math inline">\(f[i]\)</span> 可以从 <span
class="math inline">\(f[j],j\in[1,i-1]\)</span> 转移而来。</p>
<p>为了好写，后面都采用和上述没有本质区别的刷表法，也就是从 <span
class="math inline">\(f[i]\)</span> 转移到 <span
class="math inline">\(f[i+j],j\in[1,n-i]\)</span>。</p>
<p>那么就要考虑 <span class="math inline">\([i+1,i+j]\)</span>
这一段如何计算了。</p>
<p>发现题目和循环节相关，想到字符串中经典结论：设 <span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(border\)</span> 集合为 <span
class="math inline">\(B\)</span>，若 <span class="math inline">\(\exists
T\in B,2|T|\ge |S|\)</span>，则 <span class="math inline">\(S\)</span>
的周期为 <span class="math inline">\(|S|-|T|\)</span>，最短周期就是最长
<span class="math inline">\(border\)</span> 对应的 <span
class="math inline">\(|S|-|T|\)</span>。</p>
<p>也就是说，我们需要求出当前 <span
class="math inline">\([i+1,n]\)</span> 这个后缀内的 <span
class="math inline">\(border\)</span>，因为要在后缀中枚举 <span
class="math inline">\(i+j\)</span> 位置。</p>
<p>用 <code>KMP</code> 求这个后缀的 <code>next</code>
数组即可，字符串（也就是这个后缀）中长度为 <span
class="math inline">\(j\)</span> 的前缀的最短周期为：<span
class="math inline">\(j-next[j]\)</span>。</p>
<p>显然数字增长带来的长度增加比周期本身的长度增加慢的多，所以只需要找最短周期。</p>
<p>转移时判断 <span class="math inline">\(j\equiv 0\mod
(j-next[j])\)</span>
是否成立，成立就可以缩成<code>?abc</code>的形式，不成立就是<code>1abc</code>的形式。</p>
<p>其实这可以看作通过周期的性质找到了最优转移点，也算是<code>KMP</code>优化<code>DP</code>了吧。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">8005</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,cnt[N],f[N],nxt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>]=nxt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> p=nxt[i];</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;s[i]!=s[p])p=nxt[p];</span><br><span class="line">        nxt[i+<span class="number">1</span>]=(s[p]==s[i])?p+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cnt[i]=cnt[i/<span class="number">10</span>]+<span class="number">1</span>;</span><br><span class="line">        f[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">kmp</span>(s+i,n-i);</span><br><span class="line">        <span class="built_in">re</span>(j,n-i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j%(j-nxt[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                f[i+j]=<span class="built_in">min</span>(f[i+j],f[i]+cnt[j/(j-nxt[j])]+j-nxt[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i+j]=<span class="built_in">min</span>(f[i+j],f[i]+j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF833B</title>
    <url>/2023/12/01/CF833B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF833B">The Bakery</a></p>
<span id="more"></span>
<p>先考虑朴素<code>DP</code></p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数分成 <span
class="math inline">\(j\)</span> 块的最大价值，<span
class="math inline">\(w\)</span> 为区间的价值。</p>
<p><span class="math display">\[
f[i][j]=\max_{k=1}^if[k][j-1]+w(k+1,i)
\]</span></p>
<p>时间复杂度 <span
class="math inline">\(O(n^2k)\)</span>，不能接受。</p>
<p>发现我们枚举到第一维了，所以调换一下状态，便于优化。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(j\)</span> 个数分成 <span
class="math inline">\(i\)</span> 块。</p>
<p><span class="math display">\[
f[i][j]=\max_{k=1}^jf[i-1][k]+w(k+1,j)
\]</span></p>
<p>后面的 <span class="math inline">\(\max\)</span>
都在同一行内，可以用数据结构优化。</p>
<p>如何求出 <span
class="math inline">\(w\)</span>？我们可以“在线”做。</p>
<p>因为 <span class="math inline">\(k\le j\)</span>，所以枚举到 <span
class="math inline">\(j\)</span> 的时候，<span
class="math inline">\(w\)</span> 能用到的右边界就是 <span
class="math inline">\(j\)</span>。</p>
<p>所以转移时动态贡献答案是可行的。</p>
<p>每次向右走一格（<span
class="math inline">\(j+1\)</span>），对于每一位 <span
class="math inline">\(f[i-1][k]\)</span>，加上新的 <span
class="math inline">\(j\)</span> 造成的贡献。</p>
<p>这个可以预处理出每个数前第一个相等的数的位置 <span
class="math inline">\(las[i]\)</span> 来做。</p>
<p>具体的，对 <span class="math inline">\([las[i]+1,1]\)</span> 区间
<span class="math inline">\(+1\)</span>，每次查询 <span
class="math inline">\([1,j]\)</span> 的最大值。</p>
<p>显然可以使用线段树维护，对于每一个 <span
class="math inline">\(i\)</span> 都清空一遍线段树即可。</p>
<p>时间复杂度 <span class="math inline">\(O(nk\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">35005</span>)</span>,<span class="title">K</span><span class="params">(<span class="number">55</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">int</span> f[K][N];</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> mx,lz;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].mx+=v;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].lz=t[rt].mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mx=f[now<span class="number">-1</span>][l<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mx;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> las[N],pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        las[i]=pos[a[i]];</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        now=i;</span><br><span class="line">        t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,las[j]+<span class="number">1</span>,j);</span><br><span class="line">            f[i][j]=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[m][n],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF886E</title>
    <url>/2023/12/01/CF886E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF886E">Maximum
Element</a></p>
<span id="more"></span>
<p>设 <span class="math inline">\(f_i\)</span> 为 <span
class="math inline">\(i\)</span> 的排列中程序运行不会出错的方案数
也就是<span class="math inline">\(i\in [i+k+1,i]\)</span>。</p>
<p><span class="math inline">\(f_i\)</span> 可以被 <span
class="math inline">\(j\in[i-k,i-1]\)</span> 转移到，除去最大值 <span
class="math inline">\(i\)</span> 外 剩余 $i-1 $个中 有 <span
class="math inline">\(i-j\)</span> 个为自由的</p>
<p>自由位置造成的贡献是 <span
class="math inline">\(A_{i-j}^{i-1}\)</span></p>
<p>然后需要一些前缀和优化复杂度。</p>
<p>最后要容斥一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,f[N],s[N],fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  io&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1e6</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=k)f[i]=fac[i];</span><br><span class="line">        <span class="keyword">else</span> f[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*(s[i<span class="number">-1</span>]-s[i-k<span class="number">-1</span>]+Mod)%Mod;</span><br><span class="line">        s[i]=(s[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*ifac[i]%Mod)%Mod;</span><br><span class="line">  &#125;</span><br><span class="line">    io&lt;&lt;(fac[n]<span class="number">-1ll</span>*fac[n<span class="number">-1</span>]*(s[n<span class="number">-1</span>]+<span class="number">1</span>)%Mod+Mod)%Mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>组合</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CF893F</title>
    <url>/2023/12/01/CF893F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF893F">Subtree Minimum
Query</a></p>
<span id="more"></span>
<p>一个找性质DS题。</p>
<p>题意：有根有点权的树，给定 <span
class="math inline">\(u,k\)</span>，求以 <span
class="math inline">\(u\)</span> 为根子树中深度在 <span
class="math inline">\([dep[u],dep[u]+k]\)</span>
内的点的点权最小值，强制在线。</p>
<p>首先可以想到一个比较无脑的做法：用树套树，大树维护dfs序，小树维护深度，也就是在线的二维数点写法。</p>
<p>注意到询问次数 <span class="math inline">\(10^6\)</span>，<span
class="math inline">\(O(m\log^2 n)\)</span>
的树套树很难通过，需要指令集大力卡常。</p>
<p>我们将树上问题转化为二维矩形问题的时候，忽略了点和深度的关联。</p>
<p>在dfs序上查找的 <span
class="math inline">\([id[u],id[u]+siz[u]-1]\)</span>
这个区间，对深度有性质：内部的点深度均 <span class="math inline">\(\ge
dep[u]\)</span>。</p>
<p>所以就可以直接“忽略”点的深度 <span
class="math inline">\(&lt;dep[u]\)</span> 的限制，这样的点在以
为根子树区间内根本不存在。</p>
<p>所以说转化的时候要动脑子，看看有没有扔了的性质，不要写DS写魔怔了。</p>
<p>用主席树，深度为时间轴，时间轴上每棵线段树维护dfs序。</p>
<p>总的来说，主席树是深度上前缀最小值的线段树序列。</p>
<p>查询直接查第 <span class="math inline">\(dep[u]+k\)</span>
棵树的对应区间即可，查到所有可能出现的值都是深度在 <span
class="math inline">\([dep[u],dep[u]+k]\)</span> 之间的。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,rt,a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> dep[N],idx[N],siz[N],dfn[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[idx[u]=++dfncnt]=u;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>],mn;</span><br><span class="line">        <span class="built_in">Seg</span>()&#123;mn=inf;&#125;</span><br><span class="line">    &#125;t[N*<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> ncnt,rot[N];</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> rot[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt||rt==old)rt=++ncnt;</span><br><span class="line">        t[rt]=t[old];</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mn=v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),<span class="built_in">ls</span>(old),l,mid,p,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),<span class="built_in">rs</span>(old),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">        t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mn;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,rt);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,rt);</span><br><span class="line">    <span class="built_in">re</span>(i,n)p[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> dep[x]&lt;dep[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        t.<span class="built_in">insert</span>(t[dep[p[i]]],t[dep[p[i<span class="number">-1</span>]]],<span class="number">1</span>,n,idx[p[i]],a[p[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,k);</span><br><span class="line">        u=(u+ans)%n+<span class="number">1</span>;</span><br><span class="line">        k=(k+ans)%n;</span><br><span class="line">        ans=t.<span class="built_in">query</span>(t[<span class="built_in">min</span>(dep[u]+k,dep[p[n]])],<span class="number">1</span>,n,idx[u],idx[u]+siz[u]<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>CF911G</title>
    <url>/2023/12/01/CF911G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF911G">Mass Change
Queries</a></p>
<span id="more"></span>
<p>首先能想到线段树暴力打100个tag的做法。</p>
<p>但时间复杂度不够优秀。</p>
<p>考虑另一种方式：开100棵线段树。</p>
<p>第 <span class="math inline">\(i\)</span> 棵线段树维护数字 <span
class="math inline">\(i\)</span> 所在位置（区间）。</p>
<p>感性理解一下，对于其中的一棵树，我们要维护一个像是：不带路径压缩的并查集结构。</p>
<p>区别在于：每个节点代表是一个区间，区间内都是这棵树所代表的数。</p>
<p>如果是并查集，可以直接合并，线段树当然就要写线段树合并了。</p>
<p>当然，线段树内不需要维护任何信息，因为树的编号 <span
class="math inline">\([1,100]\)</span> 和节点区间就是需要的信息。</p>
<p>用动态开点写一写即可。</p>
<p>时间复杂度大概是 <span class="math inline">\(O(m\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,ncnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> root[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!u||!v)<span class="keyword">return</span> u|v;</span><br><span class="line">  <span class="built_in">ls</span>(u)=<span class="built_in">merge</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v));</span><br><span class="line">  <span class="built_in">rs</span>(u)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v));</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!rt)rt=++ncnt;</span><br><span class="line">  <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),l,mid,id);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span>&amp; v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!u)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">    v=<span class="built_in">merge</span>(u,v),u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!v)v=++ncnt;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">work</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v),l,mid,ml,mr);</span><br><span class="line">  <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">work</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v),mid+<span class="number">1</span>,r,ml,mr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getAns</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    ans[l]=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">getAns</span>(<span class="built_in">ls</span>(rt),l,mid,c);</span><br><span class="line">  <span class="built_in">getAns</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">insert</span>(root[x],<span class="number">1</span>,n,i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;	</span><br><span class="line">        <span class="built_in">read</span>(l,r,x,y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;	</span><br><span class="line">    <span class="built_in">work</span>(root[x],root[y],<span class="number">1</span>,n,l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">re</span>(i,<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">getAns</span>(root[i],<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF954F</title>
    <url>/2023/12/01/CF954F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF954F">Runner's
Problem</a></p>
<span id="more"></span>
<p>题目看起来就非常的<code>DP</code>。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为走到 <span
class="math inline">\((j,i)\)</span> 的方案数。</p>
<p>在没有障碍的前提下，可以直接转移： <span class="math display">\[
\begin{aligned}
f[i][1]=f[i-1][1]+f[i-1][2]
f[i][2]=f[i-1][1]+f[i-1][2]+f[i-1][3];
f[i][3]=f[i-1][2]+f[i-1][3]
\end{aligned}
\]</span> 复杂度为 <span
class="math inline">\(O(m)\)</span>，不太行。</p>
<p>线性递推，考虑矩阵加速。</p>
<p>容易构造一个矩阵：</p>
<p><span class="math display">\[
\begin{bmatrix}1&amp;1&amp;0\\1&amp;1&amp;1\\0&amp;1&amp;1\end{bmatrix}\times
\begin{bmatrix}f[n-1][1]\\f[n-1][2]\\f[n-1][3]\end{bmatrix}=\begin{bmatrix}f[n][1]\\f[n][2]\\f[n][3]\end{bmatrix}
\]</span></p>
<p>但我们要考虑障碍的处理。</p>
<p>其实也很简单，发现障碍区间个数为 <span
class="math inline">\(10^4\)</span>。所以可以直接将整个地图划分为若干个有相同障碍状态的段。</p>
<p>分段用不同的转移矩阵做快速幂就好了。（哪一行有障碍，就在转移矩阵中置
<span class="math inline">\(0\)</span>
哪一行），判断障碍需要离散化之后用差分前缀和做区间 <span
class="math inline">\(+1\)</span> 的标记。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n+27n\log
m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) a[i][j] = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) a[i][j] = (i == j); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">origin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(k, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c.a[i][j] += a[i][k] * b.a[k][j] % Mod;</span><br><span class="line">            c.a[i][j] %= Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mat <span class="title">qpow</span><span class="params">(mat a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat res;</span><br><span class="line">    res.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line">ll m, bas[N], sum[<span class="number">3</span>][N];</span><br><span class="line"><span class="type">int</span> l[N], r[N], op[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op[i], l[i], r[i]);</span><br><span class="line">        op[i]--;</span><br><span class="line">        bas[++cnt] = l[i] - <span class="number">1</span>;</span><br><span class="line">        bas[++cnt] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bas[++cnt] = <span class="number">1</span>;</span><br><span class="line">    bas[++cnt] = m;</span><br><span class="line">    <span class="built_in">sort</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>) - bas - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = <span class="built_in">lower_bound</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>, l[i]) - bas;</span><br><span class="line">        r[i] = <span class="built_in">lower_bound</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>, r[i]) - bas;</span><br><span class="line">        sum[op[i]][l[i]]++;</span><br><span class="line">        sum[op[i]][r[i] + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">re</span>(i, cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[j][i] += sum[j][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    mat ans, t;</span><br><span class="line">    ans.<span class="built_in">reset</span>();</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">origin</span>();</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[j][i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.a[j][<span class="number">0</span>] = t.a[j][<span class="number">1</span>] = t.a[j][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">qpow</span>(t, bas[i] - bas[i - <span class="number">1</span>]);</span><br><span class="line">        ans = t * ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans.a[<span class="number">1</span>][<span class="number">0</span>], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>JOISC2014E</title>
    <url>/2023/12/27/JOISC2014E/</url>
    <content><![CDATA[<p><a
href="https://www.luogu.com.cn/problem/AT_joisc2014_e">水筒</a></p>
<span id="more"></span>
<p>观察题面，以建筑之间距离为边权，要使 <span class="math inline">\(S\to
T\)</span> 路径上经过的边权最大值最小。</p>
<p>显然可以最小生成树，生成树外的边满足边权大于等于边两端之间链上任何一个边权。</p>
<p>答案就是最小生成树上 <span class="math inline">\(S\to T\)</span>
的链上最大值。</p>
<p>考虑怎么求最小生成树。</p>
<p>做BFS，将建筑集合作为起点集合，做搜索的过程中染色，并维护一个并查集。</p>
<p>如果出现不同的颜色重叠且这两种颜色没有在并查集中连通，说明有两个建筑
<span class="math inline">\(u,v\)</span>
<strong>第一次</strong>搜到了同一个点 <span
class="math inline">\(p\)</span>，那么将 <span
class="math inline">\(dis(u,p)+dis(p,v)+1\)</span> 作为 <span
class="math inline">\(u,v\)</span>
边上的边权，并合并并查集；否则就加入队列继续搜索。因为是广搜，所以第一次重叠一定是最短路。</p>
<p>这里相当于是：对于最蠢的暴力求最短路做了优化，因为一共只需要知道前
<span class="math inline">\(P-1\)</span>
小的路径，所以要用一些手段使得边的出现顺序是从最短边开始递增的，广搜找中继点
<span class="math inline">\(p\)</span> 的搜索过程满足要求。</p>
<p>时间复杂度 <span class="math inline">\(O(HW+(P+Q)\log
P)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">re</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p=<span class="number">0</span>; <span class="type">char</span> i=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(i&lt;<span class="string">&#x27;0&#x27;</span>||i&gt;<span class="string">&#x27;9&#x27;</span>)	i=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(i&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;i&lt;=<span class="string">&#x27;9&#x27;</span>)	p=p*<span class="number">10</span>+i-<span class="string">&#x27;0&#x27;</span>,i=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p,T,sum,cnt,k;</span><br><span class="line"><span class="type">char</span> a[M][M];</span><br><span class="line"><span class="type">int</span> dis[M][M],b[M][M],fa[N];</span><br><span class="line"><span class="type">int</span> fir[N],nex[N],poi[N],val[N];</span><br><span class="line"><span class="type">int</span> dep[N],f[N][<span class="number">20</span>],t[N][<span class="number">20</span>];</span><br><span class="line"><span class="type">bool</span> v[M][M],used[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zy</span> &#123;</span><br><span class="line">  <span class="type">int</span> from,to;</span><br><span class="line">  <span class="type">int</span> w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> &#123;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">&#125;que[N];</span><br><span class="line">queue&lt;E &gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  nex[++sum]=fir[x];</span><br><span class="line">  poi[sum]=y;</span><br><span class="line">  val[sum]=z;</span><br><span class="line">  fir[x]=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    E now=q.<span class="built_in">front</span>(); </span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x=now.x;</span><br><span class="line">    <span class="type">int</span> y=now.y;</span><br><span class="line">    v[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">      <span class="type">int</span> xx=x+dx[i];</span><br><span class="line">      <span class="type">int</span> yy=y+dy[i];</span><br><span class="line">      <span class="keyword">if</span>(xx&lt;<span class="number">1</span>||xx&gt;n||yy&lt;<span class="number">1</span>||yy&gt;m||a[xx][yy]==<span class="string">&#x27;#&#x27;</span>||v[xx][yy])	<span class="keyword">continue</span>;</span><br><span class="line">      v[x][y]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(!b[xx][yy]) &#123;</span><br><span class="line">        b[xx][yy]=b[x][y];</span><br><span class="line">        dis[xx][yy]=dis[x][y]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>((E)&#123;xx,yy&#125;);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span>(b[xx][yy]!=b[x][y]) </span><br><span class="line">      &#123;</span><br><span class="line">        e[++cnt].from=b[xx][yy];</span><br><span class="line">        e[cnt].to=b[x][y];</span><br><span class="line">        e[cnt].w=dis[xx][yy]+dis[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(zy x,zy y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[x]!=x)	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">  <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> father,<span class="type">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[x]=deep; used[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=fir[x];i;i=nex[i]) &#123;</span><br><span class="line">    <span class="type">int</span> p=poi[i];</span><br><span class="line">    <span class="keyword">if</span>(p==father)	<span class="keyword">continue</span>;</span><br><span class="line">    f[p][<span class="number">0</span>]=x;</span><br><span class="line">    t[p][<span class="number">0</span>]=val[i];</span><br><span class="line">    <span class="built_in">dfs</span>(p,x,deep+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">19</span>;j++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">    f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>],</span><br><span class="line">    t[i][j]=<span class="built_in">max</span>(t[i][j<span class="number">-1</span>],t[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">find</span>(fa[x])!=<span class="built_in">find</span>(fa[y])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&lt;dep[y])	<span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)	</span><br><span class="line">    <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">      ans=<span class="built_in">max</span>(ans,t[x][i]),x=f[x][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y)	<span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]==f[y][i]||!f[x][i]||!f[y][i])	<span class="keyword">continue</span>;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(t[x][i],t[y][i]));</span><br><span class="line">    x=f[x][i]; y=f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(t[x][<span class="number">0</span>],t[y][<span class="number">0</span>]));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">re</span>(); m=<span class="built_in">re</span>(); p=<span class="built_in">re</span>(); T=<span class="built_in">re</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)	cin&gt;&gt;a[i][j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++) &#123;</span><br><span class="line">    <span class="type">int</span> X,Y;</span><br><span class="line">    X=<span class="built_in">re</span>(); Y=<span class="built_in">re</span>();</span><br><span class="line">    b[X][Y]=i;</span><br><span class="line">    q.<span class="built_in">push</span>((E)&#123;X,Y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)	fa[i]=i;</span><br><span class="line">  <span class="built_in">sort</span>(e+<span class="number">1</span>,e+cnt+<span class="number">1</span>,cmp);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(e[i].from);</span><br><span class="line">    <span class="type">int</span> fy=<span class="built_in">find</span>(e[i].to);</span><br><span class="line">    <span class="keyword">if</span>(fx==fy)	<span class="keyword">continue</span>;</span><br><span class="line">    fa[fy]=fx;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="built_in">ins</span>(e[i].from,e[i].to,e[i].w);</span><br><span class="line">    <span class="built_in">ins</span>(e[i].to,e[i].from,e[i].w);</span><br><span class="line">    <span class="keyword">if</span>(k==p<span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">    <span class="keyword">if</span>(!used[i])	<span class="built_in">dfs</span>(i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Dp</span>();</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    x=<span class="built_in">re</span>(); y=<span class="built_in">re</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Lca</span>(x,y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>倍增</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P1350</title>
    <url>/2023/12/01/P1350/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1350">P1350
车的放置</a></p>
<span id="more"></span>
<p>首先 <span class="math inline">\(n\times n\)</span> 的正方形中放
<span class="math inline">\(n\)</span> 个的方案显然是 <span
class="math inline">\(n!\)</span>。</p>
<p>设 <span class="math inline">\(f(n,m,k)\)</span> 为的 <span
class="math inline">\(n\times m\)</span> 的矩形中选 <span
class="math inline">\(k\)</span> 个的方案：</p>
<p><span class="math inline">\(f(n,m,k)=\binom{n}{k}\binom{m}{k}\times
k!\)</span>。</p>
<p>在 <span class="math inline">\(n\)</span> 行 <span
class="math inline">\(m\)</span> 列中选 <span
class="math inline">\(k\)</span> 行<span
class="math inline">\(k\)</span> 列，然后放 <span
class="math inline">\(k\)</span> 个。</p>
<p>发现题目中这个图形有性质：如果划分为两个矩形，那么有一维将不再相互影响。</p>
<p>可以划分为上 <span class="math inline">\(a\times b\)</span> 和下
<span class="math inline">\((a+c)\times d\)</span>。</p>
<p>枚举在上面放了 <span class="math inline">\(k\)</span> 个中的 <span
class="math inline">\(i\)</span> 个。</p>
<p>答案为 <span class="math inline">\(\sum\limits_{i=0}^kf(a,b,i)\times
f(a+c-i,d,k-i)\)</span>。</p>
<p>有 <code>DP</code> 写法。设 <span
class="math inline">\(f[i][j]\)</span> 为 前 <span
class="math inline">\(i\)</span> 列放 <span
class="math inline">\(j\)</span> 个，<span
class="math inline">\(h[i]\)</span> 为第 <span
class="math inline">\(i\)</span> 列的高度。</p>
<p><span class="math inline">\(f[i][j]=f[i-1][j]+f[i-1][j-1]\times
(h[i]-j+1)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e3</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e5</span>+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a,b,c,d,k;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=inv[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[m]%Mod*inv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n||k&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n,k)*<span class="built_in">C</span>(m,k)%Mod*fac[k]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e3</span>);</span><br><span class="line">    <span class="built_in">read</span>(a,b,c,d,k);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">calc</span>(a,b,i)*<span class="built_in">calc</span>(a+c-i,d,k-i)%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P1527</title>
    <url>/2023/12/06/P1527/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1527">P1527 [国家集训队]
矩阵乘法</a></p>
<span id="more"></span>
<p>求第 <span class="math inline">\(k\)</span> 小，当然是二分。</p>
<p>子矩阵的查询，不太能在数据结构上二分，思考暴力二分如何优化。</p>
<p>正常的暴力二分，对每个询问，二分答案 <span
class="math inline">\(mid\)</span>，如果 <span
class="math inline">\((x_1,y_1),(x_2,y_2)\)</span> 矩形内 <span
class="math inline">\(\ge mid\)</span> 的数的个数大于 <span
class="math inline">\(k\)</span>，说明 <span
class="math inline">\(mid\)</span> 大了，不然就小了，总复杂度为 <span
class="math inline">\(O(q\times n^2\log V)\)</span>，无法通过。</p>
<p>对于很多询问，对每个询问都做一次二分，显然是存在浪费的。</p>
<p>可以利用整体二分的技巧。</p>
<p>具体的，对所有询问离线，对矩形内 <span class="math inline">\(n\times
n\)</span> 个元素排序，用 <span
class="math inline">\(F(l,r,ql,qr)\)</span> 处理 当前二分区间为 <span
class="math inline">\([l,r]\)</span>，有 <span
class="math inline">\([ql,qr]\)</span>
这个区间内的询问，到达了这个二分区间（<span class="math inline">\(l\le
r\le n\times n,ql\le qr \le q\)</span>）。</p>
<p>排序的原因：可以直接二分“第几个位置”，而不是二分具体的值——因为值域比较大。</p>
<p>首先将权值在 <span class="math inline">\([l,mid]\)</span>
范围内的位置上加一（用二维树状数组维护），可以快速查询子矩阵中权值在
<span class="math inline">\([l,mid]\)</span> 内的个数，对 <span
class="math inline">\([ql,qr]\)</span> 内每个询问都查询一次个数 <span
class="math inline">\(s\)</span>，如果 <span class="math inline">\(s\ge
k\)</span>，就放在左边，否则就放在右边，且 <span
class="math inline">\(k\leftarrow k-s\)</span>（因为我们查询的不是 <span
class="math inline">\([1,mid]\)</span>
内的个数，要类比权值线段树求<code>kth</code>），然后将 <span
class="math inline">\([ql,qr]\)</span> 内的询问按照刚才的左右排好。</p>
<p>设左边放了 <span class="math inline">\(L\)</span> 个，右边放了 <span
class="math inline">\(R\)</span> 个，那么 <span
class="math inline">\(F(l,r,ql,qr)\)</span> 可以递归到 <span
class="math inline">\(F(l,mid,ql,ql+L-1),F(mid+1,r,qr-R+1,qr)\)</span>，当
<span class="math inline">\(l=r\)</span> 时，说明 <span
class="math inline">\([ql,qr]\)</span> 中的询问的答案都是第 <span
class="math inline">\(l\)</span> 个位置的权值，记录答案即可。</p>
<p>关于复杂度：递归结构和线段树相同。每次调用 <span
class="math inline">\(F(l,r,ql,qr)\)</span> 会对树状数组做 <span
class="math inline">\(r-l+1\)</span> 次修改，<span
class="math inline">\(ql-qr+1\)</span> 次查询，线性遍历部分忽略。</p>
<ul>
<li>对于前者，就是“线段树”上所有节点代表的长度之和乘以单次修改的复杂度，长度之和为
<span class="math inline">\(n^2\log {n^2}=O(n^2\log
n)\)</span>，复杂度为 <span class="math inline">\(O(n^2\log n\times
\log^2n)\)</span>。</li>
<li>对于后者，递归树上的每一层都会完全覆盖 <span
class="math inline">\(q\)</span> 个询问，一共有 <span
class="math inline">\(\log{n^2}=O(\log n)\)</span> 层，这部分的复杂度为
<span class="math inline">\(O(q\log n\times \log^2 n)\)</span>。</li>
</ul>
<p>总复杂度为 <span class="math inline">\(O((n^2+q)\log^3
n)\)</span>，跑满差不多 <span class="math inline">\(2\times
10^8\)</span>，开<code>O2</code>最大点<code>250ms</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">505</span>)</span>,<span class="title">qN</span><span class="params">(<span class="number">6e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,qn;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Num</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Num&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;m[N*N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qny</span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2,k;</span><br><span class="line">&#125;q[qN];</span><br><span class="line"><span class="type">int</span> id[qN],ans[qN],t1[qN],t2[qN];</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="type">int</span> c[N][N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=y;j&lt;=n;j+=<span class="built_in">lowbit</span>(j))&#123;</span><br><span class="line">                c[i][j]+=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i&gt;<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=y;j&gt;<span class="number">0</span>;j-=<span class="built_in">lowbit</span>(j))&#123;</span><br><span class="line">                res+=c[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ask</span>(x2,y2)-<span class="built_in">ask</span>(x1<span class="number">-1</span>,y2)-<span class="built_in">ask</span>(x2,y1<span class="number">-1</span>)+<span class="built_in">ask</span>(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&gt;qr)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,ql,qr)ans[id[i]]=m[l].v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,l,mid)&#123;</span><br><span class="line">        BIT::<span class="built_in">add</span>(m[i].x,m[i].y,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>,u=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,ql,qr)&#123;</span><br><span class="line">        u=id[i],s=BIT::<span class="built_in">query</span>(q[u].x1,q[u].y1,q[u].x2,q[u].y2);</span><br><span class="line">        <span class="keyword">if</span>(s&gt;=q[u].k)t1[++cnt1]=u;</span><br><span class="line">        <span class="keyword">else</span> t2[++cnt2]=u,q[u].k-=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> qcnt=ql<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt1)id[++qcnt]=t1[i];</span><br><span class="line">    <span class="built_in">re</span>(i,cnt2)id[++qcnt]=t2[i];</span><br><span class="line">    <span class="built_in">rep</span>(i,l,mid)&#123;</span><br><span class="line">        BIT::<span class="built_in">add</span>(m[i].x,m[i].y,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(l,mid,ql,ql+cnt1<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(mid+<span class="number">1</span>,r,qr-cnt2+<span class="number">1</span>,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,qn);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            m[(i<span class="number">-1</span>)*n+j]=&#123;i,j,x&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(m+<span class="number">1</span>,m+n*n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,qn)&#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].x1,q[i].y1,q[i].x2,q[i].y2,q[i].k);</span><br><span class="line">        id[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n*n,<span class="number">1</span>,qn);</span><br><span class="line">    <span class="built_in">re</span>(i,qn)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1393</title>
    <url>/2024/01/10/P1393/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1393">P1393 Mivik
的标题</a></p>
<span id="more"></span>
<p>这东西和概率没有深刻联系，先不管，直接计数。</p>
<p>记 标题 为大串，名字 <span class="math inline">\(S\)</span>
为小串。<span class="math inline">\(L=|S|\)</span>。</p>
<p>设 <span class="math inline">\(f_i\)</span> 为：大串长为 <span
class="math inline">\(i\)</span>，小串出现在末尾且只出现一次的方案数。</p>
<p>答案为： <span class="math display">\[
\sum_{i=L}^{n}f_i\times m^{n-i}
\]</span> 后面剩下 <span class="math inline">\(n-i\)</span>
个随便放。由定义可得，计数不重不漏。</p>
<p><span class="math inline">\(f\)</span> 比较难求，考虑算一些和 <span
class="math inline">\(f\)</span> 在某些方面对称的东西。</p>
<p>设 <span class="math inline">\(g_i\)</span> 为：若大串长度为 <span
class="math inline">\(i\)</span>，不含小串的方案数。</p>
<p>容易发现有： <span class="math display">\[
g_i=m\times g_{i-1}-f_i
\]</span> 从 <span class="math inline">\(i-1\)</span> 到 <span
class="math inline">\(i\)</span>，增加一个字符，有可能会使末尾出现完整小串，所以去掉末尾是完整小串的方案。</p>
<p>设 <span class="math inline">\(f,g\)</span> 的普通生成函数为 <span
class="math inline">\(F,G\)</span>。</p>
<p>有： <span class="math display">\[
G(x)=mxG(x)+1-F(x)
\]</span> 别忘了补常数项。</p>
<p>接下来这一步不是非常显然。</p>
<p>定义一个关于小串的序列： <span class="math display">\[
c_i=[i\textrm{ is a period of S}]
\]</span> <span class="math inline">\(c_i=1\)</span> 代表小串有长为
<span class="math inline">\(i\)</span> 的周期，或者说小串有长为 <span
class="math inline">\(L-i\)</span> 的 <span
class="math inline">\(\textrm{border}\)</span>。</p>
<p>这被称作字符串的自相关向量，链接：<a
href="https://en.wikipedia.org/wiki/Autocorrelation_(words)">Autocorrelation
(words) - Wikipedia</a>，此题算是字符串自相关多项式的应用。</p>
<p>有式子： <span class="math display">\[
g_{i-L}=\sum_{j=0}^{i}f_{i-j}c_{j}
\]</span> 唐突卷积。</p>
<p>这样理解：如果 <span class="math inline">\(c_j\)</span> 为 <span
class="math inline">\(1\)</span>，也就是存在 <span
class="math inline">\(\textrm{border } L-j\)</span>， 就可以在 <span
class="math inline">\(f_{i-j}\)</span> 后面放 <span
class="math inline">\(S[L-j+1,L]\)</span>，这样在末尾就会出现新的 <span
class="math inline">\(S\)</span>，且它和 <span
class="math inline">\(f_j\)</span> 末尾的 <span
class="math inline">\(S\)</span> 有交；而 <span
class="math inline">\(g_{i-L}\)</span> 中减去 <span
class="math inline">\(L\)</span> 就相当于扣去了整个新的 <span
class="math inline">\(S\)</span>。因为 <span
class="math inline">\(f_{i-j}\)</span> 包含了前缀 <span
class="math inline">\([1,i-j]\)</span>
的情况，容易发现计数不重不漏。</p>
<p>举个例子，设小串为 <code>aba</code>，存在周期
<code>ab</code>；对于大串 <code>aaaba</code> 来说，如果在末尾添加
<code>ba</code>（这是 <span
class="math inline">\(\textrm{border}\)</span> 的补集），就会形成
<code>aaababa</code>，扣掉末尾的 <span class="math inline">\(S\)</span>
得到 <code>aaab</code>。</p>
<p>相当于，很难数末尾一定没有 <span
class="math inline">\(S\)</span>，就让末尾一定出现 <span
class="math inline">\(S\)</span> 且前面没有完整的 <span
class="math inline">\(S\)</span>，再扣掉末尾 <span
class="math inline">\(S\)</span> 即可。</p>
<p>设 <span class="math inline">\(c\)</span> 的普通生成函数为 <span
class="math inline">\(C\)</span>。</p>
<p>根据上面的卷积形式，容易得到： <span class="math display">\[
G(x)x^L=F(x)C(x)
\]</span> 和第一个式子联立： <span class="math display">\[
F(x)=\frac{x^L}{C(x)-mxC(x)+x^L}
\]</span> 对分母多项式求逆，对于分子，求答案的时候位移 <span
class="math inline">\(L\)</span> 位就行。</p>
<p>最后别忘了乘上 <span class="math inline">\(\dfrac{1}{m^n}\)</span>
算概率。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">qpow</span>(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    T = T * T % mod;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> T * a % mod;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> PL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> G = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> lim, k, r[N], iG;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">            <span class="keyword">if</span> (r[i] &gt; i)</span><br><span class="line">                <span class="built_in">swap</span>(a[i], a[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> wn = <span class="built_in">qpow</span>(tp == <span class="number">1</span> ? G : iG, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> W = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; mid; k++, W = W * wn % mod)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x = a[j + k], y = a[j + k + mid] * W % mod;</span><br><span class="line">                    a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> I = <span class="built_in">qpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (tp == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">                a[i] = a[i] * I % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsy</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lim = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lim &lt; (x &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            lim &lt;&lt;= <span class="number">1</span>, k++;</span><br><span class="line">        <span class="built_in">re</span>(i, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="built_in">qpow</span>(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Inv</span>(a, b, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">qsy</span>(len);</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            c[i] = a[i];</span><br><span class="line">        <span class="built_in">ntt</span>(c, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">ntt</span>(b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">            b[i] = (<span class="number">2</span> - b[i] * c[i] % mod + mod) % mod * b[i] % mod;</span><br><span class="line">        <span class="built_in">ntt</span>(b, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len; i &lt; lim; i++)</span><br><span class="line">            b[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, L, nxt[N], C[N], T[N], F[N], s[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    PL::iG = <span class="built_in">qpow</span>(PL::G, mod - <span class="number">2</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;</span><br><span class="line">    <span class="built_in">re</span>(i, L)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i])</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i])</span><br><span class="line">            ++j;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = L;</span><br><span class="line">    <span class="keyword">while</span> (now)</span><br><span class="line">    &#123;</span><br><span class="line">        C[L - now] = <span class="number">1</span>;</span><br><span class="line">        now = nxt[now];</span><br><span class="line">    &#125;</span><br><span class="line">    T[<span class="number">0</span>] = C[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">re</span>(i, L)</span><br><span class="line">    &#123;</span><br><span class="line">        T[i] = (C[i] - m * C[i - <span class="number">1</span>] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    (T[L] += <span class="number">1</span>) %= mod;</span><br><span class="line">    PL::<span class="built_in">Inv</span>(T, F, n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - L)</span><br><span class="line">    &#123;</span><br><span class="line">        (ans += <span class="built_in">qpow</span>(m, n - (L + i)) * F[i] % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * <span class="built_in">qpow</span>(<span class="built_in">qpow</span>(m, n), mod - <span class="number">2</span>) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>概率与期望</tag>
        <tag>KMP</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1654</title>
    <url>/2024/01/05/P1654/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1654">P1654 OSU!</a></p>
<span id="more"></span>
<p>简单题。</p>
<p>对于随机过程的题，注意DP数组的定义，转移不一定要通过加状态或枚举进行，可以直接在定义处“解决”。</p>
<p>不需要枚举末尾放了多少<code>O</code>，然后 <span
class="math inline">\(F(i-j)\to
F(i)\)</span>，可以直接求出期望末尾<code>O</code>长度，简洁计算，对于这种
<span class="math inline">\(P\)</span> 概率 <span
class="math inline">\(+a\)</span>，<span
class="math inline">\((1-P)\)</span> 概率赋值为 <span
class="math inline">\(b\)</span>
的事件，两种东西本质上是一样的，求期望长度可以统一转移过程。</p>
<p>设 <span class="math inline">\(F(i)\)</span> 为前缀 <span
class="math inline">\(i\)</span> 的答案，有： <span
class="math display">\[
F(i)=F(i-1)+P_i(\Delta E(X^3))
\]</span> 推导。 <span class="math display">\[
\begin{aligned}
&amp;E((X+1)^3-X^3)=E(3X^2+3X+1)\\
&amp;E((X+1)^3-X^3)=3E(X^2))+3E(X)+1\\\\
&amp;E(X^2)=P_i(E((X+1)^2-X^2))\\
&amp;E(X^2)=P_i(E(2X+1))\\
&amp;E(X^2)=P_i(2E(X)+1)\\\\
&amp;E(X)=P_i(E(X-1)+1)
\end{aligned}
\]</span> 直接递推，做完了。具体见代码。</p>
<p>一些值得一提的地方。</p>
<ul>
<li><p>在推导中使用 <span class="math inline">\(E(X)\)</span>
其实不严谨。求的是每个前缀的 <span
class="math inline">\(E(X)\)</span>，设为 <span
class="math inline">\(g\)</span>。<span
class="math inline">\(E(X),E(X+1)\)</span> 的关系和 <span
class="math inline">\(g[i-1],g[i]\)</span> 的关系不一样。不过所有用到
<span class="math inline">\(E\)</span> 的地方前面都乘了 <span
class="math inline">\(P_i\)</span>，当前是 <code>o</code> 的话，<span
class="math inline">\(E(X+1),E(X)\)</span> 确实可以代表 <span
class="math inline">\(g[i],g[i-1]\)</span>，所以这么用是有一点取巧的。</p></li>
<li><p>如果使用的形式不是 <span
class="math inline">\((X+1)^3-X^3\)</span>，而是 <span
class="math inline">\(X^3-(X-1)^3\)</span>，很不巧，会更容易出现错误。最终会推出一些：<span
class="math inline">\(E(X^2)=E((X-1)^2)+2E(X)-1\)</span>
的式子，而这里需要统一右侧形式，<span
class="math inline">\(E(X)\)</span> 变为 <span
class="math inline">\(2E(X-1)+2-1\)</span>，用 <span
class="math inline">\(2E(X-1)+1\)</span>，不然是错的。可以理解为等式两边不能都和当前过程的随机事件相关？</p></li>
</ul>
<p>还是尽量减少负号吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> p[N],f[N],g[N],h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        g[i]=p[i]*(g[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        h[i]=p[i]*(h[i<span class="number">-1</span>]+<span class="number">2</span>*g[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+p[i]*(<span class="number">3</span>*h[i<span class="number">-1</span>]+<span class="number">3</span>*g[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>)&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>P2034</title>
    <url>/2023/12/01/P2034/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2034">P2034
选择数字</a></p>
<span id="more"></span>
<p>肯定是DP没跑了。</p>
<p>暴力 <span class="math inline">\(O(n^2)\)</span>
的DP多种多样，显然需要一些优化。</p>
<p>这种连续 <span class="math inline">\(k\)</span>
个的限制很像单调队列。</p>
<p>这种看起来像是需要单调队列优化的题，要把状态的转移向
“对前面一段枚举，找<span
class="math inline">\(\max\)</span>”的形式去靠近。</p>
<p>设 <span class="math inline">\(f[i][0/1]\)</span> 为前个数，第 <span
class="math inline">\(i\)</span> 个没选或者选了的最优答案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][0]=\max(f[i-1][0],f[i-1][1])\\
&amp;f[i][1]=\max_{j=i-k}^{i-1}f[j][0]+\sum_{t=j+1}^i a[t]
\end{aligned}
\]</span></p>
<p><span class="math inline">\(f[i][0]\)</span> 可以直接转移。</p>
<p>将 <span class="math inline">\(f[i][1]\)</span>
的转移改成的前缀和数组的差分形式：</p>
<p><span class="math display">\[
\begin{aligned}
f[i][1]&amp;=\max_{j=i-k}^{i-1}f[j][0]+s[i]-s[j]\\
&amp;=s[i]+\max_{j=i-k}^{i-1}f[j][0]-s[j]
\end{aligned}
\]</span></p>
<p>对后面的 <span class="math inline">\(\max\)</span>
用单调队列优化。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>单调队列最好先<code>push_back</code>一个 <span
class="math inline">\(0\)</span> 进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">struct</span> <span class="title class_">Deque</span>&#123;</span><br><span class="line">    T q[N];</span><br><span class="line">    <span class="type">int</span> frt,bak;</span><br><span class="line">    <span class="built_in">Deque</span>()&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;q[<span class="number">1</span>]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[frt];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[bak];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bak-frt+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;frt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;bak--;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;q[++bak]=x;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (bak-frt+<span class="number">1</span>)&gt;<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,k,a[N];</span><br><span class="line">ll f[N][<span class="number">2</span>],sum[N];</span><br><span class="line">Deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;i-k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        f[i][<span class="number">1</span>]=sum[i]+f[q.<span class="built_in">front</span>()][<span class="number">0</span>]-sum[q.<span class="built_in">front</span>()];</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;f[q.<span class="built_in">back</span>()][<span class="number">0</span>]-sum[q.<span class="built_in">back</span>()]&lt;f[i][<span class="number">0</span>]-sum[i])&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2292</title>
    <url>/2023/12/14/P2292/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2292">P2292 [HNOI2004] L
语言</a></p>
<span id="more"></span>
<p>首先有一个较为显然的DP想法。</p>
<p>设 <span class="math inline">\(f[i]\)</span>：前缀 <span
class="math inline">\(i\)</span> 能否理解，如果存在 <span
class="math inline">\(f[j]=1\)</span> 且 <span
class="math inline">\(t[j+1,i]\in D\)</span>，那么 <span
class="math inline">\(f[i]=1\)</span>，否则 <span
class="math inline">\(f[i]=0\)</span>。</p>
<p>暴力做，复杂度 <span class="math inline">\(O(nm|s||t|)\)</span>。</p>
<p>考虑优化，对 <span class="math inline">\(D\)</span> 建AC自动机。</p>
<p>将 <span class="math inline">\(t\)</span>
放到AC自动机上匹配，不要忘记将AC自动机上叶子的每个儿子都指回根，可以自动循环匹配。</p>
<p>对于自动机上点 <span class="math inline">\(p\)</span>，我们需要知道
<span class="math inline">\(t[1,p]\)</span>
中哪些后缀是模式串，而且我们只需要知道后缀的长度。</p>
<p>直接枚举可能的后缀，复杂度 <span
class="math inline">\(O(m|s||t|)\)</span>，不够快。</p>
<p>发现 <span class="math inline">\(|s|\le 20\)</span>，状压。</p>
<p>设 <span class="math inline">\(can[p]\)</span>，如果 <span
class="math inline">\(can[p]\)</span> 第 <span
class="math inline">\(i\)</span> 位为 <span
class="math inline">\(1\)</span>，代表 <span
class="math inline">\(t[p-i+1,p]\)</span> 等于某个模式串。</p>
<p>怎么求 <span class="math inline">\(can[p]\)</span> 呢？</p>
<p>预处理一下每个模式串的深度，枚举节点，跳 <span
class="math inline">\(fail\)</span>，点 <span
class="math inline">\(p\)</span> 的每个 <span
class="math inline">\(fail\)</span>
祖先代表的是<strong>所有</strong>作为某个模式串<strong>前缀</strong>出现的
<span class="math inline">\(p\)</span>
串<strong>后缀</strong>，我们需要作为<strong>整个</strong>模式串出现的
<span class="math inline">\(p\)</span>
串<strong>后缀</strong>，判断是不是结束位置即可。</p>
<p>查询计算合法状态时，只需要关注前 <span
class="math inline">\(20\)</span>
位信息，用<code>unsigned</code>自然溢出比较简便。</p>
<p>时间复杂度 <span class="math inline">\(O(n|s|^2+m|t|)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">25</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">55</span>)</span>,<span class="title">L</span><span class="params">(<span class="number">2e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,ncnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> s[N],t[L];</span><br><span class="line"><span class="type">int</span> ch[N*N][<span class="number">26</span>],ed[N*N],dep[N*N],fail[N*N];</span><br><span class="line"><span class="type">unsigned</span> can[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,len)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][c])ch[p][c]=++ncnt;</span><br><span class="line">        p=ch[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>,dep[p]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)ch[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">            <span class="type">int</span> &amp;v=ch[u][i];</span><br><span class="line">            <span class="keyword">if</span>(v)&#123;</span><br><span class="line">                fail[v]=ch[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> v=ch[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,ncnt)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=i;u;u=fail[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ed[u])&#123;</span><br><span class="line">                can[i]|=(<span class="number">1</span>&lt;&lt;dep[u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),p=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> sta=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,len)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=ch[p][c];</span><br><span class="line">        sta&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sta&amp;can[p])&#123;</span><br><span class="line">            sta|=<span class="number">1</span>;</span><br><span class="line">            res=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;(t+<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">work</span>(t)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P2414</title>
    <url>/2023/12/14/P2414/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2414">P2414 [NOI2011]
阿狸的打字机</a></p>
<span id="more"></span>
<p>将打字机放在Trie上，发现每次操作只会让当前节点移动一次，也就是说Trie的总规模是
<span class="math inline">\(O(m)\)</span> 的。</p>
<p>对这个Trie跑AC自动机。</p>
<p>考虑，询问Trie中两个根到点的字符串 <span
class="math inline">\(x,y\)</span>，求 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(y\)</span> 中的出现次数，怎么做。</p>
<p>fail树可以解决这个问题。</p>
<p>在fail树中找 <span class="math inline">\(y\)</span> 对应的点 <span
class="math inline">\(u\)</span>，枚举fail树上根到 <span
class="math inline">\(u\)</span> 的点 <span
class="math inline">\(v\)</span>，对每个 <span
class="math inline">\(v\)</span> 一直跳 <span
class="math inline">\(fail\)</span>，如果跳到 <span
class="math inline">\(x\)</span>，答案加一，进一步转为：将 <span
class="math inline">\(u\)</span> 到根点权设为 <span
class="math inline">\(1\)</span>，其他为 <span
class="math inline">\(0\)</span>，求 <span
class="math inline">\(x\)</span> 对应点内fail树上子树和。</p>
<!-- 可以理解成：$u$ 的全部 $fail$ 祖先，是 $u$ **可能有贡献**的后缀，而这些后缀是指向其他模式串的前缀的，那么 $u$ 的后缀（1）的后缀（显然也在 $fail$ 祖先中），就是其他模式串前缀（2）的后缀，也就是子串，而（1）,（2）两串是相等的，那么这个前缀的后缀也是串 $u$ 的子串，总而言之，$fail$ 祖先是子串，而找 $x$ 在子串中的出现次数，就看 $x$ 子树内（$x$ 子树内就是包含 $x$ 的串）有多少个是 $y$ 的子串。  错了。-->
<p>因为每次有 <span class="math inline">\(1\)</span> 的部分只会
变长一个/缩短一个，所以可以对询问离线，按 <span
class="math inline">\(y\)</span>
从小到大的顺序处理询问，用树状数组维护，每次查询 <span
class="math inline">\(x\)</span> 的子树和即可。</p>
<p>时间复杂度 <span class="math inline">\(O(L\log m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> n, m, stc[N], top, node, ed[N], son[N][S];</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> dn, fa[N], dfn[N], sz[N], ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pii&gt; buc[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= dn)</span><br><span class="line">        c[x] += v, x += x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">        s += c[x], x -= x &amp; -x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    sz[id] = <span class="number">1</span>, dfn[id] = ++dn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it : e[id])</span><br><span class="line">        <span class="built_in">dfs</span>(it), sz[id] += sz[it];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">            ed[++n] = p;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            p = stc[--top];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!son[p][s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            son[p][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++node;</span><br><span class="line"></span><br><span class="line">        stc[++top] = p = son[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y, buc[y].<span class="built_in">pb</span>(&#123;x, i&#125;);</span><br><span class="line"></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="keyword">if</span> (son[<span class="number">0</span>][i])</span><br><span class="line">            q.<span class="built_in">push</span>(son[<span class="number">0</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(), e[fa[t]].<span class="built_in">pb</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">            son[t][i] ? (q.<span class="built_in">push</span>(son[t][i]), fa[son[t][i]] = son[fa[t]][i]) : son[t][i] = son[fa[t]][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>), top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>, n = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> (pii it : buc[++n]) &#123;</span><br><span class="line">                <span class="type">int</span> q = ed[it.fi];</span><br><span class="line">                ans[it.se] = <span class="built_in">query</span>(dfn[q] + sz[q] - <span class="number">1</span>) - <span class="built_in">query</span>(dfn[q] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            <span class="built_in">add</span>(dfn[p], <span class="number">-1</span>), p = stc[--top];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stc[++top] = p = son[p][s[i] - <span class="string">&#x27;a&#x27;</span>], <span class="built_in">add</span>(dfn[p], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>树状数组</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P2467</title>
    <url>/2023/12/02/P2467/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2467">P2467 [SDOI2010]
地精部落</a></p>
<span id="more"></span>
<p>实际上是让我们数阶的交替排列数</p>
<p>OEIS: <a href="https://oeis.org/A001250">A001250 - OEIS</a></p>
<p>设计 <code>DP</code>。</p>
<p>首先，发现阶山峰山谷状态只和第一个波谷的状态有关。</p>
<p>记 <span class="math inline">\(f[i][0/1]\)</span>：长度为 <span
class="math inline">\(i\)</span> 的排列，第一个是山峰/山谷的方案数。</p>
<p>先不管接口处的山峰山谷方案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">        f[i]+=f[j]*f[i<span class="number">-1</span>-j]*C[i<span class="number">-1</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(i\)</span> 是长度，<span
class="math inline">\(j\)</span> 是枚举到的当前最大值位置，前面放长为
<span class="math inline">\(j\)</span>，后面长为 <span
class="math inline">\(i-1-j\)</span> ，加上最大值，拼成长度 <span
class="math inline">\(i\)</span> 。（组合数是选 <span
class="math inline">\(j\)</span>
个放前面，当然后面不用乘组合数，已经被确定了）</p>
<p>当然 这样并没有考虑两段和最大值之间接口处的问题，可能出现不合法。</p>
<p>而 <span class="math inline">\(f[i][0/1]\)</span>
的状态显然可以推出最后一位的状态，所以我们可以直接通过 <span
class="math inline">\(f[i][0/1]\)</span> 做转移。</p>
<p>当最大的数放在偶数位后时，因为最大的数前的一定是山谷，所以是“峰-谷-峰-谷-最大值”，所以前面的山脉的开头就一定是山峰，后面的山脉开头一定要是山谷（如果原来就是山峰，是非法的），所以就可以得到一个正确的转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)f[i][<span class="number">1</span>]+=f[j][<span class="number">1</span>]*f[i<span class="number">-1</span>-j][<span class="number">0</span>]*C[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>
<p>当最大的数放在奇数位后时，同理，是"谷-峰-谷-最大值"，前面的开头是山谷，后面的开头是山谷。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(j%<span class="number">2</span>)f[i][<span class="number">0</span>]+=f[j][<span class="number">0</span>]*f[i<span class="number">-1</span>-j][<span class="number">0</span>]*C[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>
<p>考虑到波峰和波谷有天然的对称性，所以其实可以只求一个的值，最后乘二。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>组合数开<code>long long</code>会爆空间，内存如果再紧一些需要滚动数组求组合数（同一层外层循环都是
<span class="math inline">\(C[i-1][x]\)</span>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4205</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,i)&#123;</span><br><span class="line">            C[i][j]=(<span class="number">1ll</span>*C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">2</span>)&#123;</span><br><span class="line">                f[i]+=C[i<span class="number">-1</span>][j]*f[j]%p*f[i-j<span class="number">-1</span>]%p;</span><br><span class="line">                f[i]%=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n]*<span class="number">2</span>%p,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2839</title>
    <url>/2023/12/02/P2839/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2839">P2839 [国家集训队]
middle</a></p>
<span id="more"></span>
<p>中位数相关。</p>
<p>设有一数列 <span class="math inline">\(a\)</span>，如果将 <span
class="math inline">\(a\)</span> 大于等于 <span
class="math inline">\(x\)</span> 的数改为 <span
class="math inline">\(1\)</span>，否则改为 <span
class="math inline">\(-1\)</span>，那么 <span class="math inline">\(\sum
a\ge 0\)</span> 和 中位数 <span class="math inline">\(\ge x\)</span>
是互为充要条件的。</p>
<p>显然具有单调性，对中位数二分。</p>
<p>对于某个 <span class="math inline">\(x\)</span>
来说，我们取出来的数当然 <span class="math inline">\(1\)</span>
越多越好。</p>
<p>现在的问题是找一个符合题意的区间，区间内 <span
class="math inline">\(1\)</span>，<span
class="math inline">\(-1\)</span> 之和最大。</p>
<p>对值域建主席树，第 <span class="math inline">\(i\)</span>
棵树需要考虑的信息为：第 <span class="math inline">\(i-1\)</span> 棵和
<span class="math inline">\(a\)</span> 中第 <span
class="math inline">\(i\)</span>
小的数，每次只会更改一位，保证了复杂度。</p>
<p>主席树中第 <span class="math inline">\(x\)</span>
棵线段树维护：当前二分到 <span
class="math inline">\(x\)</span>，数组改为 <span
class="math inline">\(1\)</span> 或 <span
class="math inline">\(-1\)</span>
形式下，下标上每个区间的前缀和后缀和最大值 和 区间和。</p>
<p>因为在 <span class="math inline">\([a,b]\)</span> 和 <span
class="math inline">\([c,d]\)</span>
段要取后缀与前缀，中间的部分必须被取到，是区间 <span
class="math inline">\([b,c]\)</span>（如果两区间不交）。</p>
<p>值域过大，将 <span class="math inline">\(a[i]\)</span> 重定义为：第
<span class="math inline">\(i\)</span> 小的数在 <span
class="math inline">\(a\)</span> 中位置 即可。</p>
<p>注意不能直接离散化，重复的数要当做不同来处理。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],q,id[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dat</span>&#123;</span><br><span class="line">    <span class="type">int</span> pre,suf,sum;</span><br><span class="line">    <span class="built_in">Dat</span>()&#123;pre=suf=-inf,sum=<span class="number">0</span>;&#125;</span><br><span class="line">    Dat <span class="keyword">operator</span>+(<span class="type">const</span> Dat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        Dat c;</span><br><span class="line">        c.pre=<span class="built_in">max</span>(pre,sum+b.pre);</span><br><span class="line">        c.suf=<span class="built_in">max</span>(b.suf,suf+b.sum);</span><br><span class="line">        c.sum=sum+b.sum;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    Dat v;</span><br><span class="line">&#125;t[N*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> ncnt,rot[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    rt=++ncnt;</span><br><span class="line">    t[rt].v.pre=t[rt].v.suf=t[rt].v.sum=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    rt=++ncnt;</span><br><span class="line">    t[rt]=t[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt].v.sum=t[rt].v.pre=t[rt].v.suf=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),<span class="built_in">ls</span>(old),l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),<span class="built_in">rs</span>(old),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    t[rt].v=t[<span class="built_in">ls</span>(rt)].v+t[<span class="built_in">rs</span>(rt)].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dat <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[rt].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr)+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> qr[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr[<span class="number">1</span>]+<span class="number">1</span>&lt;=qr[<span class="number">2</span>]<span class="number">-1</span>)&#123;</span><br><span class="line">        res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">1</span>]+<span class="number">1</span>,qr[<span class="number">2</span>]<span class="number">-1</span>).sum;</span><br><span class="line">    &#125;</span><br><span class="line">    res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">0</span>],qr[<span class="number">1</span>]).suf;</span><br><span class="line">    res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">2</span>],qr[<span class="number">3</span>]).pre;</span><br><span class="line">    <span class="keyword">return</span> res&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        id[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[x]&lt;a[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">build</span>(rot[<span class="number">1</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(rot[i],rot[i<span class="number">-1</span>],<span class="number">1</span>,n,id[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(qr[i]);</span><br><span class="line">            qr[i]=(qr[i]+ans)%n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(qr,qr+<span class="number">4</span>);</span><br><span class="line">        l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                ans=a[id[mid]];</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P3175</title>
    <url>/2023/12/02/P3175/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3175">P3175 [HAOI2015]
按位或</a></p>
<span id="more"></span>
<p>题目涉及“第一次到达某个状态”，可以尝试<code>min-max</code>容斥。</p>
<p>首先对题目做转化：把所有二进制码看做集合。</p>
<p>有一个较为经典的想法：在组成集合 <span
class="math inline">\(S\)</span> 的过程中，第一个被放入 <span
class="math inline">\(S\)</span> 的元素的选中时间为 <span
class="math inline">\(min(S)\)</span>，最后一个被放入的元素的选中时间为
<span
class="math inline">\(max(S)\)</span>（这里不是实际最值，是时间戳的最值，这样写只是好看）</p>
<p>这里 <span class="math inline">\(max\)</span>
就是第一次到达某状态时间。</p>
<p>有<code>min-max</code>容斥的式子：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T)\\
&amp;E(max(S))=\sum_{T\subseteq S}(-1)^{|T|+1}E(min(T))
\end{aligned}
\]</span></p>
<p>当然，期望意义也成立，这是min-max容斥很好的性质。</p>
<p>显然，答案为 <span class="math inline">\(E(max(U))\)</span></p>
<p>现在考虑如何去求 <span class="math inline">\(E(min(S))\)</span>。</p>
<p>发现 <span class="math inline">\(E(min(S))\)</span> 就是和 <span
class="math inline">\(S\)</span> 有交的集合第一次被选中的期望时间。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;E(min(S))=\frac{1}{\sum_{T\cap S\ne \varnothing}p[T]}
\end{aligned}
\]</span></p>
<p>期望是概率的倒数。</p>
<p>但我们比较难去对于 <span class="math inline">\(2^n\)</span>
种集合的每一种去求一遍有交集合的概率和。</p>
<p>正难则反，考虑去求他没有交集的概率和，用 <span
class="math inline">\(1\)</span> 减去它就是上面的答案了（原因显然）</p>
<p>问题也就转化成：补集的每一个子集的概率和。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;E(min(S))=\frac{1}{1-\sum_{T\subseteq\complement_US}p[T]}
\end{aligned}
\]</span></p>
<p>后面那个和式的形式非常经典，可以做一遍FWT的或卷积，或者用高维前缀和（子集和DP）。</p>
<p>求出 <span class="math inline">\(E(min(S))\)</span>
后再套进最上面的容斥式子，就是答案。</p>
<p>时间复杂度 <span
class="math inline">\(O(n2^n)\)</span>，可以通过。</p>
<p>代码里两种做子集和的方式都写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">orFWT</span><span class="params">(<span class="type">double</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,r=i&lt;&lt;<span class="number">1</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j+=r)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">                A[i+j+k]+=A[j+k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SoSDP</span><span class="params">(<span class="type">double</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                A[j]+=A[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// orFWT(f);</span></span><br><span class="line">    <span class="built_in">SoSDP</span>(f);</span><br><span class="line">    <span class="type">int</span> cs=<span class="number">0</span>,op=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cs=((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^s;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>-f[cs]&lt;eps)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;INF\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        op=(__builtin_popcount(s)&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        ans+=<span class="number">1</span>/(<span class="number">1</span>-f[cs])*op;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>概率与期望</tag>
        <tag>子集和DP</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P3193</title>
    <url>/2024/01/09/P3193/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3193">P3193 [HNOI2008]
GT考试</a></p>
<span id="more"></span>
<p>看到 <span class="math inline">\(N\le 10^9\)</span>
不要急，先想暴力DP。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为长串前缀 <span
class="math inline">\(i\)</span> 的后缀与短串匹配了前 <span
class="math inline">\(j\)</span> 个的方案个数。</p>
<p>答案为： <span class="math display">\[
\sum_{i=0}^{m-1}f[n][i]
\]</span> 如何转移？</p>
<p>第二维相当于：加入一个字符，将这个新串 <code>reverse</code>
一下，求新大串和小串的 <span
class="math inline">\(\textrm{LCP}\)</span>。</p>
<p>如果匹配上，就是 <span class="math inline">\(f[i][j]\to
f[i+1][j+1]\)</span>；如果失配，就是 <span
class="math inline">\(f[i][j]\to f[i+1][k]\)</span>。</p>
<p>这里的 <span class="math inline">\(k\)</span> 可以联想 KMP 理解。</p>
<p>设 <span class="math inline">\(g[k][j]\)</span> 为：当前第二维为
<span
class="math inline">\(k\)</span>，末尾加一个新数字，能加入多少种数字，使得匹配到的长度从
<span class="math inline">\(k\)</span> 变为 <span
class="math inline">\(j\)</span>。</p>
<p>有 DP 式子： <span class="math display">\[
f[i][j]=\sum_{k=0}^{m-1}f[i-1][k]\times g[k][j]
\]</span> 容易理解。</p>
<p>对于 <span
class="math inline">\(g\)</span>，小串是不动的，随便预处理一下，反正
<span class="math inline">\(M\le 20\)</span>。</p>
<p>DP 是 <span class="math inline">\(O(nm)\)</span> 的，需要加速。</p>
<p>这个形式显然是矩乘。直接快速幂加速即可。</p>
<p>时间复杂度 <span class="math inline">\(O(m^3\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,nxt[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x+=y)&gt;=mod&amp;&amp;(x-=mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> n,A[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> _n=<span class="number">0</span>) &#123;n=_n,<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in">sizeof</span>(A));&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> ~ () &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) A[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ret</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k) &#123;</span><br><span class="line">            <span class="built_in">upd</span>(ret.A[i][k],<span class="number">1LL</span>*A[i][j]*b.A[j][k]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> ^ (<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ret</span><span class="params">(n)</span>,x</span>=*<span class="keyword">this</span>; ~ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> p=b;p;p&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ret=ret*x;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nxt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i]) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i]) ++j;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">F</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch=<span class="string">&#x27;0&#x27;</span>;ch&lt;=<span class="string">&#x27;9&#x27;</span>;++ch) &#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=ch) j=nxt[j];</span><br><span class="line">            <span class="keyword">if</span>(s[j+<span class="number">1</span>]==ch) ++j;</span><br><span class="line">            ++F.A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    Matrix F=<span class="built_in">kmp</span>();</span><br><span class="line">    F=F^n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">upd</span>(ans,F.A[<span class="number">0</span>][i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵加速</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3266</title>
    <url>/2023/12/27/P3266/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3266">P3266 [JLOI2015]
骗我呢</a></p>
<span id="more"></span>
<p>计数小trick。</p>
<p>对于每一行，值域 <span class="math inline">\([0,m]\)</span>，<span
class="math inline">\(m\)</span> 个数，那就只有一个数没有出现过。</p>
<p>也就是说，必须严格递增，单次增加 <span class="math inline">\(\le
2\)</span> 而且有且仅有一个为 <span
class="math inline">\(2\)</span>。</p>
<p>发现只要知道没出现的数是啥，就能确定一整行数，这是关键的状态设计方法。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为第 <span
class="math inline">\(i\)</span> 行没出现过的数是 <span
class="math inline">\(j\)</span> 的方案数，显然有 <span
class="math inline">\(f[i][j]=\sum_{k=0}^{j+1}f[i-1][k]\)</span>。</p>
<p>关于 <span class="math inline">\(j+1\)</span>
的上界：手模一下第二个限制，发现大于 <span
class="math inline">\(j+1\)</span> 就不合法了。</p>
<p>和式的转移方法，可以观察相邻的两个差了多少，然后尝试类似前缀和的转移。</p>
<p>发现 <span
class="math inline">\(f[i][j]-f[i][j-1]=f[i-1][j+1]\)</span>，得到 <span
class="math inline">\(f[i][j]=f[i][j-1]+f[i-1][j+1]\)</span>，状态设计不变。</p>
<p>对于这种式子，套路的，转成二维平面上路径计数。</p>
<figure>
<img src="https://s1.ax1x.com/2018/10/18/iwUEt0.png" alt="sample1" />
<figcaption aria-hidden="true">sample1</figcaption>
</figure>
<p>实际上是在数上图的左上到右下的路径个数。</p>
<p>看起来很丑，变换一下基向量，别忘了要<strong>对图形的边界一起变换</strong>。</p>
<p>最终再对称一下，变成：</p>
<figure>
<img src="https://s1.ax1x.com/2018/10/18/iwUt1O.png" alt="sample2" />
<figcaption aria-hidden="true">sample2</figcaption>
</figure>
<p>只能向上或向右走，数左下到右上，且不能碰到左右两条直线的路径个数。</p>
<p>（第二个图左边的虚线是第一个图最左侧竖着的那一列线段）</p>
<p>精准一点，是从 <span class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\((n+m+1,n)\)</span>，且不触碰 <span
class="math inline">\(A:y=x+1\)</span>，<span
class="math inline">\(B:y=x-(m+2)\)</span> 的路径条数。</p>
<p>如果只有一条线，可以像我们的经典问题：求卡特兰数递推式那样做一个对称然后简单求个组合数。</p>
<p>具体的，如果只有 <span class="math inline">\(A\)</span>，做出 <span
class="math inline">\((n+m+1,n)\)</span> 关于 <span
class="math inline">\(A\)</span> 的对称点 <span
class="math inline">\(P\)</span>，那么 <span
class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\((n+m+1,n)\)</span> 的路径个数减去 <span
class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\(P\)</span> 的个数就是答案。容易发现任何一个 <span
class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\(P\)</span> 的路径都代表碰到过直线到达 <span
class="math inline">\((n+m+1,n)\)</span> 的一个方案。</p>
<p>但是两条线很难直接算。</p>
<p>将触碰（或穿过）直线的序列写出来，形如 <code>AAABBAABBB</code>。</p>
<p>但是这样还要考虑具体碰了几次，比较麻烦。</p>
<p>把极长连续段缩一下，变成
<code>ABAB</code>，直接对着接触直线的“本质次数”，或者说交换的次数来做计数。</p>
<p>发现卡特兰数的递推式推导过程中，减去的部分本质上是求缩完连续段后，<strong>最后一个触碰的直线为
<span class="math inline">\(A\)</span></strong>
的方案数（因为是对终点做对称，容易理解），只不过只有一条线，最后还是最前无所谓了。</p>
<p>所以在两条线的情况下，只数 <span
class="math inline">\((n+m+1,n)\)</span> 关于 <span
class="math inline">\(A\)</span> 的对称点 <span
class="math inline">\(P\)</span> 的方案的话，求出来的是序列以
<code>A</code> 结尾的，吗？</p>
<p>并不是，因为我们完全忽略了直线 <span
class="math inline">\(B\)</span>，其实是以 <code>A</code> 或
<code>AB</code> 结尾的，容易发现会计算上除了序列 <code>B</code>
之外的所有情况。</p>
<p>就算只有单单一个 <code>B</code> 也很难算，因为做关于 <span
class="math inline">\(B\)</span>
的对称点也是同理的，需要考虑容斥，具体来说是对序列的前缀容斥。</p>
<p>设 <span class="math inline">\(c(q)\)</span> 为序列 <span
class="math inline">\(q\)</span>
<strong>本身</strong>（不是前后缀）的方案数，<span
class="math inline">\(g(x)\)</span> 为序列长度 <span
class="math inline">\(\ge x\)</span> 的全部方案数，<span
class="math inline">\(h(x,y)\)</span> 为 <span
class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\((x,y)\)</span>
的<strong>无限制</strong>方案数，就是一个简单组合数。</p>
<p>根据前面说的，有 <span
class="math inline">\(h(P)=c(\textrm{A})+g(2)\)</span>。</p>
<p>设 <span class="math inline">\((n+m+1,n)\)</span> 关于 <span
class="math inline">\(B\)</span> 与 <span
class="math inline">\(Q\)</span> 对称，容易得到 <span
class="math inline">\(h(Q)=c(\textrm{B})+g(2)\)</span>。</p>
<p>两式相加，有 <span
class="math inline">\(h(P)+h(Q)=c(\textrm{A})+c(\textrm{B})+2g(2)\)</span>。</p>
<p>根据定义， <span
class="math inline">\(g(1)=c(A)+c(B)+g(2)\)</span>，所以有 <span
class="math inline">\(g(1)=h(P)+h(Q)-g(2)\)</span>。</p>
<p>对于 <span class="math inline">\(h\)</span>，无限制情况下，<span
class="math inline">\((0,0)\)</span> 到 <span
class="math inline">\((x,y)\)</span> 的路径数是 <span
class="math inline">\(\dbinom{x+y}{x}\)</span>，所以说 <span
class="math inline">\(h(x,y)=\dbinom{x+y}{x}\)</span>，容易计算。</p>
<p>对于 <span
class="math inline">\(g\)</span>，发现变成了另一个子问题，递归解决。</p>
<p>容易证明，<span class="math inline">\(P,Q\)</span>
的对称性在组合意义上是可以叠加（递归）的，如果 <span
class="math inline">\(P\)</span> 再对 <span
class="math inline">\(B\)</span> 对称得到 <span
class="math inline">\(P&#39;\)</span>，那么 <span
class="math inline">\(P&#39;\)</span> 就代表以 <code>BA</code> 或
<code>BAB</code> 结尾的方案数，<span
class="math inline">\(Q&#39;\)</span> 同理，代表以 <code>AB</code> 或
<code>ABA</code> 结尾的方案数。</p>
<p>易得：<span
class="math inline">\(h(P&#39;)=c(\textrm{AB})+g(3),h(Q&#39;)=c(\textrm{BA})+g(3),g(2)=h(P&#39;)+h(Q&#39;)-g(3)\)</span>。</p>
<p>代换 <span
class="math inline">\(g(1)=h(P)+h(Q)-h(P&#39;)-h(Q&#39;)+g(3)\)</span>，容易发现
<span class="math inline">\(g(x)\)</span> 的容斥系数为 <span
class="math inline">\((-1)^{x+1}\)</span>。</p>
<p>答案为 <span class="math inline">\(h(n+m+1,n)-g(1)\)</span>。</p>
<p>直接算就完事了，看代码就行，代码是对 <span
class="math inline">\(h(P),h(Q)\)</span> 分开算的，比较好写。</p>
<p>注意到 <span class="math inline">\(P,Q\)</span> 必须时刻保持 <span
class="math inline">\(\ge
0\)</span>，每次对称都至少会向外走一步，所以复杂度有保证。</p>
<p>总复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,ifac[N],fac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    ifac[<span class="number">0</span>]=fac[<span class="number">0</span>]=ifac[<span class="number">1</span>]=fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(mod-mod/i)*ifac[mod%i]%mod;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">path</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n+m]*ifac[n]%mod*ifac[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(x,y);</span><br><span class="line">    x--,y++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(x,y);</span><br><span class="line">    x+=m+<span class="number">2</span>,y-=m+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">3e6</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> x=n+m+<span class="number">1</span>,y=n,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">flip1</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">path</span>(x,y))%mod;</span><br><span class="line">        <span class="built_in">flip2</span>(x,y);</span><br><span class="line">        ans=(ans-<span class="built_in">path</span>(x,y)+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    x=n+m+<span class="number">1</span>,y=n;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">flip2</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">path</span>(x,y))%mod;</span><br><span class="line">        <span class="built_in">flip1</span>(x,y);</span><br><span class="line">        ans=(ans-<span class="built_in">path</span>(x,y)+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(<span class="built_in">path</span>(n+m+<span class="number">1</span>,n)-ans+mod)%mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P3309</title>
    <url>/2023/12/07/P3309/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3309">P3309 [SDOI2014]
向量集</a></p>
<span id="more"></span>
<p>形式化一下：给定 <span class="math inline">\(l,r,x_0,y_0\)</span>，求
<span class="math inline">\(\max\limits_{i=l}^r x_i\times x_0+y_i\times
y_0\)</span>，同时支持在 <span class="math inline">\(x,y\)</span>
末尾插入新元素。</p>
<p>对这种二元式子最优化，想到斜率相关。</p>
<p><span class="math inline">\(i\)</span> 比 <span
class="math inline">\(j\)</span> 更优的条件是：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;x_i\times x_0+y_i\times y_0&gt;x_j\times x_0+y_j\times y_0\\
&amp;x_i\times x_0-x_j\times x_0&gt;y_j\times y_0-y_i\times y_0\\
&amp;x_0\times(x_i-x_j)&gt;y_0\times(y_j-y_i)\\
&amp;\textnormal{if
}y_0&gt;0\,,\;-\frac{x_0}{y_0}&lt;\frac{y_i-y_j}{x_i-x_j}\\
&amp;\textnormal{if
}y_0\le0\,,\;-\frac{x_0}{y_0}&gt;\frac{y_i-y_j}{x_i-x_j}\\
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(y_0&gt;0\)</span>，答案在上凸壳；若
<span class="math inline">\(y\le 0\)</span>，答案在下凸壳。</p>
<p>但是我们需要支持<code>push_back</code>和区间询问。</p>
<p>放在线段树上即可，询问的区间拆到线段树上，线段树每一段维护凸包，对每一段三分算出凸壳上最优点，像线段树查询一样取<code>max</code>。</p>
<p>这里的线段树是“残缺”的，随着加入更多向量不断向右补全。</p>
<p>因为询问的区间不会超过当前向量个数，所以残缺的段一定用不到——也就意味着我们只需要在这个段变得完整的时候，再去算凸壳，这样一个段就只需要算一次，复杂度也就对了。</p>
<p>修改部分复杂度：每个段算一次，总段长为 <span
class="math inline">\(O(n\log n)\)</span>，总复杂度为 <span
class="math inline">\(O(n\log^2 n)\)</span>，这部分是均摊的。</p>
<p>查询部分复杂度：每次要在 <span class="math inline">\(\log n\)</span>
个段上三分，每次三分 <span class="math inline">\(\log
n\)</span>，单次查询 <span class="math inline">\(O(\log^2
n)\)</span>。</p>
<p>综上，总复杂度为 <span class="math inline">\(O(n\log^2
n)\)</span>。</p>
<p>可能更本质一点说：</p>
<p>对 <span class="math inline">\(ans=\max\limits_{i=l}^r x_i\times
x_0+y_i\times y_0\)</span> 除 <span
class="math inline">\(y_0\)</span>，得</p>
<p><span class="math display">\[
\frac{ans}{y_0}=\max\limits_{i=l}^r \frac{x_0}{y_0}\times x_i+y_i
\]</span></p>
<p>实质上是在解决形如下面这个式子的函数动态最值问题。</p>
<p><span class="math display">\[
f(x)=\max_{i=l(x)}^{r(x)}k(x)\times X(i)+B(i)
\]</span></p>
<p>感觉这对 <code>DP</code> 的优化也有一定启发，可能会是一些
<code>wqs</code> 二分？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=b.x)<span class="keyword">return</span> x&lt;b.x;</span><br><span class="line">        <span class="keyword">return</span> y&lt;b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    ll <span class="keyword">operator</span>*(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span>*x*b.y<span class="number">-1ll</span>*y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="function">Point <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        tmp.x-=b.x,tmp.y-=b.y;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function">ll <span class="title">dot</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*a.x*b.x+<span class="number">1ll</span>*a.y*b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,pcnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        vector&lt;Point&gt; up,dn;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remake</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;Point&gt; buc,&amp;t1=t[rt].up,&amp;t2=t[rt].dn;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,r)buc.<span class="built_in">pb</span>(p[i]);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">range</span>(buc));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:buc)&#123;</span><br><span class="line">            <span class="keyword">while</span>(t1.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;(i-t1.<span class="built_in">back</span>())*(t1.<span class="built_in">back</span>()-t1[t1.<span class="built_in">size</span>()<span class="number">-2</span>])&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                t1.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t1.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:buc)&#123;</span><br><span class="line">            <span class="keyword">while</span>(t2.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;(i-t2.<span class="built_in">back</span>())*(t2.<span class="built_in">back</span>()-t2[t2.<span class="built_in">size</span>()<span class="number">-2</span>])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                t2.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t2.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">const</span> vector&lt;Point&gt;&amp; vec,<span class="type">const</span> Point&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=vec.<span class="built_in">size</span>()<span class="number">-1</span>,m1=<span class="number">0</span>,m2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            m1=l+(r-l)/<span class="number">3</span>,m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dot</span>(vec[m1],x)&gt;<span class="built_in">dot</span>(vec[m2],x))r=m2;</span><br><span class="line">            <span class="keyword">else</span> l=m1;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=-INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,r)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">dot</span>(vec[i],x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==r)<span class="built_in">remake</span>(rt,l,r);</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">const</span> Point&amp; w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w.y&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">calc</span>(t[rt].up,w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">calc</span>(t[rt].dn,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;ll res=-INF;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr,w));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr,w));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">char</span> onl;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deco</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(onl!=<span class="string">&#x27;E&#x27;</span>)x^=(ans&amp;<span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;onl;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    Point w;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;w.x&gt;&gt;w.y;</span><br><span class="line">        <span class="built_in">deco</span>(w.x),<span class="built_in">deco</span>(w.y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            p[++pcnt]=w;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,pcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="built_in">deco</span>(l),<span class="built_in">deco</span>(r);</span><br><span class="line">            ans=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,w);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>凸包</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P3317</title>
    <url>/2023/12/27/P3317/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3317">P3317 [SDOI2014]
重建</a></p>
<span id="more"></span>
<p>设边 <span class="math inline">\(e\)</span> 的边权为 <span
class="math inline">\(P_e\)</span>，矩阵树定理的模板求的是 <span
class="math inline">\(\sum\limits_{T}\prod\limits_{e\in
T}P_e\)</span>，在 <span class="math inline">\(\forall e,P_e=1\)</span>
的时候就是生成树个数，而在 <span class="math inline">\(\exists e,P_e\ne
1\)</span> 的时候<strong>不能</strong>代表出现生成树的概率。</p>
<p>显然还需要强制要求树以外的边不存在，也就是 <span
class="math inline">\(\sum\limits_{T}(\prod\limits_{e\in T}
P_e\prod\limits_{e\not\in T}(1-P_e))\)</span>。</p>
<p>拆式子。 <span class="math display">\[
\begin{aligned}
&amp;\sum_{T}\left(\prod_{e\in T} P_e\prod_{e\not\in T}(1-P_e)\right)\\
=&amp;\sum_{T}\left(\prod_{e\in T} P_e\frac{\prod_e(1-P_e)}{\prod_{e\in
T}(1-P_e)}\right)\\
=&amp;\left(\prod_e(1-P_e)\right)\left(\sum_{T}\prod_{e\in
T}\frac{P_e}{1-P_e}\right)
\end{aligned}
\]</span> 前半部分直接算，将 <span
class="math inline">\(\frac{P_e}{1-P_e}\)</span>
作为邻接矩阵的边权，跑矩阵树，得出后半部分。</p>
<p>注意判一下 <span class="math inline">\(1-P_e=0,P_e=0\)</span>
的情况，设成 <code>eps</code>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> D[N][N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mx=i;</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(D[mx][i]&lt;D[j][i])mx=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mx!=i)<span class="built_in">swap</span>(D[mx],D[i]),op^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[i][i]&gt;-eps&amp;&amp;D[i][i]&lt;eps)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">double</span> d=D[j][i]/D[i][i];</span><br><span class="line">            <span class="built_in">rep</span>(k,i,n<span class="number">-1</span>)&#123;</span><br><span class="line">                D[j][k]-=d*D[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res*=D[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op)res*=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            cin&gt;&gt;D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(D[i][j])&lt;eps)D[i][j]=eps;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="number">1</span>-D[i][j])&lt;eps)D[i][j]=<span class="number">1</span>-eps;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)ans*=(<span class="number">1</span>-D[i][j]);</span><br><span class="line">            D[i][j]=D[i][j]/(<span class="number">1</span>-D[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        D[i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                D[i][i]+=D[i][j];</span><br><span class="line">                D[i][j]=-D[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans*=<span class="built_in">Gauss</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>概率与期望</tag>
        <tag>矩阵树定理</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>P3345</title>
    <url>/2023/12/04/P3345/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3345">P3345 [ZJOI2015]
幻想乡战略游戏</a></p>
<span id="more"></span>
<p>其实整道题从头到尾都是在容斥。</p>
<p>题意：维护带点权，边权的树，<span class="math inline">\(m\)</span>
次单点点权加，<span
class="math inline">\(f(x)=\sum\limits_{i=1}^ndis(x,i)\times
w_i\)</span>，<span class="math inline">\(dis\)</span> 为带权距离，<span
class="math inline">\(w\)</span> 为点权。求每次修改后的 <span
class="math inline">\(\min\limits_{x\in tree} f(x)\)</span>。</p>
<p>没有头绪，跳过 怎么求 <span class="math inline">\(f\)</span>
这个问题，直接考虑：假设当前暂定答案为 <span
class="math inline">\(f(x)\)</span>，如何确定 <span
class="math inline">\(y\in son(x)\)</span> 是否满足 <span
class="math inline">\(f(y)&lt;f(x)\)</span>。</p>
<p>直接做差，设 <span class="math inline">\(s(x)\)</span> 为 <span
class="math inline">\(x\)</span> 为根的子树点权之和，因为 <span
class="math inline">\(dis(x,y)&gt;0\)</span>，有</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\Delta=f(y)-f(x)=(s(x)-2s(y))\times dis(x,y)\\
&amp;\Delta &lt;0\,\Leftrightarrow s(x)&lt;2s(y)
\end{aligned}
\]</span></p>
<p>这一步画个图很好理解。显然对于某个 <span
class="math inline">\(x\)</span>，这样的 <span
class="math inline">\(y\)</span> 至多存在一个。</p>
<p>可以想到一个暴力：每次询问从根开始向下跑，不断从 <span
class="math inline">\(x\)</span> 递归到 <span
class="math inline">\(y\)</span> 内，找不到 <span
class="math inline">\(y\)</span> 说明 <span
class="math inline">\(f(x)\)</span> 就是答案。</p>
<p>但还需要证明一步：如果 <span
class="math inline">\(f(y)&gt;f(x)\)</span>，那么 <span
class="math inline">\(\forall y^\prime\in
son(y),f(y^\prime)&gt;f(x)\)</span> 也一定成立。</p>
<p>证明：假设 <span class="math inline">\(y^\prime\)</span> 比 <span
class="math inline">\(x\)</span> 更优，那么有 <span
class="math inline">\(s(x)&lt;2s(y^\prime),s(x)\ge 2s(y)\)</span>，得到
<span
class="math inline">\(s(y^\prime)&gt;s(y)\)</span>，因为点权非负，有
<span class="math inline">\(s(y^\prime)\le s(y)\)</span>
，矛盾，得证。</p>
<p>易得，如果 <span class="math inline">\(\exists
y,f(y)&lt;f(x)\)</span>，那么最优点一定在 以 <span
class="math inline">\(y\)</span> 子树内，否则最优点为 <span
class="math inline">\(x\)</span>。</p>
<p>所以上面那个暴力是对的，就是太慢了。</p>
<p>这种子树里找点的算法要马上想到点分治，此题带修，建点分树。</p>
<p>但是点分树上的儿子并不是原图中儿子，不能直接跳儿子……吗？</p>
<p>其实完全可以，只不过找 <span class="math inline">\(y\)</span>
不能在点分树上找，要找原图中的 <span class="math inline">\(y\in
son(x)\)</span>，如果有更优的 <span
class="math inline">\(y\)</span>，跳到 <span
class="math inline">\(y\)</span>
为根的子树的重心节点在点分树上的位置——就是 <span
class="math inline">\(x\)</span> 在点分树上的某个对应的儿子。</p>
<p>容易证明这是对的，因为没有错过子树中的任何一个部分，只是从重心分治了一下而已。</p>
<p>在树中找儿子是有复杂度保证的，题面一定要看完：</p>
<blockquote>
<p>非常神奇的是，对于所有数据，这棵树上的点的度数都不超过 <span
class="math inline">\(20\)</span>。</p>
</blockquote>
<p>显然，点分树上度数也不超过 <span
class="math inline">\(20\)</span>。</p>
<p>回到如何求出 <span class="math inline">\(f\)</span>
的问题，这似乎是个套路（我草写这题的时候被我忘了），注意下文的 <span
class="math inline">\(fa_x\)</span> 是 <span
class="math inline">\(x\)</span>
在<strong>点分树</strong>上的父亲，所有和树结构相关的东西也都是在<strong>点分树</strong>上的。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;g(x)=\sum_{i\in subtree(x)}dis(x,i)\times A_i\\
&amp;h(x)=\sum_{i\in subtree(x)}dis(fa_x,i)\times A_i\\
\end{aligned}
\]</span></p>
<p>设 <span class="math inline">\(A\)</span> 为 <span
class="math inline">\(x\)</span>
的所有根以外的祖先组成的点集，则有：</p>
<p><span class="math display">\[
\begin{aligned}
f(x)=g(x)+\sum\limits_{i\in
A}g(fa_i)-h(i)+dis(x,fa_i)\times(s(fa_i)-s(i))
\end{aligned}
\]</span></p>
<p>画图感受一下这个式子，<span class="math inline">\(h,g\)</span>
代表的这种思想比较有启发意义。</p>
<p><span class="math inline">\(h\)</span> 实质上是 <span
class="math inline">\(g\)</span> 中每个系数都加一的结果，设 <span
class="math inline">\(D\)</span>：<span
class="math inline">\(fa_i\)</span> 为根子树（除了以 <span
class="math inline">\(i\)</span> 为根子树部分）构成的点集。</p>
<p><span class="math inline">\(g(fa_i)-h(i)\)</span> 也就等于 <span
class="math inline">\(\sum\limits_{u\in D}dis(fa_i,u)\times
A_u\)</span>。</p>
<p>加上 <span
class="math inline">\(dis(x,fa_i)\times(s(fa_i)-s(i))\)</span>，补齐了从
<span class="math inline">\(dis(fa_i,u)\)</span> 到 <span
class="math inline">\(dis(x,u)\)</span>
的系数区别，然后枚举祖先，就可以求出全部 <span
class="math inline">\(D\)</span> 并起来的答案，也就是 <span
class="math inline">\(f(x)\)</span> 了。</p>
<p><span class="math inline">\(|A|\)</span> 是 <span
class="math inline">\(O(\log n)\)</span> 的，复杂度正确。</p>
<p>修改就直接在点分树上暴力上跳，改 <span
class="math inline">\(s,h,g\)</span> 即可。</p>
<p>用 <span class="math inline">\(O(n\log n)-O(1)\)</span>
的<code>RMQ</code> 求 <code>LCA</code>，时间复杂度最坏 <span
class="math inline">\(O(m\times 20\log^2 n)\)</span>，很难卡满。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,x,y,z,siz[N],tot;</span><br><span class="line"><span class="type">int</span> head[N],sum,rt,f[N],vis[N],par[N],cnt,lg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll dis1[N],dis2[N],sumv[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v,next,w;&#125;G[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    G[++tot].u=u;G[tot].v=v;G[tot].w=w;G[tot].next=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Orinal_Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> head[N],cnt,tot;</span><br><span class="line">    <span class="type">int</span> st[N&lt;&lt;<span class="number">2</span>][<span class="number">21</span>],dis[N],tpos[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,next,w;&#125;E[<span class="number">2</span>*N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        E[++tot].u=u;E[tot].v=v;E[tot].w=w;E[tot].next=head[u];head[u]=tot;</span><br><span class="line">        E[++tot].u=v;E[tot].v=u;E[tot].w=w;E[tot].next=head[v];head[v]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tpos[u]&gt;tpos[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="type">int</span> k=lg[tpos[v]-tpos[u]+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dis[u]+dis[v]<span class="number">-2</span>*<span class="built_in">min</span>(st[tpos[u]][k],st[tpos[v]-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">        st[++cnt][<span class="number">0</span>]=dis[u];tpos[u]=cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=E[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=E[i].v;<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">            dis[v]=dis[u]+E[i].w;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            st[++cnt][<span class="number">0</span>]=dis[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">initrmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tpos,<span class="number">0</span>,<span class="built_in">sizeof</span>(tpos));cnt=<span class="number">0</span>;tot=<span class="number">0</span>;dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=cnt;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=cnt&amp;&amp;i&lt;=cnt;i++)</span><br><span class="line">        st[i][j]=<span class="built_in">min</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=T.head[u];i;i=T.E[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=T.E[i].v;<span class="keyword">if</span>(vis[v]||v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(v,u);siz[u]+=siz[v];</span><br><span class="line">        f[u]=<span class="built_in">max</span>(f[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]=<span class="built_in">max</span>(f[u],sum-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(f[u]&lt;f[rt])rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;par[u]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=T.head[u];i;i=T.E[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=T.E[i].v;<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        sum=siz[v];f[<span class="number">0</span>]=siz[v];rt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(v,<span class="number">0</span>);<span class="built_in">Addedge</span>(u,rt,v);</span><br><span class="line">        <span class="built_in">work</span>(rt,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    sumv[u]+=val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;par[i];i=par[i])&#123;</span><br><span class="line">        <span class="type">int</span> dist=T.<span class="built_in">getdis</span>(par[i],u);</span><br><span class="line">        dis1[par[i]]+=(ll)dist*val;</span><br><span class="line">        dis2[i]+=(ll)dist*val;</span><br><span class="line">        sumv[par[i]]+=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    ll ans=dis1[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;par[i];i=par[i])&#123;</span><br><span class="line">        <span class="type">int</span> dist=T.<span class="built_in">getdis</span>(par[i],u);</span><br><span class="line">        ans+=dis1[par[i]]-dis2[i];</span><br><span class="line">        ans+=dist*(sumv[par[i]]-sumv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="built_in">calc</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].next)&#123;</span><br><span class="line">        ll tmp=<span class="built_in">calc</span>(G[i].w);</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;ans)<span class="keyword">return</span> <span class="built_in">query</span>(G[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis1,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis1));</span><br><span class="line">    <span class="built_in">memset</span>(dis2,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis2));</span><br><span class="line">    <span class="built_in">memset</span>(sumv,<span class="number">0</span>,<span class="built_in">sizeof</span>(sumv));</span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;(N&lt;&lt;<span class="number">2</span>);i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">read</span>(x,y,z),T.<span class="built_in">addedge</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();T.<span class="built_in">initrmq</span>();sum=n;f[<span class="number">0</span>]=n;</span><br><span class="line">    rt=<span class="number">0</span>;<span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> LastOrder=rt;<span class="built_in">work</span>(rt,<span class="number">0</span>);rt=LastOrder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(rt));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>点分治</tag>
        <tag>点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3350</title>
    <url>/2023/12/28/P3350/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3350">P3350 [ZJOI2016]
旅行者</a></p>
<span id="more"></span>
<p>问题很抽象，考虑离线询问，分治。</p>
<p>设当前是在 <span class="math inline">\(x\in
[xl,xr],y\in[yl,yr]\)</span> 这个范围的点中，处理 <span
class="math inline">\(q\in[ql,qr]\)</span> 的询问。</p>
<p>类似于 <span
class="math inline">\(\textrm{KD-Tree}\)</span>，每次在长边上分治，将矩形切成两个小矩形，做跨过中间分割线的询问，将完全在小矩形内的询问递归下去。</p>
<p>对于跨过分割线的询问，枚举分割线上的点，钦定这个点为中转点，跑从这个点到两边小矩形的最短路，贡献答案。</p>
<p>最短路有一个小优化：因为边权 <span class="math inline">\(\ge
1\)</span>，初始化时，如果 <code>dis</code>
数组在上一次求最短路的时候就是曼哈顿距离（真最短路）的话，就不覆盖为
<span class="math inline">\(+\infty\)</span>，直接加上距离。</p>
<p>整体的复杂度分析：</p>
<p>容易发现，形状为正方形，且每次向下传询问都传到底的时候，复杂度最高。</p>
<p>设 <span class="math inline">\(T(n,m,q)\)</span> 为短边长为 <span
class="math inline">\(n\)</span>，长边长为 <span
class="math inline">\(m\)</span> 的长方形内有 <span
class="math inline">\(q\)</span> 个询问（初始时 <span
class="math inline">\(n=m\)</span>），得到答案的复杂度。不妨假设每次分治向下各自传递一半的询问，这样可以全部传到底。
<span class="math display">\[
\begin{aligned}
T(n,m,q)&amp;=n\times nm\log(nm)+nq+2T(\tfrac{m}{2},n,\tfrac{q}{2})\\
&amp;=n^2m\log(nm)+nq+2((\tfrac{m}{2})^2n\log
(\tfrac{nm}{2})+\tfrac{mq}{4})+4T(\tfrac{n}{2},\tfrac{m}{2},\tfrac{q}{4})\\
\end{aligned}
\]</span> 一次递归两层来使 <span class="math inline">\(n,m\)</span>
平衡，发现递归到了另一个 <span class="math inline">\(n=m\)</span>
的子问题，设 <span class="math inline">\(T(n,q)\)</span> 边长为 <span
class="math inline">\(n\)</span> 的正方形中 <span
class="math inline">\(q\)</span> 个询问的复杂度。 <span
class="math display">\[
\begin{aligned}
T(n,q)&amp;=n^3\log
(n^2)+nq+2(\tfrac{n^3}{4}\log(\tfrac{n^2}{2})+\tfrac{nq}{4})+4T(\tfrac{n}{2},\tfrac{q}{4})\\
&amp;=n^3\log
(n^2)+nq+\tfrac{n^3}{2}(\log(n^2)-1)+\tfrac{nq}{2}+4T(\tfrac{n}{2},\tfrac{q}{4})\\
&amp;=3n^3\log
n+\tfrac{3}{2}nq-\tfrac{n^3}{2}+4T(\tfrac{n}{2},\tfrac{q}{4})\\
&amp;=3n^3\log n+\tfrac{3}{2}nq+4T(\tfrac{n}{2},\tfrac{q}{4})
\end{aligned}
\]</span> 设 <span class="math inline">\(C(n,q)=3n^3\log
n+\tfrac{3}{2}nq\)</span>，有： <span class="math display">\[
\begin{aligned}
T(n,q)&amp;=C(n,q)+4T(\tfrac{n}{2},\tfrac{q}{4})\\
&amp;=C(n,q)+4(C(\tfrac{n}{2},\tfrac{q}{4})+4T(\tfrac{n}{4},\tfrac{q}{16}))\\
&amp;=C(n,q)+4C(\tfrac{n}{2},\tfrac{q}{4})+16T(\tfrac{n}{4},\tfrac{q}{16})
\end{aligned}
\]</span> 可以观察到： <span class="math display">\[
\begin{aligned}
T(n,q)&amp;=\sum_{i=1}^{\log
n}2^{2(i-1)}C(\tfrac{n}{2^{i-1}},\tfrac{q}{2^{2(i-1)}})\\
&amp;=\sum_{i=1}^{\log
n}2^{2(i-1)}\left(\tfrac{3}{2^{3(i-1)}}n^3\log(\tfrac{n}{2^{i-1}})+\tfrac{3nq}{2^{3i-2}}\right)\\
&amp;=\sum_{i=1}^{\log
n}\tfrac{3}{2^{i-1}}n^3\log(\tfrac{n}{2^{i-1}})+\tfrac{3nq}{2^i}\\
&amp;=\sum_{i=1}^{\log n}\frac{n^3\log n-n^3i+3nq}{2^i}\\
&amp;=\sum_{i=1}^{\log n}\frac{n^3\log n+nq}{2^i}\\
&amp;=(n^3\log n+nq)\times \left(\sum_{i=1}^{\log n}\frac{1}{2^i}\right)
\end{aligned}
\]</span> 因为 <span class="math inline">\(i\le \log n\)</span>，所以
<span class="math inline">\(-n^3i\)</span> 数量级和 <span
class="math inline">\(n^3\log n\)</span> 持平，可以去掉。</p>
<p>易得 <span class="math inline">\(\sum_{i=1}^{\log
n}\frac{1}{2^i}=\frac{2(n-1)}{n}=O(1)\)</span>。</p>
<p>带入，得： <span class="math display">\[
\begin{aligned}
T(n,q)&amp;=(n^3\log n+nq)\times O(1)\\
&amp;=O(n^3\log n+qn)
\end{aligned}
\]</span> 推导过程中忽略了一些常数和数量级较低的项。</p>
<p>设面积为 <span class="math inline">\(S=n^2\)</span>，复杂度为 <span
class="math inline">\(O(S\sqrt{S}\log S+q\sqrt{S})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">5</span>,Q=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,qn,bcnt;</span><br><span class="line">pii bas[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w,nxt;</span><br><span class="line">&#125;e[Q*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Qry</span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2,id;</span><br><span class="line">&#125;q[Q],buc[Q];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[Q],dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> xl,<span class="type">int</span> xr,<span class="type">int</span> yl,<span class="type">int</span> yr,<span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d=dis[u];</span><br><span class="line">    <span class="built_in">rep</span>(i,xl,xr)<span class="built_in">rep</span>(j,yl,yr)&#123;</span><br><span class="line">        dis[<span class="built_in">id</span>(i,j)]=h?dis[<span class="built_in">id</span>(i,j)]+d:inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[u]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,u&#125;);</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>,v=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">tie</span>(f,u)=que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(dis[u]!=f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="built_in">tie</span>(x,y)=bas[v];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;xl||xr&lt;x||y&lt;yl||yr&lt;y)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> xl,<span class="type">int</span> xr,<span class="type">int</span> yl,<span class="type">int</span> yr,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&gt;qr)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(xr-xl&gt;yr-yl)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(xl+xr)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,yl,yr)&#123;</span><br><span class="line">            <span class="built_in">dij</span>(<span class="built_in">id</span>(mid,i),xl,xr,yl,yr,i-yl);</span><br><span class="line">            <span class="built_in">rep</span>(j,ql,qr)&#123;</span><br><span class="line">                ans[q[j].id]=<span class="built_in">min</span>(ans[q[j].id],dis[<span class="built_in">id</span>(q[j].x1,q[j].y1)]+dis[<span class="built_in">id</span>(q[j].x2,q[j].y2)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=ql<span class="number">-1</span>,r=qr+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,ql,qr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].x1&lt;mid&amp;&amp;q[i].x2&lt;mid)buc[++l]=q[i];</span><br><span class="line">            <span class="keyword">if</span>(q[i].x1&gt;mid&amp;&amp;q[i].x2&gt;mid)buc[--r]=q[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,ql,l)q[i]=buc[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,r,qr)q[i]=buc[i];</span><br><span class="line">        <span class="built_in">solve</span>(xl,mid<span class="number">-1</span>,yl,yr,ql,l);</span><br><span class="line">        <span class="built_in">solve</span>(mid+<span class="number">1</span>,xr,yl,yr,r,qr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(yl+yr)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,xl,xr)&#123;</span><br><span class="line">            <span class="built_in">dij</span>(<span class="built_in">id</span>(i,mid),xl,xr,yl,yr,i-xl);</span><br><span class="line">            <span class="built_in">rep</span>(j,ql,qr)&#123;</span><br><span class="line">                ans[q[j].id]=<span class="built_in">min</span>(ans[q[j].id],dis[<span class="built_in">id</span>(q[j].x1,q[j].y1)]+dis[<span class="built_in">id</span>(q[j].x2,q[j].y2)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=ql<span class="number">-1</span>,r=qr+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,ql,qr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].y1&lt;mid&amp;&amp;q[i].y2&lt;mid)buc[++l]=q[i];</span><br><span class="line">            <span class="keyword">if</span>(q[i].y1&gt;mid&amp;&amp;q[i].y2&gt;mid)buc[--r]=q[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,ql,l)q[i]=buc[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,r,qr)q[i]=buc[i];</span><br><span class="line">        <span class="built_in">solve</span>(xl,xr,yl,mid<span class="number">-1</span>,ql,l);</span><br><span class="line">        <span class="built_in">solve</span>(xl,xr,mid+<span class="number">1</span>,yr,r,qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">        bas[++bcnt]=&#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">re</span>(j,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">ae</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j+<span class="number">1</span>),x);</span><br><span class="line">        <span class="built_in">ae</span>(<span class="built_in">id</span>(i,j+<span class="number">1</span>),<span class="built_in">id</span>(i,j),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)<span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">ae</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i+<span class="number">1</span>,j),x);</span><br><span class="line">        <span class="built_in">ae</span>(<span class="built_in">id</span>(i+<span class="number">1</span>,j),<span class="built_in">id</span>(i,j),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(qn);</span><br><span class="line">    <span class="built_in">re</span>(i,qn)&#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].x1,q[i].y1,q[i].x2,q[i].y2);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">1</span>,m,<span class="number">1</span>,qn);</span><br><span class="line">    <span class="built_in">re</span>(i,qn)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>分治</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P3403</title>
    <url>/2023/12/02/P3403/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3403">P3403 跳楼机</a></p>
<span id="more"></span>
<p>这是同余最短路的经典问题。</p>
<p><span class="math inline">\(n\)</span>
很大，考虑可以到达的楼层的分布规律。</p>
<p>可以发现，如果我们能到第 <span class="math inline">\(n\)</span>
层，也一定能到 <span class="math inline">\(n+x\)</span> 层（<span
class="math inline">\(y,z\)</span> 同理）。</p>
<p>也就是说 我们只需要判断 <span class="math inline">\(x\)</span>
的同余类中是否能走到即可。</p>
<p>如何判断呢？</p>
<p>让 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(i+y\mod x\)</span>，<span
class="math inline">\(i+z \mod x\)</span> 连边，边权分别为 <span
class="math inline">\(y,z\)</span> 和。</p>
<p>跑最短路，只要最短路小于等于 <span
class="math inline">\(h\)</span>，我们就可以在全程高度不超过 <span
class="math inline">\(h\)</span> 的前提下到达某个同余类。</p>
<p>显然，同余最短路可以拓展到 <span class="math inline">\(m\)</span>
种上升方式，设每次爬升高度的值域为 <span
class="math inline">\(v\)</span>，复杂度为 <span
class="math inline">\(O(vm\log v)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> h,x,y,z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">  <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  e[++ecnt].to=v;</span><br><span class="line">  e[ecnt].w=w;</span><br><span class="line">  e[ecnt].nxt=head[u];</span><br><span class="line">  head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mkp</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    u=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">      v=e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mkp</span>(dis[v],v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  CIOO;</span><br><span class="line">  cin&gt;&gt;h&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">  h--;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">ae</span>(i,(i+y)%x,y);</span><br><span class="line">    <span class="built_in">ae</span>(i,(i+z)%x,z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dij</span>();</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i]&lt;=h)&#123;</span><br><span class="line">      ans+=(h-dis[i])/x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P3563</title>
    <url>/2023/12/12/P3563/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3563">P3563 [POI2013]
POL-Polarization</a></p>
<span id="more"></span>
<p>和 <a
href="https://h01yshhmy.github.io/2023/12/10/CF1856E2/">CF1856E2 |
h01yshhmy</a>
的DP手段相同，写这篇题解主要为了写题目中结论的证明过程。</p>
<p>先考虑最小值。</p>
<p>显然相邻的两个点一定可以连通，对于不相邻的点，可以将相邻“两层”边都赋上不同方向，这样就只有相邻的点可以连通了，答案为
<span class="math inline">\(n-1\)</span>。</p>
<p>最大值部分。</p>
<p>先规定：子树 <span class="math inline">\(u\)</span>
是外向/内向，<strong>包括</strong> <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(u\)</span> 父亲的边（如果存在）。</p>
<p>设 <span class="math inline">\(siz[u]\)</span> 为以 <span
class="math inline">\(u\)</span> 为根子树的大小，<span
class="math inline">\(sum[u]\)</span> 为 <span
class="math inline">\(\sum_{v\in subT(u)} siz[v]\)</span>。</p>
<p>首先，如果一个 <span class="math inline">\(u\)</span>
为根子树内所有边的方向均相同，那么 <span
class="math inline">\(a,b\)</span> 均在 <span
class="math inline">\(subT(u)\)</span> 内的贡献就是 <span
class="math inline">\(sum[u]-|subT(u)|\)</span>。</p>
<p>只需要边相同，全外向和全内向在子树内部造成的贡献是一样的，但是在子树的外部，显然内向子树可以向上走，走到外向子树内，会造成更多额外贡献，反之亦然。</p>
<p>有一个结论：对于最大值，最优情况一定是以一个点为根，其各个子树内边的状态为要么该点能到达子树内的每个点，即外向，要么子树内的每个点能到达该点，即内向，且该点为树的重心。</p>
<p>假设当前树上有两个中心：<span class="math inline">\(u,v\)</span>（将
<span class="math inline">\(u\)</span> 提到根或者 <span
class="math inline">\(v\)</span>
提到根均可以满足上述要求）。可以发现，<span
class="math inline">\(u,v\)</span> 之间的方向是单向的，设 <span
class="math inline">\(u,v\)</span> 儿子中内向子树集合分别为 <span
class="math inline">\(A,C\)</span>，外向子树集合分别为 <span
class="math inline">\(B,D\)</span>，那么额外贡献要么是 <span
class="math inline">\(A\times C\)</span> 要么是 <span
class="math inline">\(B\times D\)</span>，但如果将 <span
class="math inline">\(u,v\)</span> 中一个点内方向统一，就可以贡献 <span
class="math inline">\((A+B)\times D\)</span> 或者 <span
class="math inline">\((C+D)\times B\)</span>
之类，总之一定比原来更优，而且方向不统一其实还会损失前文中 <span
class="math inline">\(sum[u]-|subT(u)|\)</span> 的部分。</p>
<p>也就是说，设中心为 <span class="math inline">\(u\)</span>，<span
class="math inline">\(u\)</span> 中外向儿子集合为 <span
class="math inline">\(S\)</span>，内向儿子集合为 <span
class="math inline">\(T\)</span>，那么额外贡献总和为 <span
class="math inline">\((\sum_{i\in S}siz[i])\times (\sum_{i\in
T}siz[i])\)</span>。</p>
<p>那么为什么是重心呢？</p>
<p>首先两个和式之和恒等于 <span
class="math inline">\(n-1\)</span>，有基本不等式，两个和式的大小越接近越好，当然其中一个也是越接近
<span class="math inline">\(\frac{n}{2}\)</span> 越好。</p>
<p>设当前中心为 <span class="math inline">\(u\)</span>，如果 <span
class="math inline">\(u\)</span> 儿子中有子树大小 <span
class="math inline">\(&gt;
\frac{n}{2}\)</span>，显然中心应该向这个儿子移动（这个儿子最多只有一个），因为这一个儿子都已经
<span class="math inline">\(&gt;\frac{n}{2}\)</span>
了，更别说和别的拼起来，所以要让它小一点，一直这样移动，最终就会移动到重心上。</p>
<p>求重心比较容易，现在要有一种划分集合 <span
class="math inline">\(S,T\)</span> 的方式，使得 <span
class="math inline">\((\sum_{i\in S}siz[i])\times (\sum_{i\in
T}siz[i])\)</span> 最大。</p>
<p>因为所有物品（儿子<code>siz</code>）之和恒等于 <span
class="math inline">\(n-1\)</span>，种类数不超过 <span
class="math inline">\(\sqrt{n}\)</span>，将 01
背包转为多重背包，并做二进制分组，只需要判断可行性，可以用
<code>bitset</code> 优化，最终复杂度为 <span
class="math inline">\(O(\frac{n\sqrt{n}}{w})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">250005</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> siz[N],mxp[N],rt,mnNum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        mxp[u]=<span class="built_in">max</span>(mxp[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[u]=<span class="built_in">max</span>(mxp[u],n-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mxp[u]&lt;mnNum)&#123;</span><br><span class="line">        mnNum=mxp[u];</span><br><span class="line">        rt=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[N],tot,cnt[N];</span><br><span class="line">bitset&lt;N&gt; f;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    rt=<span class="number">0</span>,mnNum=inf;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        ans+=siz[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[rt])&#123;</span><br><span class="line">        cnt[siz[v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i]&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            cnt[i]-=<span class="number">2</span>,cnt[i*<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,cnt[i])&#123;</span><br><span class="line">            f|=f&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pe</span>(i,n/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i])&#123;</span><br><span class="line">            <span class="built_in">write</span>(n<span class="number">-1</span>,<span class="string">&#x27; &#x27;</span>,ans+<span class="number">1ll</span>*i*(n-i<span class="number">-1</span>),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树的重心</tag>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>bitset</tag>
        <tag>贪心</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3604</title>
    <url>/2023/12/02/P3604/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3604">P3604
美好的每一天</a></p>
<span id="more"></span>
<p>只有简单区间询问 和 不太好求的答案，想到莫队。</p>
<p>显然，能构成一个回文串的区间，内部一定至多有一种字符有奇数个。</p>
<p>发现字符集很小（26），而且我们只关注奇偶性：考虑状压。</p>
<p>可以预处理出每个 <span class="math inline">\([1,i]\)</span>
前缀内每个字符的奇偶性状态。</p>
<p>因为奇偶性的状态等价于异或，对异或前缀和 <span
class="math inline">\(s\)</span> 直接差分即可查询区间信息。</p>
<p>思考什么样的区间异或值可以对答案产生贡献：至多有一个位置为1。</p>
<p>问题转化为：区间 <span class="math inline">\([l,r]\)</span> 内有多少
<span class="math inline">\((x,y)\)</span>，使得 <span
class="math inline">\(s_y\oplus s_{x-1}\)</span> 至多只有一位为1（<span
class="math inline">\(x\le y\)</span>）。</p>
<p>现在可以莫队了。</p>
<p>加入/删除一个位置 <span
class="math inline">\(x\)</span>，考虑其他位置和这个位置匹配成 <span
class="math inline">\((x,y)\)</span>
能产生多少贡献，也就是看有多少个满足至多只有一位为1（复读）。</p>
<p>算答案很简单，要么 <span
class="math inline">\(s_x=s_y\)</span>，要么就枚举为 <span
class="math inline">\(1\)</span> 的是哪一位。</p>
<p>时间复杂度 <span
class="math inline">\(O(26n\sqrt{n})\)</span>，莫队不要忘了
先算后加，先删后算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">6e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,B,a[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> qry&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l/B==b.l/B)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((l/B)&amp;<span class="number">1</span>)?r&lt;b.r:r&gt;b.r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l&lt;b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line">ll nowans,ans[N];</span><br><span class="line"><span class="type">int</span> cnt[(<span class="number">1</span>&lt;&lt;<span class="number">26</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    nowans+=cnt[a[x]];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        nowans+=cnt[a[x]^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">    nowans-=cnt[a[x]];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        nowans-=cnt[a[x]^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    B=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    cin&gt;&gt;(str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        a[i]=(<span class="number">1</span>&lt;&lt;(str[i]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        a[i]^=a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        q[i]=(qry)&#123;l,r,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l<span class="number">-1</span>)<span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l<span class="number">-1</span>)<span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r)<span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r)<span class="built_in">add</span>(++r);</span><br><span class="line">        ans[q[i].id]=nowans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>P3703</title>
    <url>/2023/12/04/P3703/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3703">P3703 [SDOI2017]
树点涂色</a></p>
<span id="more"></span>
<p>阅读题面，考虑树剖。</p>
<p>通过画图可以注意到，设 <span class="math inline">\(f[u]\)</span> 为
<span class="math inline">\(u\)</span> 到根的路径权值，那么 <span
class="math inline">\((u,v)\)</span> 路径权值就等于 <span
class="math inline">\(f[u]+f[v]-2*f[lca(u,v)]+1\)</span>。</p>
<p>现在考虑如何维护 <span class="math inline">\(f\)</span>。</p>
<p>有 <span class="math inline">\(f\)</span> 后，操作 <span
class="math inline">\(2\)</span> 只需要求 <span
class="math inline">\(lca\)</span>，操作 <span
class="math inline">\(3\)</span> 只需要求区间最大值，重点在操作 <span
class="math inline">\(1\)</span>，如何修改？</p>
<p>考虑维护每个相同颜色的段，覆盖 <span class="math inline">\(u\)</span>
到根颜色时，直接暴力遍历路径上每个颜色段。</p>
<p>具体如何修改？我们考虑现在正在 <span class="math inline">\(u\to
top[u]\)</span> 重链上的情况，设 <span
class="math inline">\(las\)</span> 为 <span
class="math inline">\(u\)</span> 下面刚转移过来的节点。</p>
<p>las 的子树内显然维护完毕，我们需要给以 <span
class="math inline">\(top[u]\)</span> 为根的子树除去 <span
class="math inline">\(las\)</span> 为根的子树 减去原来 <span
class="math inline">\(u\)</span> 到根的颜色段数（就是 <span
class="math inline">\(f[u]\)</span> 答案）。</p>
<p>先给 <span class="math inline">\(top[u]\)</span> 减去，再给 <span
class="math inline">\(las\)</span> 加上即可。</p>
<p>还有一个要注意的点。</p>
<p>假如原来这段颜色并没有被正在修改的路径完全覆盖，则需要对这段颜色所在的子树单独加一。</p>
<p>关于复杂度：考虑每次修改最多只会增加一个颜色段，而一个颜色段被遍历到的时候，就会被覆盖（或者说删除），所以一共遍历颜色段的次数只有
<span
class="math inline">\(O(n+m)\)</span>，修改颜色段时用的是树剖修改这个段，修改一个段要
<span class="math inline">\(O(\log^2 n)\)</span>，所以总复杂度上界为
<span class="math inline">\(O((n+m)\log^2 n)\)</span>。</p>
<p>当然此题有比较短（真的短吗）的 <code>LCT</code> 写法，等学完
<code>LCT</code> 再说，先鸽了。</p>
<p>upd：学完 <code>LCT</code> 了，摆了，就这样吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">namespace</span> GR&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u,v);</span><br><span class="line">            G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">            G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> TD&#123;</span><br><span class="line">    <span class="type">int</span> top[N],fa[N],dep[N],hson[N],siz[N],dfn[N],idx[N],dfncnt;</span><br><span class="line">    <span class="type">int</span> pa[N][<span class="number">18</span>],frm[N],to[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">        fa[u]=f,siz[u]=<span class="number">1</span>,dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">        pa[u][<span class="number">0</span>]=fa[u];</span><br><span class="line">        frm[u]=u,to[u]=u;</span><br><span class="line">        <span class="built_in">re</span>(i,<span class="number">16</span>)&#123;</span><br><span class="line">            pa[u][i]=pa[pa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">each</span>(v,GR::G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init1</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">                hson[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">        top[u]=tp,idx[u]=++dfncnt;</span><br><span class="line">        dfn[dfncnt]=u;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">init2</span>(hson[u],tp);</span><br><span class="line">        <span class="built_in">each</span>(v,GR::G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init2</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> mx,lz,col;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mx=dep[dfn[l]];</span><br><span class="line">            t[rt].col=dfn[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updMax</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].mx+=v;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updCol</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].col=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">            <span class="built_in">updMax</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">            <span class="built_in">updMax</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">            t[rt].lz=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].col)&#123;</span><br><span class="line">            <span class="built_in">updCol</span>(<span class="built_in">ls</span>(rt),t[rt].col);</span><br><span class="line">            <span class="built_in">updCol</span>(<span class="built_in">rs</span>(rt),t[rt].col);</span><br><span class="line">            t[rt].col=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modMax</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">updMax</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modMax</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modMax</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modCol</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">updCol</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modCol</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modCol</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qryMax</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mx;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">qryMax</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">qryMax</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qryCol</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> t[rt].col;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="keyword">return</span> <span class="built_in">qryCol</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qryCol</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modPath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> las)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            <span class="type">int</span> tmp=<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[u],idx[u]);</span><br><span class="line">            <span class="built_in">modMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[top[u]]+siz[top[u]]<span class="number">-1</span>,<span class="number">1</span>-tmp);</span><br><span class="line">            <span class="keyword">if</span>(las)<span class="built_in">modMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[las],idx[las]+siz[las]<span class="number">-1</span>,tmp<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">modCol</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[u],tot);</span><br><span class="line">            las=top[u],u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[u],idx[u]);</span><br><span class="line">        <span class="built_in">modMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[u],idx[u]+siz[u]<span class="number">-1</span>,<span class="number">1</span>-tmp);</span><br><span class="line">        <span class="keyword">if</span>(las)<span class="built_in">modMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[las],idx[las]+siz[las]<span class="number">-1</span>,tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">modCol</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[u],idx[v],tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbTo</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">per</span>(i,<span class="number">16</span>,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[pa[u][i]]&gt;dep[v])&#123;</span><br><span class="line">                u=pa[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        frm[++tot]=u;</span><br><span class="line">        to[tot]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> las=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="type">int</span> c=<span class="built_in">qryCol</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[u]),tt=to[c];</span><br><span class="line">            <span class="keyword">if</span>(frm[c]==u)frm[c]=to[c]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                to[c]=<span class="built_in">climbTo</span>(frm[c],u);</span><br><span class="line">                <span class="built_in">modMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[to[c]],idx[to[c]]+siz[to[c]]<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">modPath</span>(u,tt,las);</span><br><span class="line">            u=fa[tt];</span><br><span class="line">            las=tt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    tot=n;</span><br><span class="line">    GR::<span class="built_in">work</span>();</span><br><span class="line">    TD::<span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u);</span><br><span class="line">            TD::<span class="built_in">modify</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u,v);</span><br><span class="line">            <span class="type">int</span> lca=TD::<span class="built_in">lca</span>(u,v);</span><br><span class="line">            <span class="type">int</span> ans1=TD::<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,TD::idx[u],TD::idx[u]);</span><br><span class="line">            <span class="type">int</span> ans2=TD::<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,TD::idx[v],TD::idx[v]);</span><br><span class="line">            <span class="type">int</span> ans3=TD::<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,TD::idx[lca],TD::idx[lca]);</span><br><span class="line">            <span class="built_in">write</span>(ans1+ans2-ans3*<span class="number">2</span>+<span class="number">1</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u);</span><br><span class="line">            <span class="built_in">write</span>(TD::<span class="built_in">qryMax</span>(<span class="number">1</span>,<span class="number">1</span>,n,TD::idx[u],TD::idx[u]+TD::siz[u]<span class="number">-1</span>),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>P3676</title>
    <url>/2023/12/04/P3676/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3676">P3676
小清新数据结构题</a></p>
<span id="more"></span>
<p>题意：维护带点权的树，支持两种操作。操作 <span
class="math inline">\(1\)</span>：修改 <span
class="math inline">\(x\)</span> 的点权 <span
class="math inline">\(w_x\)</span>，操作 <span
class="math inline">\(2\)</span>：查询以 <span
class="math inline">\(x\)</span> 为整棵树的根时，<span
class="math inline">\(\sum\limits_{i=1}^n(\sum\limits_{j\in
subT(i)}w_j)^2\)</span>。</p>
<p>平方和，考虑拆式子或者做转化。</p>
<p>看起来不太好直接拆，子树和转成区间的前缀和-差分后，还是不好拆。</p>
<p>考虑另一个道路，转化成其他形式/函数。</p>
<p>设 <span class="math inline">\(x\)</span> 为树根，<span
class="math inline">\(sum=\sum\limits_{i=1}^n w_i\)</span>，<span
class="math inline">\(s(i)=\sum\limits_{j\in subT(i)}w_j\)</span>。</p>
<p>使用拆贡献的转换方式，<span
class="math inline">\(\sum_{i=1}^ns(i)=\sum_{i=1}^nw_i\times
(dis(i,x)+1)\)</span>，计算每个点权会被加几次。</p>
<p>进一步得到 <span
class="math inline">\(\sum_{i=1}^ns(i)=sum+\sum_{i=1}^nw_i\times
dis(i,x)\)</span></p>
<p>设 <span class="math inline">\(F=\sum_{i=1}^nw_i\times
dis(i,x)\)</span>，对于 <span class="math inline">\(F\)</span>
的计算，在 <a href="https://h01yshhmy.github.io/2023/12/04/P3345/">P3345
| h01yshhmy</a> 有完整的推导过程。</p>
<p>也就是 <span class="math inline">\(\sum_{i=1}^n
s(i)=sum+F\)</span>。</p>
<p>接下来有一个重要的观察：<span class="math inline">\(\sum_{i=1}^n
s(i)\times(sum-s(i))\)</span>
和根的位置无关，<strong>一直是一个定值</strong>，设为 <span
class="math inline">\(W\)</span>。</p>
<p>可以理解为每条边的两端的权值和相乘再求和，这种思想还是比较好的，在变化的对应关系中找不变量，通过不变量可能会更容易表示出答案，当然也是在凑
<span class="math inline">\(\sum_{i=1}^n s(i)^2\)</span> 的形式。</p>
<p>拆括号，<span class="math inline">\(W=\sum_{i=1}^n sum\times
s(i)-\sum_{i=1}^n s(i)^2\)</span>。</p>
<p><span class="math inline">\(\sum_{i=1}^n sum\times
s(i)=sum\sum_{i=1}^n s(i)=sum\times(sum+F)\)</span>。</p>
<p>所以 <span class="math inline">\(W=sum\times(sum+F)-\sum_{i=1}^n
s(i)^2\)</span>。</p>
<p>那么答案就出来了：<span class="math inline">\(\sum_{i=1}^n
s(i)^2=sum\times (sum+F)-W\)</span>。</p>
<p><span class="math inline">\(sum,W\)</span> 均可以 <span
class="math inline">\(O(n)\)</span> 预处理，不再赘述。</p>
<p><span class="math inline">\(F\)</span> 的计算方法在 <a
href="https://h01yshhmy.github.io/2023/12/04/P3345/">P3345 |
h01yshhmy</a>。</p>
<p>用 <span class="math inline">\(O(n\log n)-O(1)\)</span>
的<code>RMQ</code> 求 <code>LCA</code>，时间复杂度 <span
class="math inline">\(O((n+q)\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to,next;&#125;a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,q,val[N],head[N],cnt,pa[N],dep[N],sz[N],son[N],top[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa[u]=f;dep[u]=dep[f]+<span class="number">1</span>;sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e=head[u];e;e=a[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[e].to;<span class="keyword">if</span> (v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];<span class="keyword">if</span> (sz[v]&gt;sz[son[u]]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[N], dfncnt, f[N][<span class="number">21</span>], lg[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> dfn[x] &lt; dfn[y] ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfncnt, f[dfn[u]][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e=head[u];e;e=a[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[e].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j, <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">re</span>(i, n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">get</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    x = dfn[x], y = dfn[y]; <span class="keyword">if</span> (x &gt; y)<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> z = lg[y - x];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(f[x + <span class="number">1</span>][z], f[y - (<span class="number">1</span> &lt;&lt; z) + <span class="number">1</span>][z]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="keyword">return</span> dep[u]+dep[v]-(dep[<span class="built_in">lca</span>(u,v)]&lt;&lt;<span class="number">1</span>);&#125;</span><br><span class="line"><span class="type">int</span> tot,root,vis[N],w[N],fa[N];</span><br><span class="line">ll sum[N],gather[N],tofa[N],Sum,W,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>;w[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e=head[u];e;e=a[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[e].to;<span class="keyword">if</span> (v==f||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];w[u]=<span class="built_in">max</span>(w[u],sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    w[u]=<span class="built_in">max</span>(w[u],tot-sz[u]);</span><br><span class="line">    <span class="keyword">if</span> (w[u]&lt;w[root]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u]=f;vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e=head[u];e;e=a[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[e].to;<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        tot=sz[v];</span><br><span class="line">        root=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(v,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">solve</span>(root,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[u]+=v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=u;fa[i];i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> dist=<span class="built_in">getdis</span>(u,fa[i]);</span><br><span class="line">        sum[fa[i]]+=v;</span><br><span class="line">        gather[fa[i]]+=dist*v;</span><br><span class="line">        tofa[i]+=dist*v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=gather[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=u;fa[i];i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> dist=<span class="built_in">getdis</span>(u,fa[i]);</span><br><span class="line">        res+=(ll)dist*(sum[fa[i]]-sum[i]);</span><br><span class="line">        res+=gather[fa[i]]-tofa[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e=head[u];e;e=a[e].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[e].to;<span class="keyword">if</span> (v==pa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DP</span>(v);sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    W+=<span class="number">1ll</span>*sz[u]*(Sum-sz[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        a[++cnt]=(edge)&#123;v,head[u]&#125;;head[u]=cnt;</span><br><span class="line">        a[++cnt]=(edge)&#123;u,head[v]&#125;;head[v]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    tot=w[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(val[i]),<span class="built_in">modify</span>(i,val[i]),Sum+=val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DP</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> opt=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(opt,x);</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(y);</span><br><span class="line">            <span class="built_in">modify</span>(x,y-val[x]);Sum+=y-val[x];</span><br><span class="line">            W+=(y-val[x])*<span class="built_in">calc</span>(x);</span><br><span class="line">            val[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">write</span>((<span class="built_in">calc</span>(x)+Sum)*Sum-W,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>点分治</tag>
        <tag>点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3747</title>
    <url>/2023/12/21/P3747/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3747">P3747 [六省联考
2017] 相逢是问候</a></p>
<span id="more"></span>
<p>其实是<a href="https://www.luogu.com.cn/problem/P4139">P4139
上帝与集合的正确用法</a>与<a
href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟 2 /
花神游历各国</a>的结合题——前者有：欧拉函数的嵌套性质对指数塔的应用，后者有：对于减小速度很快的信息，可以暴力做的思想。</p>
<p>有前置知识：拓展欧拉定理。</p>
<p>我们需要它降幂，来推推式子。</p>
<p>设 <span class="math inline">\(C(i)\)</span> 为 <span
class="math inline">\(c\)</span> 的 “<span
class="math inline">\(i\)</span> 阶方”，也就是一共有 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(c\)</span> 叠起来。 <span class="math display">\[
\begin{aligned}
&amp;C(x)\;\textrm{mod}\;p=c^{C(x-1)\;\textrm{mod}\;\varphi(p)}\\
&amp;C(x-1)\;\textrm{mod}\;\varphi(p)=c^{C(x-2)\;\textrm{mod}\;\varphi(\varphi(p))}
\end{aligned}
\]</span> （值得一提，可能会出现加 <span
class="math inline">\(\varphi(p)\)</span>
的情况（定理内容），不影响正确性，不再赘述）。</p>
<p>发现 <span class="math inline">\(\varphi(p)\)</span>
会不断向上嵌套。</p>
<p>注意到，当 <span class="math inline">\(p\)</span> 是奇数，<span
class="math inline">\(\varphi(p)\le \varphi(p)-1\)</span>，当 <span
class="math inline">\(p\)</span> 是偶数，<span
class="math inline">\(\varphi(p)\le
\frac{\varphi(p)}{2}\)</span>，所以最多嵌套 <span
class="math inline">\(\log p\)</span> 次后，值就为 <span
class="math inline">\(1\)</span>，也就是说，这个“指数塔”高度在 <span
class="math inline">\(\log p\)</span> 以上的部分，模数都为 <span
class="math inline">\(1\)</span>，这部分被消掉了，一个塔的值最大也只有
<span class="math inline">\(C(\log p)\)</span> 这个级别。</p>
<p>既然这样，建立线段树，维护区间内修改次数最少的块的修改次数，修改时，如果区间内最小修改次数
<span class="math inline">\(\ge\log
p\)</span>，显然可以<code>return</code>，否则继续暴力递归。</p>
<p>暴力修改时需要对每个叶子算出指数塔的值，如果按照<a
href="https://www.luogu.com.cn/problem/P4139">P4139
上帝与集合的正确用法</a>直接做，时间复杂度 <span
class="math inline">\(O(n\log n\log^2 p)\)</span>，过不去。</p>
<p>要继续优化。</p>
<p>观察一下我们在 上帝集合正确用法 中的递归写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(<span class="number">2</span>,<span class="built_in">solve</span>(phi[p])+phi[p],p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的递归只会有 <span class="math inline">\(\log p\)</span>
层，那么对应的模数也只有 <span class="math inline">\(\log p\)</span>
种。</p>
<p>这启发我们预处理。</p>
<p>设 <span class="math inline">\(ph[i]\)</span> 为嵌套了 <span
class="math inline">\(i\)</span> 层的 <span
class="math inline">\(\varphi(p)\)</span>，这就是全部的非 <span
class="math inline">\(1\)</span> 模数。可以预处理 <span
class="math inline">\(c^j\mod ph[i]\)</span> 的值。</p>
<p>但是 <span class="math inline">\(j\)</span> 比较大（因为 <span
class="math inline">\(j\)</span> 是由模数约束的，低层的模数和 <span
class="math inline">\(a,p\)</span> 相关而且同级，<span
class="math inline">\(10^8\)</span>），预处理需要对 <span
class="math inline">\(j\)</span> 根号分治：预处理 <span
class="math inline">\(c1[i][j],c2[i][j]\)</span> 分别表示 <span
class="math inline">\(c^j\mod ph[i]\)</span> 和 <span
class="math inline">\(c^{j\times 10^4}\mod
ph[i]\)</span>，用两个数组拼出真正的 <span
class="math inline">\(j\)</span>，注意要记录是否需要加 <span
class="math inline">\(\varphi(p)\)</span>。</p>
<p>每个线段树节点最多改 <span class="math inline">\(\log p\)</span>
次，每次修改指数塔高度最多 <span class="math inline">\(\log
p\)</span>，总复杂度 <span class="math inline">\(O(\sqrt{p}\log
p+n\log^2 p)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, B = <span class="number">1e4</span>, Lg = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n, m, P, c, a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum, tim;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getphi</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x, t = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(t % i)) &#123;</span><br><span class="line">            res = res * (i - <span class="number">1</span>) / i;</span><br><span class="line">            <span class="keyword">while</span> (!(t % i)) t /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res = res * (t - <span class="number">1</span>) / t;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ph[N], cnt;</span><br><span class="line"><span class="type">int</span> c1[Lg][B + <span class="number">5</span>], c2[Lg][B + <span class="number">5</span>], add1[Lg][B + <span class="number">5</span>], add2[Lg][B + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ph[<span class="number">0</span>] = P;</span><br><span class="line">    <span class="keyword">while</span> (ph[cnt] != <span class="number">1</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        ph[cnt] = <span class="built_in">getphi</span>(ph[cnt - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ph[++cnt] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cnt) &#123;</span><br><span class="line">        c1[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">re</span>(j, B) &#123;</span><br><span class="line">            c1[i][j] = c1[i][j - <span class="number">1</span>] * c;</span><br><span class="line">            add1[i][j] = add1[i][j - <span class="number">1</span>] | (c1[i][j] &gt;= ph[i]);</span><br><span class="line">            c1[i][j] %= ph[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cnt) &#123;</span><br><span class="line">        c2[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">re</span>(j, B) &#123;</span><br><span class="line">            c2[i][j] = c2[i][j - <span class="number">1</span>] * c1[i][B];</span><br><span class="line">            add2[i][j] = add2[i][j - <span class="number">1</span>] | (c2[i][j] &gt;= ph[i]);</span><br><span class="line">            c2[i][j] %= ph[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cpow</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> i, <span class="type">int</span>&amp; flg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v1 = b % B, v2 = b / B, res = c1[i][v1] * c2[i][v2];</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= ph[i]) flg = <span class="number">1</span>;</span><br><span class="line">    flg |= add1[i][v1] | add2[i][v2];</span><br><span class="line">    <span class="keyword">return</span> res % ph[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = a;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; ph[x]) res = res % ph[x] + ph[x];</span><br><span class="line">    <span class="built_in">pe</span>(i, x) &#123;</span><br><span class="line">        <span class="type">int</span> flg = <span class="number">0</span>;</span><br><span class="line">        res = <span class="built_in">cpow</span>(res, i - <span class="number">1</span>, flg);</span><br><span class="line">        <span class="keyword">if</span> (flg) res += ph[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].tim = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].tim, t[<span class="built_in">rs</span>(rt)].tim);</span><br><span class="line">    t[rt].sum = (t[<span class="built_in">ls</span>(rt)].sum + t[<span class="built_in">rs</span>(rt)].sum) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[rt].tim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ml, <span class="type">int</span> mr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[rt].tim &gt;= cnt) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[rt].tim++;</span><br><span class="line">        t[rt].sum = <span class="built_in">calc</span>(a[l], t[rt].tim) % P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">ls</span>(rt), l, mid, ml, mr);</span><br><span class="line">    <span class="keyword">if</span> (mr &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ml, mr);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt].sum;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res = (res + <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, mid, ql, qr)) % P;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res = (res + <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ql, qr)) % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m, P, c);</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(op, l, r);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>欧拉函数</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P3773</title>
    <url>/2024/01/13/P3773/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3773">P3773 [CTSC2017]
吉夫特</a></p>
<span id="more"></span>
<p>组合数与取模，考虑 Lucas 定理。 <span class="math display">\[
\binom{A}{B}=\binom{\frac{A}{2}}{\frac{B}{2}}\binom{A\textrm{ mod
}2}{B\textrm{ mod
}2}=\binom{\frac{A}{4}}{\frac{B}{4}}\binom{\frac{A}{2}\textrm{ mod
}2}{\frac{B}{2}\textrm{ mod }2}\binom{A\textrm{ mod }2}{B\textrm{ mod
}2}\mod 2
\]</span> 容易发现，最终形式变成二进制上每一位之间的组合数之积。</p>
<p>有 <span
class="math inline">\(\dbinom{0}{0}=\dbinom{1}{0}=\dbinom{1}{1}=1,\dbinom{0}{1}=0\)</span>。</p>
<p>所以 <span class="math inline">\(B\)</span> 在二进制上必须是 <span
class="math inline">\(A\)</span> 的子集，不然就会乘 <span
class="math inline">\(0\)</span>。</p>
<p>设 <span class="math inline">\(f(x)\)</span> 为：以 <span
class="math inline">\(x\)</span> 这个数结尾的数列数量。</p>
<p>遍历 <span class="math inline">\(a\)</span>，每次将 <span
class="math inline">\(f(a_i)\)</span> 贡献到 <span
class="math inline">\(f(s),s\in a_i\)</span>，枚举子集即可。</p>
<p>因为有子序列的限制，需要立即将 <span
class="math inline">\(f(a_i)\)</span>
加入答案（不然无法满足定义中的结尾要求），防止后面的贡献混进来。</p>
<p>时间复杂度 <span class="math inline">\(O(3^{\log a})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2.4e5</span>+<span class="number">5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=(a[i]<span class="number">-1</span>)&amp;a[i];s;s=s<span class="number">-1</span>&amp;a[i])&#123;</span><br><span class="line">            f[s]=(f[s]+f[a[i]]+<span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+f[a[i]])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>组合</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title>P3911</title>
    <url>/2024/01/02/P3911/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3911">P3911
最小公倍数之和</a></p>
<span id="more"></span>
<p>记 <span class="math inline">\(C_x\)</span> 为 <span
class="math inline">\(\sum_{i=1}^n[A_i=x]\)</span>，<span
class="math inline">\(L\)</span> 为 <span
class="math inline">\(\max_{i=1}^n A_i\)</span>。 <span
class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^n\textrm{lcm}(A_i,A_j)\\
=&amp;\sum_{i=1}^L\sum_{j=1}^LC_iC_j\times \textrm{lcm}(i,j)\\
=&amp;\sum_{i=1}^L\sum_{j=1}^L\frac{iC_i\times jC_j}{\gcd(i,j)}\\
=&amp;\sum_{i=1}^L\sum_{j=1}^L\sum_{k=1}^L\frac{iC_i\times
jC_j}{k}\times [\gcd(i,j)=k]\\
=&amp;\sum_{k=1}^Lk^2\sum_{i=1}^{\lfloor\frac{L}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{L}{k}\rfloor}\frac{iC_{ik}\times
jC_{jk}}{k}\times [\gcd(i,j)=1]\\
=&amp;\sum_{k=1}^L\sum_{i=1}^{\lfloor\frac{L}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{L}{k}\rfloor}\sum_{d|\gcd(i,j)}\mu(d)\times
iC_{ik}\times jC_{jk}\times k\\
=&amp;\sum_{k=1}^Lk\sum_{d=1}^{\lfloor\frac{L}{k}\rfloor}\mu(d)\times
d^2\sum_{i=1}^{\lfloor\frac{L}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{L}{kd}\rfloor}
iC_{ikd}\times jC_{jkd}\\
=&amp;\sum_{k=1}^Lkd\sum_{kd\le L}\mu(d)\times
d\sum_{i=1}^{\lfloor\frac{L}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{L}{kd}\rfloor}
iC_{ikd}\times jC_{jkd}\\
=&amp;\sum_{T=1}^LT\sum_{d|T}^{L}\mu(d)\times
d\sum_{i=1}^{\lfloor\frac{L}{T}\rfloor}\sum_{j=1}^{\lfloor\frac{L}{T}\rfloor}
iC_{iT}\times jC_{jT}\\
=&amp;\sum_{T=1}^LT\left(\sum_{d|T}^{L}\mu(d)\times
d\right)\sum_{i=1}^{\lfloor\frac{L}{T}\rfloor}iC_{iT}\sum_{j=1}^{\lfloor\frac{L}{T}\rfloor}jC_{jT}\\
=&amp;\sum_{T=1}^LT\left(\sum_{d|T}^{L}\mu(d)\times
d\right)\left(\sum_{i=1}^{\lfloor\frac{L}{T}\rfloor}iC_{iT}\right)^2
\end{aligned}
\]</span> 莫反的经典套路，将枚举的两项 <span
class="math inline">\(i,j\)</span> 拆出公因数 <span
class="math inline">\(k,d\)</span>，然后枚举 <span
class="math inline">\(T=kd\)</span> 并交换求和，使得枚举 <span
class="math inline">\(d\)</span> 的部分和后面 <span
class="math inline">\(i,j\)</span>
部分无关，这样就可以给和式套括号分开算了。</p>
<p>第一个括号预处理，筛出 <span
class="math inline">\(\mu\)</span>，枚举倍数做贡献，复杂度 <span
class="math inline">\(O(L\ln L)\)</span>。</p>
<p>第二个括号直接暴力算，复杂度为 <span class="math inline">\(L\times
\sum_{T=1}^L\lfloor\frac{1}{T}\rfloor=O(L\ln L)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(L\ln L)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,A[N],mu[N],np[N],C[N];</span><br><span class="line">ll F[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prm;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,lim)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i])&#123;</span><br><span class="line">            prm.<span class="built_in">pb</span>(i);</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:prm)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*j&gt;lim)<span class="keyword">break</span>;</span><br><span class="line">            np[i*j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*j]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,lim)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*j&lt;=lim;j++)&#123;</span><br><span class="line">            F[i*j]+=i*mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(N<span class="number">-5</span>);</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> L=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(A[i]);</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">        L=<span class="built_in">max</span>(L,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(T,L)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,L/T)&#123;</span><br><span class="line">            sum+=<span class="number">1ll</span>*i*C[T*i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=T*F[T]*sum*sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>反演</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3973</title>
    <url>/2023/12/26/P3973/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3973">P3973 [TJOI2015]
线性代数</a></p>
<span id="more"></span>
<p>先把具体式子写出来。 <span class="math display">\[
\begin{aligned}
D&amp;=(A\times B-C)\times A^{\mathsf{T}}\\
&amp;=\left(\left(\sum_{j=1}^nA_j\times B_{j,i}\right)-C_i\right)\times
A^{\mathsf{T}}\\
&amp;=\sum_{i=1}^nA_i\left(\sum_{j=1}^nA_j\times B_{j,i}\right)-A_iC_i\\
&amp;=\sum_{i=1}^n\sum_{j=1}^nA_iA_jB_{j,i}-\sum_{i=1}^nA_iC_i
\end{aligned}
\]</span> 可以发现，如果 <span class="math inline">\(A_i,A_j\)</span>
都为 <span class="math inline">\(1\)</span>，会造成 <span
class="math inline">\(B_{i,j}\)</span> 的贡献；如果 <span
class="math inline">\(A_i\)</span> 为 <span
class="math inline">\(1\)</span>，会造成 <span
class="math inline">\(-C_i\)</span> 的贡献。现在要最大化总贡献。</p>
<p>想到网络流。</p>
<p>转一下问题，先让初始贡献 <span class="math inline">\(ans=\sum
B\)</span>，如果 <span class="math inline">\(A_i,A_j\)</span> 不都是
<span class="math inline">\(1\)</span>，减少 <span
class="math inline">\(B_{i,j}\)</span>；如果 <span
class="math inline">\(A_i\)</span> 为 <span
class="math inline">\(1\)</span>，减少 <span
class="math inline">\(C_i\)</span>，最小化减少的值。</p>
<p>经典的，跑最小割，将我们对 <span class="math inline">\(A\)</span>
选择 <span class="math inline">\(0/1\)</span>
的过程变成网络流中对边的选择（割掉的边）。</p>
<p>首先连 <span class="math inline">\(S\to B(i,j)\)</span>，流量为 <span
class="math inline">\(b_{i,j}\)</span>；然后是 <span
class="math inline">\(C(i)\to T\)</span>，流量为 <span
class="math inline">\(c_i\)</span>；最后连接 <span
class="math inline">\(B(i,j)\to C(i),B(i,j)\to C(j)\)</span>，边权为
<span class="math inline">\(+\infty\)</span>。</p>
<p>这么连边的原因是什么？</p>
<p>对于最小割，割一条边可以看作是：这条边对应命题成立了，造成了贡献。不过对于大多数网络流建模来讲，一般会讨论保留一条边要怎样才能合法，而不是割掉一条边要怎样才能合法（合法指图被分割两部分）。</p>
<p>首先，因为中间的容量是 <span
class="math inline">\(+\infty\)</span>，所以割只能割 <span
class="math inline">\(S\to*,*\to T\)</span> 的边。然后做一些讨论，对于
<span class="math inline">\(S\to B(i,j)\)</span> 来讲，如果 <span
class="math inline">\(S\to B(i,j)\)</span> 保留，<span
class="math inline">\(C(i)\to T,C(j)\to T\)</span>
显然一定都要割掉才合法，这符合我们的定义——全 <span
class="math inline">\(1\)</span> 的话 <span
class="math inline">\(-c_i,-c_j\)</span>；如果 <span
class="math inline">\(C(i)\to T\)</span> 保留，<span
class="math inline">\(S\to B(i,*),S\to B(*,i)\)</span>
显然一定都要割掉才合法，这也符合定义——如果 <span
class="math inline">\(c_i=0\)</span>，<span
class="math inline">\(b_{i,*},b_{*,i}\)</span> 的贡献都要减去。</p>
<p>其实，大多数网络流建模中最关键的部分：<span
class="math inline">\(B(i,j)\to C(i)\)</span>
的部分，就是在控制上述的”如果那么“关系。</p>
<p>二分图上 <span
class="math inline">\(\textrm{dinic}\)</span>，时间复杂度约为 <span
class="math inline">\(O(n^{2.5})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>,V=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,b[N][N],c[N],S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">    ll cap;</span><br><span class="line">&#125;e[V*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[V],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    e[ecnt].cap=cap;</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,cap);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> lev[V],cur[V];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(lev,lev+V,inf);</span><br><span class="line">    q.<span class="built_in">push</span>(S);lev[S]=<span class="number">0</span>;</span><br><span class="line">    cur[S]=head[S];</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap&lt;=<span class="number">0</span>||lev[v]!=inf)<span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            lev[v]=lev[u]+<span class="number">1</span>;</span><br><span class="line">            cur[v]=head[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lev[T]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T)<span class="keyword">return</span> fl;</span><br><span class="line">    ll res=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(lev[v]!=lev[u]+<span class="number">1</span>||e[i].cap&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        c=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].cap,fl));</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>)lev[v]=inf;</span><br><span class="line">        fl-=c,e[i].cap-=c,e[i^<span class="number">1</span>].cap+=c,res+=c;</span><br><span class="line">        <span class="keyword">if</span>(fl==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        res+=<span class="built_in">dfs</span>(S,INF);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    S=<span class="number">0</span>,T=<span class="number">1e6</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="built_in">read</span>(b[i][j]);</span><br><span class="line">            ans+=b[i][j];</span><br><span class="line">            <span class="built_in">af</span>(S,(i<span class="number">-1</span>)*n+j,b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">        <span class="built_in">af</span>(n*n+i,T,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="built_in">af</span>((i<span class="number">-1</span>)*n+j,n*n+i,INF);</span><br><span class="line">            <span class="built_in">af</span>((i<span class="number">-1</span>)*n+j,n*n+j,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans-=<span class="built_in">dinic</span>();</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最大流最小割</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>P3964</title>
    <url>/2023/12/02/P3964/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3964">P3964 [TJOI2013]
松鼠聚会</a></p>
<span id="more"></span>
<p>是一个小trick。</p>
<p>观察题目，两点距离的定义其实是 切比雪夫距离，也叫棋盘距离。</p>
<p>考虑暴力怎么做：枚举 <span class="math inline">\(j\)</span>，求 <span
class="math inline">\(\min\sum_{i=1}^ndis((x_i,y_i),(x_j,y_j))\)</span>。</p>
<p>枚举 <span class="math inline">\(j\)</span>
很难优化，考虑优化求和。</p>
<p>切比雪夫距离很难快速求和，但可以转化为 曼哈顿距离。</p>
<blockquote>
<p>曼哈顿坐标系是通过切比雪夫坐标系旋转 <span
class="math inline">\(45\degree\)</span>
后，缩小到原来的一半得到的。</p>
<p>将一个点 <span class="math inline">\((x,y)\)</span> 的坐标转化为
<span class="math inline">\((x+y,x-y)\)</span>
后，原坐标系中曼哈顿距离等于新坐标系中切比雪夫距离。</p>
<p>将一个点 <span class="math inline">\((x,y)\)</span> 的坐标转化为
<span class="math inline">\((\frac{x+y}{2},\frac{x-y}{2})\)</span>
后，原坐标系中切比雪夫距离等于新坐标系中曼哈顿距离。</p>
</blockquote>
<p>我们可以将 <span class="math inline">\((x,y)\)</span> 都转为 <span
class="math inline">\((\frac{x+y}{2},\frac{x-y}{2})\)</span>，但是小数容易有精度误差，所以可以转为
<span class="math inline">\((x+y,x-y)\)</span> 后再对距离之和除 <span
class="math inline">\(2\)</span>。</p>
<p>对曼哈顿距离的求和是很好做的。</p>
<p>拆绝对值就完事了。</p>
<p>拆出来 <span
class="math inline">\(\sum\limits_{i=1}^n|x_i-x_j|+\sum\limits_{i=1}^n|y_i-y_j|\)</span></p>
<p>将 <span class="math inline">\(x,y\)</span> 排序，二分找到分界点
<span class="math inline">\(p_x,p_y\)</span>。</p>
<p>式子变成 <span class="math inline">\(\sum\limits_{i=1}^{p_x}
x_j-x_i+\sum\limits_{i=p_x+1}^nx_i-x_j\)</span>，<span
class="math inline">\(y\)</span> 同理。</p>
<p>对排序后的数组求前缀和 <span
class="math inline">\(sx,sy\)</span>。</p>
<p>上面的和式转化为 <span class="math inline">\(x_j\times
p_x-sx_{p_x}+sx_n-sx_{p_x}-x_j\times(n-p_x)\)</span>，<span
class="math inline">\(y\)</span> 同理。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,x[N],y[N],bax[N],bay[N];</span><br><span class="line">ll sumx[N],sumy[N];</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rx=<span class="built_in">lower_bound</span>(bax+<span class="number">1</span>,bax+n+<span class="number">1</span>,x[i])-bax;</span><br><span class="line">    <span class="type">int</span> ry=<span class="built_in">lower_bound</span>(bay+<span class="number">1</span>,bay+n+<span class="number">1</span>,y[i])-bay;</span><br><span class="line">    <span class="keyword">return</span> rx*<span class="number">1ll</span>*x[i]-sumx[rx]-(n-rx)*<span class="number">1ll</span>*x[i]+sumx[n]-sumx[rx]+</span><br><span class="line">        ry*<span class="number">1ll</span>*y[i]-sumy[ry]-(n-ry)*<span class="number">1ll</span>*y[i]+sumy[n]-sumy[ry];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> xi=<span class="number">0</span>,yi=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(xi,yi);</span><br><span class="line">        x[i]=bax[i]=xi+yi;</span><br><span class="line">        y[i]=bay[i]=xi-yi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(bax+<span class="number">1</span>,bax+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        sumx[i]=sumx[i<span class="number">-1</span>]+bax[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(bay+<span class="number">1</span>,bay+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        sumy[i]=sumy[i<span class="number">-1</span>]+bay[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">calc</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    ans/=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>距离相关</tag>
      </tags>
  </entry>
  <entry>
    <title>P3991</title>
    <url>/2023/12/07/P3991/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3991">P3991 [BJOI2017]
喷式水战改</a></p>
<span id="more"></span>
<p>可以看作是平衡树维护<code>DDP</code>的模板。</p>
<p>题意：维护一个数列，数列支持在某位置插入一段长为 <span
class="math inline">\(x\)</span>
的相同的数，每次插入后求数列最大权值，权值定义为：将数列划分为四个可以为空的部分，每个数在四个部分内的权值分别为
<span
class="math inline">\(a_i,b_i,c_i,a_i\)</span>，所有数的权值之和。</p>
<p>如果直接维护数列，总长度高达 <span class="math inline">\(O(\sum
x)\)</span>，无法接受。</p>
<p>所以要将相同的段都缩成一个点，显然相同的段肯定会被放在同一部分内。</p>
<p>当然是要对这些段 <code>DP</code>，但是还要支持插入。</p>
<p>考虑平衡树维护动态 <code>DP</code>。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为：前 <span
class="math inline">\(i\)</span> 个段，第 <span
class="math inline">\(i\)</span> 段在整体的第 <span
class="math inline">\(1/2/3/4\)</span>
部分的最大收益，容易得到转移式子：</p>
<p><span class="math display">\[
f[i][j]=\max_{k\le j\le 4}f[i-1][k]+v_{i,j}
\]</span></p>
<p><span class="math inline">\(v_{i,j}\)</span> 为 <span
class="math inline">\(i\)</span> 在第 <span
class="math inline">\(j\)</span> 部分的贡献。</p>
<p>这个式子非常符合我们的要求。</p>
<p>容易构造如下矩阵，<code>max</code>乘即可。</p>
<p><span class="math display">\[
\begin{bmatrix}
v_{i,0}&amp;v_{i,1}&amp;v_{i,2}&amp;v_{i,3}\\
-\infty&amp;v_{i,1}&amp;v_{i,2}&amp;v_{i,3}\\
-\infty&amp;-\infty&amp;v_{i,2}&amp;v_{i,3}\\
-\infty&amp;-\infty&amp;-\infty&amp;v_{i,3}
\end{bmatrix}
\]</span></p>
<p>用文艺<code>fhq-Treap</code>维护子树内的答案矩阵，插入的时候判断是否切断了另一个段，如果切断了就再<code>split</code>一次，最后全部<code>merge</code>上即可。</p>
<p>关于复杂度：每次加入一个新的段，最多会使总段数增加两个，每次插入只新增
<span class="math inline">\(O(1)\)</span> 个段，总复杂度 <span
class="math inline">\(O(n\log n\times w^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span>&#123;</span><br><span class="line">    ll m[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">Mat</span>()&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            m[i][j]=-INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat <span class="keyword">operator</span>*(Mat b)&#123;</span><br><span class="line">        Mat c;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            c.m[i][j]=<span class="built_in">max</span>(c.m[i][j],m[i][k]+b.m[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> BT&#123;</span><br><span class="line">    Mat t[N],ori[N];</span><br><span class="line">    ll siz[N],val[N];</span><br><span class="line">    mt19937 rnd;</span><br><span class="line">    <span class="type">int</span> rt,ncnt,ch[N][<span class="number">2</span>],rk[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> r=++ncnt;</span><br><span class="line">        t[r].m[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1ll</span>*x*a;</span><br><span class="line">        t[r].m[<span class="number">0</span>][<span class="number">1</span>]=t[r].m[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1ll</span>*x*b;</span><br><span class="line">        t[r].m[<span class="number">0</span>][<span class="number">2</span>]=t[r].m[<span class="number">1</span>][<span class="number">2</span>]=t[r].m[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1ll</span>*x*c;</span><br><span class="line">        t[r].m[<span class="number">0</span>][<span class="number">3</span>]=t[r].m[<span class="number">1</span>][<span class="number">3</span>]=t[r].m[<span class="number">2</span>][<span class="number">3</span>]=t[r].m[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1ll</span>*x*a;</span><br><span class="line">        val[r]=siz[r]=x,rk[r]=<span class="built_in">rnd</span>(),ori[r]=t[r];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> r=++ncnt;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,i,<span class="number">3</span>)&#123;</span><br><span class="line">            t[r].m[i][j]=ori[x].m[i][j]/val[x]*now;</span><br><span class="line">        &#125;</span><br><span class="line">        val[r]=siz[r]=now,rk[r]=<span class="built_in">rnd</span>(),ori[r]=t[r];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        siz[x]=siz[<span class="built_in">ls</span>(x)]+siz[<span class="built_in">rs</span>(x)]+val[x];</span><br><span class="line">        t[x]=ori[x];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ls</span>(x))t[x]=t[<span class="built_in">ls</span>(x)]*t[x];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rs</span>(x))t[x]=t[x]*t[<span class="built_in">rs</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pii <span class="title">split</span><span class="params">(<span class="type">int</span> x,ll s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(siz[<span class="built_in">ls</span>(x)]+val[x]&gt;s)&#123;</span><br><span class="line">            pii t=<span class="built_in">split</span>(<span class="built_in">ls</span>(x),s);</span><br><span class="line">            <span class="built_in">ls</span>(x)=t.se,<span class="built_in">pushup</span>(x);</span><br><span class="line">            <span class="keyword">return</span> &#123;t.fi,x&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        pii t=<span class="built_in">split</span>(<span class="built_in">rs</span>(x),s-siz[<span class="built_in">ls</span>(x)]-val[x]);</span><br><span class="line">        <span class="built_in">rs</span>(x)=t.fi,<span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> &#123;x,t.se&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u||!v)<span class="keyword">return</span> u+v;</span><br><span class="line">        <span class="keyword">if</span>(rk[u]&gt;rk[v])<span class="keyword">return</span> <span class="built_in">rs</span>(u)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(u),v),<span class="built_in">pushup</span>(u),u;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ls</span>(v)=<span class="built_in">merge</span>(u,<span class="built_in">ls</span>(v)),<span class="built_in">pushup</span>(v),v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ls</span>(u))u=<span class="built_in">ls</span>(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> BT::rt,BT::merge;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ll pre=<span class="number">0</span>,ans=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p,a,b,c,x);</span><br><span class="line">        pii t=BT::<span class="built_in">split</span>(rt,p);</span><br><span class="line">        <span class="keyword">if</span>(BT::siz[t.fi]==p)&#123;</span><br><span class="line">            <span class="type">int</span> u=BT::<span class="built_in">newnode</span>(a,b,c,x);</span><br><span class="line">            rt=<span class="built_in">merge</span>(t.fi,<span class="built_in">merge</span>(u,t.se));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-=BT::siz[t.fi];</span><br><span class="line">            <span class="type">int</span> u=BT::<span class="built_in">newnode</span>(a,b,c,x),v=BT::<span class="built_in">getmin</span>(t.se),y=BT::val[v];</span><br><span class="line">            pii o=BT::<span class="built_in">split</span>(t.se,y);</span><br><span class="line">            rt=<span class="built_in">merge</span>(t.fi,<span class="built_in">merge</span>(<span class="built_in">merge</span>(<span class="built_in">merge</span>(BT::<span class="built_in">change</span>(v,p),u),BT::<span class="built_in">change</span>(v,y-p)),o.se));</span><br><span class="line">        &#125;</span><br><span class="line">        ans=-INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,BT::t[rt].m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(ans-pre,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        pre=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>动态DP</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4001</title>
    <url>/2023/12/11/P4001/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4001">P4001 [ICPC-Beijing
2006] 狼抓兔子</a></p>
<span id="more"></span>
<p>一定程度上的板子题。</p>
<p>以兔子个数为容量，是一个裸的最小割。</p>
<p>边数过多。</p>
<p>显然没有常规减少边数的方式。</p>
<p>这是个平面图，建平面图的对偶图，有一个结论：</p>
<p>对偶图上 <span class="math inline">\(s\to t\)</span>
的每一条路径对应平面图的一个割，对偶图上 <span
class="math inline">\(s\to t\)</span> 的最短路等于平面图的最小割。</p>
<p>关于对偶图：将平面图的每一个面作为一个点，如果两个面相邻，就在两个面之间建边，边权为原图邻边边权，如果一个边的两边是同一个面，那就连一个自环。</p>
<p>注意，在“最小割转对偶图最短路”的实际应用中，一般都将原图外部的这个面切成两半，比如一个网格图，可能会以对角线将图的外部分成“左下，右上”两部分，分别作为
<span class="math inline">\(s,t\)</span>，显然这里 <span
class="math inline">\(s,t\)</span> 之间不能连边。</p>
<p>建出对偶图之后跑最短路就好了，建边比较恶心。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,st,ed;</span><br><span class="line">vector&lt;pii&gt; G[N];</span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[st]=<span class="number">0</span>;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">tie</span>(f,u)=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(dis[u]!=f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    ed=(<span class="number">2</span>*n<span class="number">-2</span>)*(m<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        G[i*<span class="number">2</span>].<span class="built_in">pb</span>(&#123;ed,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            u=<span class="number">2</span>*(i<span class="number">-2</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>+<span class="number">2</span>*j;</span><br><span class="line">            v=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+<span class="number">2</span>*j;</span><br><span class="line">            G[u].<span class="built_in">pb</span>(&#123;v,x&#125;);</span><br><span class="line">            G[v].<span class="built_in">pb</span>(&#123;u,x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        u=<span class="number">2</span>*(n<span class="number">-2</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>+<span class="number">2</span>*i;</span><br><span class="line">        G[st].<span class="built_in">pb</span>(&#123;u,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            u=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>+<span class="number">2</span>*j;</span><br><span class="line">            v=u<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)G[st].<span class="built_in">pb</span>(&#123;u,x&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==m)G[v].<span class="built_in">pb</span>(&#123;ed,x&#125;);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                G[u].<span class="built_in">pb</span>(&#123;v,x&#125;);</span><br><span class="line">                G[v].<span class="built_in">pb</span>(&#123;u,x&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            u=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>+<span class="number">2</span>*j;</span><br><span class="line">            v=u+<span class="number">1</span>;</span><br><span class="line">            G[u].<span class="built_in">pb</span>(&#123;v,x&#125;);</span><br><span class="line">            G[v].<span class="built_in">pb</span>(&#123;u,x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    <span class="built_in">write</span>(dis[ed],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最大流最小割</tag>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>平面图</tag>
      </tags>
  </entry>
  <entry>
    <title>P4052</title>
    <url>/2023/12/14/P4052/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4052">P4052 [JSOI2007]
文本生成器</a></p>
<span id="more"></span>
<blockquote>
<p>ACAM
除了能够进行字符串匹配，还常与动态规划相结合，因为它精确刻画了文本串与<strong>所有</strong>模式串的匹配情况。同时，自动机中
<span class="math inline">\(\delta\)</span>
函数自然地为动态规划的转移指明了方向。因此，当遇到形如
“不能出现若干单词” 的字符串<strong>计数或最优化</strong>问题，可以考虑在
ACAM 上 DP，将 ACAM 的状态写进 DP 的一个维度。</p>
</blockquote>
<p>自动机上DP，算经典题。</p>
<p>首先容斥一步，至少含有一个的串个数不好计算，转为总个数减去一个都没有的串个数，称这样的串为合法串。</p>
<p>将所有串插入AC自动机，处理出 <span
class="math inline">\(tag[i]\)</span>：Trie上 <span
class="math inline">\(i\)</span>
代表的字符串是否是<strong>非法串</strong>，建自动机BFS时，需要对 <span
class="math inline">\(tag\)</span> 更新：如果 <span
class="math inline">\(fail[u]\)</span> 非法，因为 <span
class="math inline">\(fail[u]\)</span> 串是 <span
class="math inline">\(u\)</span> 串的后缀，所以 <span
class="math inline">\(u\)</span> 也非法，<span
class="math inline">\(tag[fail[u]]\to tag[u]\)</span>，<span
class="math inline">\(fail\)</span>
树显然是一个DAG，在DAG上BFS处理，处理的顺序一定是先 <span
class="math inline">\(fail[u]\)</span> 再 <span
class="math inline">\(u\)</span>，无后效性。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span>：长为 <span
class="math inline">\(i\)</span>，在AC自动机内处于状态 <span
class="math inline">\(j\)</span>，且是合法串的字符串数量，转移时枚举下一个字符
<span class="math inline">\(c\)</span>，如果更新后的 <span
class="math inline">\(tag[\delta(j,c)]\)</span> 依旧合法，做 <span
class="math inline">\(f[i][j]\to f[i+1][\delta(j,c)]\)</span>
的转移。</p>
<p>答案为 <span
class="math inline">\(26^m-\sum_{i}f[m][i]\)</span>，<span
class="math inline">\(i\)</span> 为自动机上每个状态。</p>
<p>也是一种 DP套DP，本质相同，都是内层自动机，外层 <span
class="math inline">\(F(i,*)\to F(\delta(i,c),*&#39;)\)</span>
的一类DP。</p>
<p>时间复杂度 <span class="math inline">\(O(m\sum |s_i|\times
|\Sigma|)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">65</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">105</span>)</span>,<span class="title">mod</span><span class="params">(<span class="number">1e4</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> ch[N*M][<span class="number">26</span>],ncnt=<span class="number">1</span>,tag[N*M],fa[N*M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,len)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][c])ch[p][c]=++ncnt;</span><br><span class="line">        p=ch[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,<span class="number">26</span>)ch[<span class="number">0</span>][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">            <span class="type">int</span> &amp;v=ch[u][i];</span><br><span class="line">            <span class="keyword">if</span>(v)&#123;</span><br><span class="line">                fa[v]=ch[fa[u]][i];</span><br><span class="line">                tag[v]|=tag[fa[v]];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> v=ch[fa[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[M][N*M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,ncnt)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(c,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tag[ch[j][c]])<span class="keyword">continue</span>;</span><br><span class="line">                f[i][ch[j][c]]=(f[i][ch[j][c]]+f[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*<span class="number">26</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,ncnt)&#123;</span><br><span class="line">        ans=(ans-f[m][i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
        <tag>DFA-DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P4072</title>
    <url>/2023/12/04/P4072/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4072">P4072 [SDOI2016]
征途</a></p>
<span id="more"></span>
<p>题意：将数列划分为 <span class="math inline">\(m\)</span> 段，设第
<span class="math inline">\(i\)</span> 段之和为 <span
class="math inline">\(x_i\)</span>，最小化 <span
class="math inline">\(m^2\times \sum_{i=1}^m\frac{(\overline x
-x_i)^2}{m}\)</span></p>
<p>当然要拆式子，设 <span class="math inline">\(S=\sum_{i=1}^m
x_i\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;m^2\times \sum_{i=1}^m\frac{(\overline x -x_i)^2}{m}\\
=&amp;m\times \sum_{i=1}^m\overline x^2 -2\overline xx_i+x_i^2\\
=&amp;m\left(\sum_{i=1}^m\overline x^2-2\sum_{i=1}^m\overline
xx_i+\sum_{i=1}^mx_i^2\right)\\
=&amp;m\left(\sum_{i=1}^m\left(\frac{S}{m}\right)^2-2\sum_{i=1}^m\frac{S}{m}x_i+\sum_{i=1}^mx_i^2\right)\\
=&amp;\sum_{i=1}^m\frac{S^2}{m}-2S\sum_{i=1}^mx_i+m\sum_{i=1}^mx_i^2\\
=&amp;m\sum_{i=1}^mx_i^2-S^2
\end{aligned}
\]</span></p>
<p>现在考虑怎么DP。</p>
<p>将数列划分为若干段，广为人知的做法是 <span
class="math inline">\(f[i][j]\)</span> 为 前 <span
class="math inline">\(j\)</span> 个划分了 <span
class="math inline">\(i\)</span>
段，转移时枚举最后一段的左端点，这种思想适用于很多算法。</p>
<p><span class="math inline">\(f\)</span> 只处理式子中 <span
class="math inline">\(\sum_{i=1}^mx_i^2\)</span> 的部分。</p>
<p>先写暴力式子，设 <span class="math inline">\(s_i=\sum_{j=1}^i
a_j\)</span>。</p>
<p><span class="math display">\[
f[i][j]=\min_{k=1}^{j-1}f[i-1][k-1]+(s_i-s_{k-1})^2
\]</span></p>
<p>如何优化这个过程？这个式子看起来很凸。</p>
<p>考虑什么情况下从 <span class="math inline">\(f[i-1][p]\)</span>
转移比 <span class="math inline">\(f[i-1][q]\)</span> 更优。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i-1][p]+(s_i-s_p)^2&lt;f[i-1][q]+(s_i-s_q)^2\\
&amp;f[i-1][p]-2s_is_p+s_p^2&lt;f[i-1][q]-2s_is_q+s_q^2\\
&amp;(f[i-1][p]+s_p^2)-(f[i-1][q]+s_q^2)&lt;2s_i(s_p-s_q)\\
&amp;\frac{(f[i-1][p]+s_p^2)-(f[i-1][q]+s_q^2)}{s_p-s_q}&lt;2s_i\\
&amp;\frac{f(p)-f(q)}{p-q}&lt;k
\end{aligned}
\]</span></p>
<p>顺利变成了斜率形式。单调队列维护下凸壳，直接做就行了，可以说是板子。</p>
<p>最后答案是 <span class="math inline">\(m\times
f[m][n]-S^2\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>这个题也可以 <code>wqs</code> 二分，但是我们需要的斜率 <span
class="math inline">\(2s_i\)</span> 单调递增，所以写 <code>wqs</code>
比较大材小用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3005</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],q[N],h,t;</span><br><span class="line">ll sum[N],f[N][N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> q,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(f[u][p]-f[u][q]+sum[p]*sum[p]-sum[q]*sum[q])/(<span class="type">double</span>)(sum[p]-sum[q]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[<span class="number">1</span>][i]=sum[i]*sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(j,<span class="number">2</span>,m)&#123;</span><br><span class="line">        h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">slope</span>(j<span class="number">-1</span>,q[h],q[h+<span class="number">1</span>])&lt;<span class="number">2</span>*sum[i])&#123;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">            f[j][i]=f[j<span class="number">-1</span>][q[h]]+(sum[q[h]]-sum[i])*(sum[q[h]]-sum[i]);</span><br><span class="line">            <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">slope</span>(j<span class="number">-1</span>,q[t<span class="number">-1</span>],q[t])&gt;<span class="built_in">slope</span>(j<span class="number">-1</span>,q[t],i))&#123;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++t]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=m*f[m][n]-sum[n]*sum[n];</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P4112</title>
    <url>/2024/01/15/P4112/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4112">P4112 [HEOI2015]
最短不公共子串</a></p>
<span id="more"></span>
<p>四合一。</p>
<p>对于第一问，考虑后缀自动机。</p>
<p>众所周知，如果 <span class="math inline">\(T\)</span> 是 <span
class="math inline">\(S\)</span> 的子串，那么在 <span
class="math inline">\(S\)</span> 的后缀自动机的 <span
class="math inline">\(\textrm{DAG}\)</span>
上，存在从“根”走出的一条路径，使得路径字符串为 <span
class="math inline">\(T\)</span>。<span class="math inline">\(T\)</span>
不是 <span class="math inline">\(S\)</span>
子串的判定是逆命题：没有任何一条这样的路径。</p>
<p>根据后缀自动机的最小性，<span class="math inline">\(T\)</span>
的路径若出现，只会出现一次。若 <span class="math inline">\(T\)</span>
存在，而与它图上相邻的 <span class="math inline">\(T+c\)</span>
不存在，那 <span class="math inline">\(T+c\)</span>
在整个图中就不存在。</p>
<p>也就是说，只需要在 <span class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>
的后缀自动机上同步移动，用广搜实现移动过程，每次拓展到当前点的每一个相邻点（加一个边上字符），如果这个字符在
<span class="math inline">\(a\)</span> 的自动机上存在而不在 <span
class="math inline">\(b\)</span>
的自动机中，说明我们找到了答案，因为广搜第一次搜到的一定距离最短，直接输出当前移动的步数即可。</p>
<p>注意广搜的 <code>vis</code>
数组需要记录两个状态，也可以理解为一个“二维”的“自动机”。</p>
<p>那子序列怎么做呢？有一个叫做 子序列自动机
的结构，拥有和后缀自动机几乎一模一样的性质。</p>
<p>处理此题的过程中是本质相同的，都是在 <span
class="math inline">\(\textrm{DAG}\)</span>
上广搜，甚至不需要改代码。</p>
<p>跑四次广搜即可，写好封装代码很短，注意清空 <code>vis</code>。</p>
<p>因为每次拓展的时候需要遍历字符集，复杂度 <span
class="math inline">\(O(|a||b||\Sigma|)\)</span>。</p>
<p>代码中子序列自动机的 <code>build</code>
过程是暴力的平方做法，实际上有线性对数的优秀做法，瓶颈不在这里懒得写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4005</span>;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Automaton</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Sgm;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; go[N];</span><br><span class="line">    <span class="type">int</span> ncnt;</span><br><span class="line">    <span class="built_in">Automaton</span>(<span class="type">int</span> Sgm_):<span class="built_in">Sgm</span>(Sgm_)&#123;</span><br><span class="line">        ncnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        go[++ncnt]=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(Sgm,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SufAM</span>:Automaton&#123;</span><br><span class="line">    <span class="type">int</span> len[N],lnk[N],las;</span><br><span class="line">    <span class="built_in">SufAM</span>(<span class="type">int</span> Sgm_):<span class="built_in">Automaton</span>(Sgm_)&#123;</span><br><span class="line">        las=<span class="built_in">newnode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> q=go[p][c],nq=<span class="built_in">newnode</span>();</span><br><span class="line">        lnk[nq]=lnk[q],lnk[q]=nq,len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">        go[nq]=go[q];</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;go[p][c]==q)&#123;</span><br><span class="line">            go[p][c]=nq,p=lnk[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p=las;</span><br><span class="line">        <span class="keyword">if</span>(go[p][c])&#123;</span><br><span class="line">            <span class="keyword">if</span>(len[go[p][c]]==len[p]+<span class="number">1</span>)<span class="keyword">return</span> go[p][c];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">split</span>(p,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> np=<span class="built_in">newnode</span>();</span><br><span class="line">        len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!go[p][c])&#123;</span><br><span class="line">            go[p][c]=np,p=lnk[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p)lnk[np]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(len[go[p][c]]==len[p]+<span class="number">1</span>)&#123;</span><br><span class="line">                lnk[np]=go[p][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> lnk[np]=<span class="built_in">split</span>(p,c);</span><br><span class="line">        &#125;</span><br><span class="line">        las=np;</span><br><span class="line">        <span class="keyword">return</span> np;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SeqAM</span>:Automaton&#123;</span><br><span class="line">    <span class="built_in">SeqAM</span>(<span class="type">int</span> Sgm_):<span class="built_in">Automaton</span>(Sgm_)&#123;</span><br><span class="line">        <span class="built_in">newnode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">newnode</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t<span class="number">-1</span>;i&amp;&amp;!go[i][c];i--)&#123;</span><br><span class="line">            go[i][c]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">SufAM <span class="title">sufa</span><span class="params">(<span class="number">26</span>)</span>,<span class="title">sufb</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line"><span class="function">SeqAM <span class="title">seqa</span><span class="params">(<span class="number">26</span>)</span>,<span class="title">seqb</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> vis[N][N];</span><br><span class="line">queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">const</span> Automaton &amp;a,<span class="type">const</span> Automaton &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">tie</span>(x,y,d)=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!y)<span class="keyword">return</span> d;</span><br><span class="line">        <span class="built_in">rep</span>(c,<span class="number">0</span>,a.Sgm<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.go[x][c])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a.go[x][c]][b.go[y][c]])&#123;</span><br><span class="line">                vis[a.go[x][c]][b.go[y][c]]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;a.go[x][c],b.go[y][c],d+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;(a+<span class="number">1</span>)&gt;&gt;(b+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a+<span class="number">1</span>),m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    sufa.<span class="built_in">build</span>(a,n);</span><br><span class="line">    sufb.<span class="built_in">build</span>(b,m);</span><br><span class="line">    seqa.<span class="built_in">build</span>(a,n);</span><br><span class="line">    seqb.<span class="built_in">build</span>(b,m);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">work</span>(sufa,sufb)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">work</span>(sufa,seqb)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">work</span>(seqa,sufb)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">work</span>(seqa,seqb)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
        <tag>子序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P4151</title>
    <url>/2023/12/02/P4151/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4151">P4151 [WC2011]
最大XOR和路径</a></p>
<span id="more"></span>
<p>题意非常简明：求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最大异或路径和。</p>
<p>很重要的一点：这是个联通无向图。</p>
<p>发现我们从 <span class="math inline">\(1\)</span> 走到 <span
class="math inline">\(n\)</span> 的路径可以看做：走了一条 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
单向的路径，然后在单向路径上多次进行：向外走到某个环，在环上绕一圈再原路返回。</p>
<p>我们只关心对异或和有贡献的部分，发现有贡献的只有经过一次的边——也就是那些环和中间这条路径。</p>
<p>问题被极大的简化。</p>
<p>我们在树上找到所有简单环（只有一条返祖边），用异或和差分出每个环的权值，塞到线性基里。</p>
<p>注：可以发现，多条返祖边之间各种连接的“复杂环”都能通过这些简单环异或得到。</p>
<p>环的部分解决了：用线性基求最大异或子集和。</p>
<p>问题在于，中间的单向路径怎么选。</p>
<p>有一个很巧妙的想法：中间这条路径其实并不重要。</p>
<p>因为所有单向路径的起点和终点都是和，也就是说，可以用任意两个合法的路径拼成一个环。</p>
<p>而所有的环我们都塞到线性基里了，任意一个路径都可以通过异或某一个大环得到另一个合法路径。所以任选一个路径即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log
D)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e4</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">lgD</span><span class="params">(<span class="number">70</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">ll path[N];</span><br><span class="line">ll num[lgD];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">63</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!num[i])&#123;</span><br><span class="line">                num[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x^=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getMax</span><span class="params">(ll num0)</span></span>&#123;</span><br><span class="line">    ll res=num0;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">63</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,res^num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll now)</span></span>&#123;</span><br><span class="line">    path[u]=now,vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,now^e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">insert</span>(now^path[v]^e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    ll w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="built_in">getMax</span>(path[n]);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>P4198</title>
    <url>/2023/12/13/P4198/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4198">P4198
楼房重建</a></p>
<span id="more"></span>
<p>此类“ <code>pushup</code> 的时候做查询”的写法被用来解决线段树
<code>pushup</code>
过程中，左右儿子有信息上互相依赖，且难以将全部信息放到节点上的问题。</p>
<p>首先答案和直线 <span class="math inline">\((0,0)(x,y)\)</span>
的斜率相关，设斜率为 <span
class="math inline">\(s\)</span>，答案就是强制以 <span
class="math inline">\(s_1\)</span> 开头的，全局最长上升子序列。</p>
<p>考虑线段树，维护区间最大值和区间上升子序列长度。</p>
<p>发现左右儿子做拼接的时候需要考虑接口处问题——两个上升子序列不一定能接上。</p>
<p>所以 <code>pushup</code> 时，以左儿子区间最大值 <span
class="math inline">\(mx\)</span>
为根据，在右儿子中<strong>递归</strong>查询强制以 <span
class="math inline">\(mx\)</span>
开头的最长上升子序列长度，再加上左儿子已经算好的即可。</p>
<p>具体查询方式见代码。</p>
<p>由于每次 <code>pushup</code> 还要查询一次，时间复杂度为 <span
class="math inline">\(O(q\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,Q;</span><br><span class="line"><span class="type">double</span> slp[N];</span><br><span class="line"><span class="keyword">namespace</span> SegT&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">double</span> mx;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>)t[rt].len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> slp[l]&gt;k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mx&lt;=k)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,k)+t[rt].len-t[<span class="built_in">ls</span>(rt)].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].len=t[<span class="built_in">ls</span>(rt)].len+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),(l+r)/<span class="number">2</span>+<span class="number">1</span>,r,t[<span class="built_in">ls</span>(rt)].mx);</span><br><span class="line">        t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">double</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mx=k,t[rt].len=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,k);</span><br><span class="line">        <span class="built_in">pushup</span>(rt,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;Q;</span><br><span class="line">    SegT::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        slp[x]=(y*<span class="number">1.0</span>)/x;</span><br><span class="line">        SegT::<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,n,x,slp[x]);</span><br><span class="line">        cout&lt;&lt;SegT::t[<span class="number">1</span>].len<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4211</title>
    <url>/2023/12/02/P4211/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4211">P4211 [LNOI2014]
LCA</a></p>
<span id="more"></span>
<p>题目求：<span
class="math inline">\(\sum\limits_{i=l}^rdep[lca(i,z)]\)</span>。</p>
<p>首先发现：没有强制在线，<span class="math inline">\([l,r]\)</span>
内的点在树上分布没有规律，尝试在点编号上前缀和-差分，但 <span
class="math inline">\(z\)</span> 的问题没有解决。</p>
<p>如果只是一个二维的问题 <span
class="math inline">\(f(l,r)\)</span>，可以转为 <span
class="math inline">\(F(r)-F(l-1)\)</span>
在一维内快速解决，但是问题是三维的。</p>
<p>前两维依然做前缀和-差分，第三维扔进<code>DS</code>。用数据结构的每一个“位置”对应当前前缀
<span class="math inline">\(pos\)</span> 的每一个 <span
class="math inline">\(z\)</span>，快速对每个 <span
class="math inline">\(z\)</span> 做 <span
class="math inline">\(F(pos-1,z)\)</span> 到 <span
class="math inline">\(F(pos,z)\)</span> 的转移。</p>
<p>显然要满足：在 <span class="math inline">\(pos\)</span>
这一维上修改，在 <span class="math inline">\(z\)</span> 上需要查询。</p>
<p>不太好直接做啊。</p>
<p>转化问题，考虑一种“拆贡献”：把 <span
class="math inline">\(dep[i]\)</span> 拆了。转化成 <span
class="math inline">\(i\)</span> 到根的点做点权 <span
class="math inline">\(+1\)</span>（废话）</p>
<p>问题转化为在 <span class="math inline">\(z\)</span> 到根的路径上
<span class="math inline">\(+1\)</span>，求 <span
class="math inline">\(i\)</span> 到根的权值和之和，<span
class="math inline">\(i\in[l,r]\)</span></p>
<p>再做一步转化，进一步发现，这个问题和另一个问题等价：<span
class="math inline">\(l\)</span> 到 <span
class="math inline">\(r\)</span> 的每一个点，到根的路径上 <span
class="math inline">\(+1\)</span>，求 <span
class="math inline">\(z\)</span> 到根的权值和。</p>
<p>现在终于得到了好做的东西，满足了快速转移 <span
class="math inline">\(F\)</span> 的条件。</p>
<p>把询问全部离线，在 <span class="math inline">\(r\)</span>
上放一个正标记 <span class="math inline">\(z\)</span>，<span
class="math inline">\(l-1\)</span> 上放一个负标记 <span
class="math inline">\(z\)</span>（差分），用线段树+树剖维护当前的 <span
class="math inline">\(pos\)</span>，每个 <span
class="math inline">\(z\)</span> 的状态 <span
class="math inline">\(F(pos,z)\)</span>。</p>
<p>每次对 <span class="math inline">\(pos\)</span> 到根上路径全部 <span
class="math inline">\(+1\)</span>，相当于做了 <span
class="math inline">\(\forall z,F(pos-1,z)\to F(pos,z)\)</span>
，扫到标记就给对应的询问加上正或负的贡献。</p>
<p>非常的好做啊。</p>
<p>总时间复杂度 <span class="math inline">\(O((n+q)\log^2
n)\)</span>，可以通过。</p>
<p>在数据结构部分还有优化空间：只有链修改，全局平衡二叉树可以做到小常数的
<span class="math inline">\(O((n+q)\log
n)\)</span>，非常牛啊，摆了不想写。</p>
<p>点编号从 <span class="math inline">\(0\)</span> 开始，代码里都加了
<span class="math inline">\(1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e4</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">201314</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N],hson[N],top[N],idx[N],dfn[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp,idx[u]=++dfncnt;</span><br><span class="line">    dfn[dfncnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(hson[u]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==hson[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCP</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum,lz,len;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].sum=t[<span class="built_in">ls</span>(rt)].sum+t[<span class="built_in">rs</span>(rt)].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].len=r-l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].sum+=v*t[rt].len;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">            t[rt].lz=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].sum;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res+=<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res+=<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modPath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[u],val);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qryPath</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            res+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[u]);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> ans[N],ask[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; L[N],R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(fa[i]);</span><br><span class="line">        fa[i]++;</span><br><span class="line">        <span class="built_in">ae</span>(fa[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l,r,ask[i]);</span><br><span class="line">        L[l].<span class="built_in">pb</span>(i);</span><br><span class="line">        R[r+<span class="number">1</span>].<span class="built_in">pb</span>(i);</span><br><span class="line">        ask[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        t.<span class="built_in">modPath</span>(i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">each</span>(j,L[i])&#123;</span><br><span class="line">            ans[j]-=t.<span class="built_in">qryPath</span>(ask[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">each</span>(j,R[i])&#123;</span><br><span class="line">            ans[j]+=t.<span class="built_in">qryPath</span>(ask[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">write</span>((ans[i]%Mod+Mod)%Mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>P4309</title>
    <url>/2023/12/02/P4309/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4309">P4309 [TJOI2013]
最长上升子序列</a></p>
<span id="more"></span>
<p>先考虑暴力<code>DP</code>的转移。</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数的<code>LIS</code>长度。</p>
<p>先把后面的 <span class="math inline">\(f\)</span>
数组整体后移一位；因为插入的数是从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
的，所以新加入的数一定可以让前面的<code>LIS</code>长度 <span
class="math inline">\(+1\)</span>。</p>
<p>设插入的位置为 <span class="math inline">\(i\)</span>：</p>
<ol type="1">
<li>将 <span class="math inline">\(f[i]\)</span> 到 <span
class="math inline">\(f[n]\)</span> 全部后移一位，空出 <span
class="math inline">\(f[i]\)</span>。</li>
<li><span
class="math inline">\(f[i]=\max\limits_{j=1}^if[j]+1\)</span></li>
</ol>
<p>时间复杂度 <span
class="math inline">\(O(n^2)\)</span>，不可接受。</p>
<p>发现两种操作均可以用平衡树加速，做到单次操作 <span
class="math inline">\(O(\log n)\)</span>。</p>
<p>具体一点（均使用<code>FHQ-Treap</code>）：</p>
<p>操作 <span class="math inline">\(1\)</span>
其实是插入了一个数，因为此题操作的下标和插入的值相同，所以不需要考虑顺序问题，<code>split</code>的时候直接找值就可以保证找到的是一个前缀。</p>
<p>操作只需要按 <span class="math inline">\(i\)</span>
做<code>split</code>，插入的新节点的 <span
class="math inline">\(f[i]\)</span> 为：左边子树维护好的最大值 <span
class="math inline">\(+1\)</span>。</p>
<p>每次查询输出全局最大即可。</p>
<p>总复杂度 <span class="math inline">\(O(n\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BT</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>], siz, wei;</span><br><span class="line">    <span class="type">int</span> val, mx;</span><br><span class="line">  &#125; t[N];</span><br><span class="line">  <span class="type">int</span> root, ncnt;</span><br><span class="line">  mt19937 rnd;</span><br><span class="line">  <span class="built_in">BT</span>() &#123;</span><br><span class="line">    root = ncnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ++ncnt;</span><br><span class="line">    <span class="built_in">ls</span>(ncnt) = <span class="built_in">rs</span>(ncnt) = <span class="number">0</span>;</span><br><span class="line">    t[ncnt].val = t[ncnt].mx = val, t[ncnt].siz = <span class="number">1</span>;</span><br><span class="line">    t[ncnt].wei = <span class="built_in">rnd</span>();</span><br><span class="line">    <span class="keyword">return</span> ncnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].mx = <span class="built_in">max</span>(&#123;t[rt].val, t[<span class="built_in">ls</span>(rt)].mx, t[<span class="built_in">rs</span>(rt)].mx&#125;);</span><br><span class="line">    t[rt].siz = t[<span class="built_in">ls</span>(rt)].siz + t[<span class="built_in">rs</span>(rt)].siz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> k, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) &#123;x = y = <span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= t[<span class="built_in">ls</span>(rt)].siz)y = rt, <span class="built_in">split</span>(<span class="built_in">ls</span>(rt), k, x, <span class="built_in">ls</span>(rt));</span><br><span class="line">    <span class="keyword">else</span> x = rt, <span class="built_in">split</span>(<span class="built_in">rs</span>(rt), k - t[<span class="built_in">ls</span>(rt)].siz - <span class="number">1</span>, <span class="built_in">rs</span>(rt), y);</span><br><span class="line">    <span class="built_in">update</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)<span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (t[x].wei &lt;= t[y].wei) &#123;</span><br><span class="line">      <span class="built_in">ls</span>(y) = <span class="built_in">merge</span>(x, <span class="built_in">ls</span>(y));</span><br><span class="line">      <span class="built_in">update</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">rs</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(x), y);</span><br><span class="line">      <span class="built_in">update</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">split</span>(root, pos, x, y);</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">newnode</span>(t[x].mx + <span class="number">1</span>);</span><br><span class="line">    root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x, z), y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t[root].mx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    bt.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="built_in">write</span>(bt.<span class="built_in">getAns</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4314</title>
    <url>/2023/12/02/P4314/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4314">P4314 CPU
监控</a></p>
<span id="more"></span>
<p>题面非常的线段树。</p>
<p>翻译一下：</p>
<ol type="1">
<li>询问区间最大值</li>
<li>询问区间历史最大值</li>
<li>区间加</li>
<li>区间推平</li>
</ol>
<p>我们把lazy tag看做一个区间被执行的操作序列。</p>
<p>那么pushdown操作就是把父节点的操作序列接在左右儿子的操作序列<strong>后面</strong></p>
<p>显然，在操作序列上，相邻的区间加 和
相邻的区间推平，都可以直接合并。</p>
<p>所以操作序列就形如：</p>
<p>加，推，加，推……</p>
<p>有一个较为容易的观察：区间推平后面的区间加，相当于移动了区间推平的“高度”。</p>
<p>那么两种操作也可以合并了。</p>
<p>pushdown应该先下传区间加的tag，因为区间加可以合并到区间推平上。</p>
<p>每次修改最大值的时候，历史最值对当前最值取即可。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log n)\)</span>。</p>
<p>代码做了很多封装，可读性上不如全部展开写，放在这里更多做模板（Ctrl+C）作用。</p>
<p>（尝试写了指针版线段树，感觉也挺好看的，和数组版本没有本质区别）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,q,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">    <span class="type">int</span> add,cov;</span><br><span class="line">    <span class="built_in">dat</span>(<span class="type">int</span> aa=<span class="number">0</span>,<span class="type">int</span> cc=-inf) &#123;add=aa;cov=cc;&#125;</span><br><span class="line">    dat <span class="keyword">operator</span> +(<span class="type">const</span> dat &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">dat</span>(<span class="built_in">max</span>(-inf,add+a.add),<span class="built_in">max</span>(a.cov,cov+a.add));&#125;</span><br><span class="line">    dat <span class="keyword">operator</span> *(<span class="type">const</span> dat &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">dat</span>(<span class="built_in">max</span>(add,a.add),<span class="built_in">max</span>(cov,a.cov));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,mx,hmx;</span><br><span class="line">    dat laz,hlaz;</span><br><span class="line">    SegT *son[<span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ls son[0]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rs son[1]</span></span><br><span class="line">    <span class="built_in">SegT</span>()&#123;</span><br><span class="line">        L=R=mx=hmx=<span class="number">0</span>;</span><br><span class="line">        laz=hlaz=<span class="built_in">dat</span>();</span><br><span class="line">        ls=rs=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(ls-&gt;mx,rs-&gt;mx);</span><br><span class="line">        hmx=<span class="built_in">max</span>(ls-&gt;hmx,rs-&gt;hmx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> dat&amp; now,<span class="type">const</span> dat&amp; his)</span></span>&#123;</span><br><span class="line">        hlaz=hlaz*(laz+his);</span><br><span class="line">        laz=laz+now;</span><br><span class="line">        hmx=<span class="built_in">max</span>(&#123;hmx,mx+his.add,his.cov&#125;);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx+now.add,now.cov);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ls-&gt;<span class="built_in">update</span>(laz,hlaz);</span><br><span class="line">        rs-&gt;<span class="built_in">update</span>(laz,hlaz);</span><br><span class="line">        laz=hlaz=<span class="built_in">dat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        L=l,R=r;</span><br><span class="line">        <span class="keyword">if</span>(L==R)&#123;mx=hmx=a[L];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (ls=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(L,mid);</span><br><span class="line">        (rs=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">        <span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">const</span> dat&amp; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R)&#123;<span class="built_in">update</span>(v,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="built_in">pushdown</span>();</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;mid)rs-&gt;<span class="built_in">modify</span>(l,r,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;=mid)ls-&gt;<span class="built_in">modify</span>(l,r,v);</span><br><span class="line">        <span class="keyword">else</span> ls-&gt;<span class="built_in">modify</span>(l,mid,v),rs-&gt;<span class="built_in">modify</span>(mid+<span class="number">1</span>,r,v);</span><br><span class="line">        <span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">bool</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R)&#123;<span class="keyword">return</span> op?hmx:mx;&#125;</span><br><span class="line">        <span class="built_in">pushdown</span>();</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;mid)<span class="keyword">return</span> rs-&gt;<span class="built_in">query</span>(l,r,op);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> ls-&gt;<span class="built_in">query</span>(l,r,op);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ls-&gt;<span class="built_in">query</span>(l,mid,op),rs-&gt;<span class="built_in">query</span>(mid+<span class="number">1</span>,r,op));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;*rt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    (rt=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            rt-&gt;<span class="built_in">modify</span>(x,y,<span class="built_in">dat</span>(z,-inf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            rt-&gt;<span class="built_in">modify</span>(x,y,<span class="built_in">dat</span>(-inf,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;rt-&gt;<span class="built_in">query</span>(x,y,<span class="number">0</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;rt-&gt;<span class="built_in">query</span>(x,y,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4319</title>
    <url>/2023/12/15/P4319/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4319">P4319
变化的道路</a></p>
<span id="more"></span>
<p>时间轴上的线段覆盖，考虑线段树分治。</p>
<p>将每个边的出现时间段挂在线段树上，问题变为怎么做支持加/删边的动态最小生成树。</p>
<p>LCT维护最大值位置即可，加边时，如果成环，找环上最大值删掉，用栈存下所有LCT上操作，便于线段树分治的撤销。</p>
<p>需要注意，这里不需要考虑“如果删掉了树边怎么找图中的边加入生成树”之类的问题，线段树分治的优势就是不需要考虑这类问题。向下走的时候，显然只有加边；跳出子树时，所有删边，都是对加边的撤回，在前面的操作中，有删边就一定有对应的加边，只要保证每个时刻都最优就好了。</p>
<p>其实这就做完了。</p>
<p>记 <span class="math inline">\(t=32766\)</span>，时间复杂度 <span
class="math inline">\(O(m\log t\log n)\)</span>，常数很大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">Tm</span><span class="params">(<span class="number">32766</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v,w;&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; T[N*<span class="number">4</span>];</span><br><span class="line">Edge e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        T[rt].<span class="built_in">pb</span>(v);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>],fa,pos,rev;</span><br><span class="line">    &#125;t[N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">nrot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">fa</span>(x))==x||<span class="built_in">rs</span>(<span class="built_in">fa</span>(x))==x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        t[x].pos=x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ls</span>(x)&amp;&amp;val[t[<span class="built_in">ls</span>(x)].pos]&gt;val[t[x].pos])t[x].pos=t[<span class="built_in">ls</span>(x)].pos;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rs</span>(x)&amp;&amp;val[t[<span class="built_in">rs</span>(x)].pos]&gt;val[t[x].pos])t[x].pos=t[<span class="built_in">rs</span>(x)].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updrev</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="built_in">ls</span>(x),<span class="built_in">rs</span>(x));</span><br><span class="line">        t[x].rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[x].rev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ls</span>(x))<span class="built_in">updrev</span>(<span class="built_in">ls</span>(x));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">rs</span>(x))<span class="built_in">updrev</span>(<span class="built_in">rs</span>(x));</span><br><span class="line">            t[x].rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">fa</span>(x),z=<span class="built_in">fa</span>(y),k=<span class="built_in">rs</span>(y)==x,w=t[x].son[!k];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">nrot</span>(y))t[z].son[<span class="built_in">rs</span>(z)==y]=x;</span><br><span class="line">        t[x].son[!k]=y;t[y].son[k]=w;</span><br><span class="line">        <span class="keyword">if</span>(w)<span class="built_in">fa</span>(w)=y;</span><br><span class="line">        <span class="built_in">fa</span>(y)=x,<span class="built_in">fa</span>(x)=z;</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> st[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> y=x,z=<span class="number">0</span>;</span><br><span class="line">        st[++z]=y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">nrot</span>(y))st[++z]=y=<span class="built_in">fa</span>(y);</span><br><span class="line">        <span class="keyword">while</span>(z)<span class="built_in">pushdown</span>(st[z--]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">nrot</span>(x))&#123;</span><br><span class="line">            y=<span class="built_in">fa</span>(x),z=<span class="built_in">fa</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">nrot</span>(y))<span class="built_in">rotate</span>((<span class="built_in">ls</span>(y)==x)^(<span class="built_in">ls</span>(z)==y)?x:y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;x=<span class="built_in">fa</span>(y=x))&#123;</span><br><span class="line">            <span class="built_in">splay</span>(x),<span class="built_in">rs</span>(x)=y,<span class="built_in">pushup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makerot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x),<span class="built_in">splay</span>(x),<span class="built_in">updrev</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findrot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x),<span class="built_in">splay</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ls</span>(x))<span class="built_in">pushdown</span>(x),x=<span class="built_in">ls</span>(x);</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x),<span class="built_in">access</span>(y),<span class="built_in">splay</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">split</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> t[y].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findrot</span>(y)!=x)<span class="built_in">fa</span>(x)=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findrot</span>(y)==x&amp;&amp;<span class="built_in">fa</span>(y)==x&amp;&amp;!<span class="built_in">ls</span>(y))&#123;</span><br><span class="line">            <span class="built_in">fa</span>(y)=<span class="built_in">rs</span>(x)=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> fa</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> LCT;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">pii sta[N];</span><br><span class="line"><span class="type">int</span> tp;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> las=tp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:T[rt])&#123;</span><br><span class="line">        <span class="type">int</span> u=e[i].u,v=e[i].v,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findrot</span>(u)==<span class="built_in">findrot</span>(v))&#123;</span><br><span class="line">            <span class="type">int</span> d=<span class="built_in">ask</span>(u,v)-n;</span><br><span class="line">            <span class="keyword">if</span>(e[d].w&lt;=w)<span class="keyword">continue</span>;</span><br><span class="line">            ans-=e[d].w;</span><br><span class="line">            <span class="built_in">cut</span>(e[d].u,d+n);</span><br><span class="line">            <span class="built_in">cut</span>(e[d].v,d+n);</span><br><span class="line">            sta[++tp]=&#123;d,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">link</span>(u,n+i);</span><br><span class="line">        <span class="built_in">link</span>(v,n+i);</span><br><span class="line">        sta[++tp]=&#123;i,<span class="number">1</span>&#125;;</span><br><span class="line">        ans+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tp&gt;las)&#123;</span><br><span class="line">        <span class="type">int</span> d=sta[tp].fi;</span><br><span class="line">        <span class="type">int</span> u=e[d].u,v=e[d].v,w=e[d].w;</span><br><span class="line">        <span class="keyword">if</span>(sta[tp].se==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">link</span>(u,d+n);</span><br><span class="line">            <span class="built_in">link</span>(v,d+n);</span><br><span class="line">            ans+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cut</span>(u,d+n);</span><br><span class="line">            <span class="built_in">cut</span>(v,d+n);</span><br><span class="line">            ans-=w;</span><br><span class="line">        &#125;</span><br><span class="line">        tp--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        e[++cnt]=&#123;u,v,w&#125;;</span><br><span class="line">        val[n+cnt]=w;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>,<span class="number">1</span>,Tm,<span class="number">1</span>,Tm,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        e[++cnt]=&#123;u,v,w&#125;;</span><br><span class="line">        val[n+cnt]=w;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>,<span class="number">1</span>,Tm,l,r,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,Tm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树分治</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>P4452</title>
    <url>/2023/12/29/P4452/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4452">P4452 [国家集训队]
航班安排</a></p>
<span id="more"></span>
<p>对于机场来说，不容易找性质（比如“只能选一次”，“选了就不能选别的”之类的网络流式约束）。</p>
<p>所以不能对机场建点，要根据机场来约束边。</p>
<p>那就对请求建点，具体的，将每个请求拆成两个点 <span
class="math inline">\(p_1,p_2\)</span>，在两点之间连流量 <span
class="math inline">\(1\)</span>，价值 <span
class="math inline">\(c\)</span> 的边，流量为 <span
class="math inline">\(1\)</span> 用来约束只能贡献一次的要求，所有的
<span class="math inline">\(p_1,p_2\)</span> 构成了二分图结构。</p>
<p>对于一个请求，如果 <span class="math inline">\(0\)</span> 时刻可以从
<span class="math inline">\(0\)</span> 机场飞到对应机场，就从源点向
<span class="math inline">\(p_1\)</span> 连流量 <span
class="math inline">\(+\infty\)</span>，价值为 <span
class="math inline">\(-f\)</span> 的边。同理，如果结束之后有足够时间回到
<span class="math inline">\(0\)</span> 机场，<span
class="math inline">\(p_2\)</span> 向汇点连流量 <span
class="math inline">\(+\infty\)</span>，价值为 <span
class="math inline">\(-f\)</span> 的边。</p>
<p>但是每次执行完一个请求并未规定一定要飞回 <span
class="math inline">\(0\)</span>
机场，也可以飞去其他请求的起点机场，所以两两枚举请求，如果满足时间条件也进行连边，如果
<span class="math inline">\(u\)</span> 请求之后可以去 <span
class="math inline">\(v\)</span>，就连 <span
class="math inline">\(up_2\to vp_1\)</span>，流量 <span
class="math inline">\(+\infty\)</span>，价值 <span
class="math inline">\(-f\)</span>。</p>
<p>网络流建模一定要善用枚举，反正瓶颈一般都在求值上。不要被思维定式卡住，边不一定只能向右连，在建模中可以通过流环去构造结构，也就是“向左”连边。</p>
<p>注意到一共只有 <span class="math inline">\(k\)</span>
个飞机，飞机就是流量，所以要新建一个点连向原来的源点，流量 <span
class="math inline">\(k\)</span>，价值 <span
class="math inline">\(0\)</span>，以新点为真源点跑最大费用最大流，就是答案。</p>
<p>时间复杂度 <span class="math inline">\(O(AC)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>,Tn=<span class="number">3005</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,T,t[N][N],w[N][N];</span><br><span class="line"><span class="type">int</span> st,ed;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w,cap,nxt;</span><br><span class="line">&#125;e[<span class="number">1000006</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100006</span>],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].cap=cap;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adf</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,w,cap);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,-w,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,s,t,c;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> dis[N*<span class="number">2</span>],vis[N*<span class="number">2</span>],tim;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,ed)dis[i]=-inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(st);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&lt;dis[u]+e[i].w&amp;&amp;e[i].cap)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[ed]!=-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flow,cost;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==ed)&#123;</span><br><span class="line">        flow+=fl;</span><br><span class="line">        <span class="keyword">return</span> fl;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=tim;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>((vis[v]!=tim||v==ed)&amp;&amp;e[i].cap&amp;&amp;dis[v]==dis[u]+e[i].w)&#123;</span><br><span class="line">            t=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(fl-used,e[i].cap));</span><br><span class="line">            <span class="keyword">if</span>(t)&#123;</span><br><span class="line">                e[i].cap-=t,e[i^<span class="number">1</span>].cap+=t;</span><br><span class="line">                cost+=t*e[i].w,used+=t;</span><br><span class="line">                <span class="keyword">if</span>(fl==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k,T);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(t[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st=m*<span class="number">2</span>+<span class="number">1</span>,ed=m*<span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].a,q[i].b,q[i].s,q[i].t,q[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">adf</span>(i*<span class="number">2</span><span class="number">-1</span>,i*<span class="number">2</span>,q[i].c,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(q[i].t+t[q[i].b][<span class="number">0</span>]&gt;T)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">adf</span>(i*<span class="number">2</span>,ed,-w[q[i].b][<span class="number">0</span>],inf);</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">0</span>][q[i].a]&lt;=q[i].s)&#123;</span><br><span class="line">            <span class="built_in">adf</span>(st+<span class="number">1</span>,i*<span class="number">2</span><span class="number">-1</span>,-w[<span class="number">0</span>][q[i].a],inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].t+t[q[i].b][q[j].a]&lt;=q[j].s)&#123;</span><br><span class="line">                <span class="built_in">adf</span>(i*<span class="number">2</span>,j*<span class="number">2</span><span class="number">-1</span>,-w[q[i].b][q[j].a],inf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">adf</span>(st,st+<span class="number">1</span>,<span class="number">0</span>,k);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            tim++;</span><br><span class="line">            <span class="built_in">dfs</span>(st,inf);</span><br><span class="line">        &#125;<span class="keyword">while</span>(vis[ed]==tim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(cost,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4322</title>
    <url>/2023/12/02/P4322/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4322">P4322 [JSOI2016]
最佳团体</a></p>
<span id="more"></span>
<p>一眼盯真，鉴定为：分数规划。</p>
<p>先转化题目中选点的约束：选包含根（节点0）的某一个连通块，最大化 <span
class="math inline">\(\frac{\sum P_i}{\sum S_i}\)</span>。</p>
<p>这个选点的限制显然可以用树上背包。</p>
<p>设 <span class="math inline">\(f[u][i]\)</span> 为 <span
class="math inline">\(u\)</span> 子树内选 <span
class="math inline">\(i\)</span> 个点，最优答案。</p>
<p><span class="math inline">\(f[u][i]\)</span> 可以从 <span
class="math inline">\(f[u][i-j]+f[v][j]\)</span> 转移而来，<span
class="math inline">\(v\)</span> 为 <span
class="math inline">\(u\)</span> 的儿子。</p>
<p>01分数规划当然要二分答案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\dfrac{\sum P_i}{\sum S_i}\ge mid\\
&amp;\sum P_i\ge \sum S_i\times mid\\
&amp;\sum P_i-S_i\times mid\ge 0
\end{aligned}
\]</span></p>
<p>以 <span class="math inline">\(P_i-S_i\times mid\)</span>
为点权，跑树上背包即可check。</p>
<p>时间复杂度为 <span class="math inline">\(O(n^2\log V)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-5</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2505</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> tar,n,s[N],p[N],r[N],fa[N];</span><br><span class="line"><span class="type">double</span> wei[N],f[N][N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=wei[u],siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">DP</span>(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="built_in">pe</span>(i,<span class="built_in">min</span>(siz[u],tar+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(siz[v],i<span class="number">-1</span>))&#123;</span><br><span class="line">                f[u][i]=<span class="built_in">max</span>(f[u][i],f[u][i-j]+f[v][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        wei[i]=p[i]-x*s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fill</span>(f[i],f[i]+tar+<span class="number">2</span>,<span class="number">-1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DP</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][tar+<span class="number">1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;tar&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;s[i]&gt;&gt;p[i]&gt;&gt;fa[i];</span><br><span class="line">        G[fa[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;l&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>背包</tag>
        <tag>分数规划</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P4491</title>
    <url>/2024/01/07/P4491/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4491">P4491 [HAOI2018]
染色</a></p>
<span id="more"></span>
<p><span class="math inline">\(W_k\)</span> 和问题没有本质联系。设 <span
class="math inline">\(f(k)\)</span> 为<strong>恰好</strong>出现 <span
class="math inline">\(s\)</span> 次的颜色<strong>恰好</strong>有 <span
class="math inline">\(k\)</span> 种的染色方案数，答案为 <span
class="math inline">\(\sum_{k}f(k)W_k\)</span></p>
<p><span class="math inline">\(f\)</span>
不好求，先把能想到的部分正确解法列出来。</p>
<p>有一个 naive 的想法是：钦定 <span class="math inline">\(k\)</span>
种颜色，每种染 <span class="math inline">\(s\)</span>
次，然后其他的彻底不管。</p>
<p>设为 <span class="math inline">\(g\)</span>，式子为： <span
class="math display">\[
g(k)=\binom{m}{k}\binom{n}{sk}\frac{(sk)!}{s!^k}(m-k)^{n-sk}
\]</span> 四个部分为：钦定 <span class="math inline">\(k\)</span>
个颜色，选 <span class="math inline">\(sk\)</span>
个染色位置，多重集的全排列（算染色方案），剩下的随便染。</p>
<p>值得一提，因为会重复计数，所以整个式子严格来说没有组合意义。</p>
<p>但是，多想想会发现，<span class="math inline">\(g\)</span> 可以通过
<span class="math inline">\(f\)</span> 得到！</p>
<p>我们可以用 <span class="math inline">\(f\)</span> 凑出 <span
class="math inline">\(g\)</span> 的重复计数方案，然后再反演。</p>
<p>设 <span
class="math inline">\(lim=\left\lfloor\dfrac{n}{s}\right\rfloor\)</span>，容易发现，对答案有贡献的
<span class="math inline">\(W_i\)</span>，要满足 <span
class="math inline">\(i\in[0,lim]\)</span>。</p>
<p>有： <span class="math display">\[
g(k)=\sum_{i=k}^{lim}\binom{i}{k}f(i)
\]</span> 为什么？如果没有重复计数，设为 <span
class="math inline">\(g_1(k)\)</span>： <span class="math display">\[
g_1(k)=\sum_{i=k}^{lim}f(i)
\]</span> 这是常规的情况。</p>
<p>但是有重复，考虑每一个 <span class="math inline">\(f(i)\)</span>
会被重复计数多少次。</p>
<p>对于当前会被算进“至少 <span class="math inline">\(k\)</span>”的 “恰好
<span class="math inline">\(i\)</span>”，有 <span
class="math inline">\(\dbinom{i}{k}\)</span> 种选择”至少 <span
class="math inline">\(k\)</span>“ 具体是哪些 <span
class="math inline">\(k\)</span> 的方案，每种方案都会贡献一次 <span
class="math inline">\(f(i)\)</span>，可以写点规模小的例子感受一下。</p>
<p>这个形式显然要二项式反演。</p>
<p>易得： <span class="math display">\[
f(k)=\sum_{i=k}^{lim}(-1)^{i-k}\binom{i}{k}g(i)
\]</span> 但是复杂度还是有问题，考虑加速计算。</p>
<p>拆式子。 <span class="math display">\[
\begin{aligned}
f(k)&amp;=\sum_{i=k}^{lim}(-1)^{i-k}\binom{i}{k}g(i)\\
&amp;=\sum_{i=k}^{lim}(-1)^{i-k}\frac{i!}{k!(i-k)!}g(i)\\
&amp;=\frac{1}{k!}\sum_{i=k}^{lim}\frac{(-1)^{i-k}}{(i-k)!}\times i!g(i)
\end{aligned}
\]</span> 找到了卷积形式。 <span class="math display">\[
\begin{aligned}
&amp;A(i)=i!g(i)\\
&amp;B(i)=\frac{(-1)^{i}}{i!}\\
&amp;f(k)=\frac{1}{k!}\sum_{i=k}^{lim}A(i)B(i-k)
\end{aligned}
\]</span> NTT 做差卷积。</p>
<p>复杂度 <span class="math inline">\(O(n+m\log m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1004535809</span>;</span><br><span class="line"><span class="keyword">namespace</span> PL&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> polynomial_assert(...) assert(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> polynomial_assert(...) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> mod, <span class="type">int</span> G&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lg2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> ^ __builtin_clz(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">modadd</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + ((x &gt;&gt; <span class="number">31</span>) &amp; mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">modsub</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= mod ? x - mod : x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = (ll)ret * x % mod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(y &gt;&gt;= <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            x = (ll)x * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">get_power_G</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; vct&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SZ</span>(vct) &lt; len) &#123;</span><br><span class="line">            len = <span class="built_in">lg2</span>(len);</span><br><span class="line">            <span class="type">int</span> k = last;</span><br><span class="line">            vct.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; len);</span><br><span class="line">            vct[<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>)] = <span class="built_in">qpow</span>(G, (mod - <span class="number">1</span>) &gt;&gt; (len + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; k; i--)</span><br><span class="line">                vct[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = (ll)vct[<span class="number">1</span> &lt;&lt; i] * vct[<span class="number">1</span> &lt;&lt; i] % mod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> lim = (<span class="number">1</span> &lt;&lt; k); k &lt; len; k++, lim &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = lim + <span class="number">1</span>; i &lt; (lim &lt;&lt; <span class="number">1</span>); i++)</span><br><span class="line">                    vct[i] = (ll)vct[i - lim] * vct[lim] % mod;</span><br><span class="line"></span><br><span class="line">            last = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DIF</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;power = <span class="built_in">get_power_G</span>(arr.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">SZ</span>(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (lim &gt;&gt; <span class="number">1</span>); i &gt;= <span class="number">1</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                ll x = arr[k], y = arr[i + k];</span><br><span class="line">                arr[k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                arr[i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (i &lt;&lt; <span class="number">1</span>), t = <span class="number">1</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>), t++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    ll x = arr[j + k], y = (ll)arr[j + i + k] * power[t] % mod;</span><br><span class="line">                    arr[j + k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                    arr[j + i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DIT</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;power = <span class="built_in">get_power_G</span>(arr.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">SZ</span>(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                ll x = arr[k], y = arr[i + k];</span><br><span class="line">                arr[k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                arr[i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (i &lt;&lt; <span class="number">1</span>), t = <span class="number">1</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>), t++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    ll x = arr[j + k], y = arr[j + i + k];</span><br><span class="line">                    arr[j + k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                    arr[j + i + k] = (ll)(x - y + mod) * power[t] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll invlim = <span class="built_in">qpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">            arr[i] = (ll)arr[i] * invlim % mod;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>() + <span class="number">1</span>, arr.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Polynomial</span>() : <span class="built_in">a</span>(&#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= x &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> : a(&#123;</span>x&#125;) &#123;&#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= a[i] &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;rhs)</span> : a(rhs) &#123;</span></span><br><span class="line">        <span class="built_in">polynomial_assert</span>(!a.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= a[i] &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rhs)</span> : a(rhs) &#123;</span></span><br><span class="line">        <span class="built_in">polynomial_assert</span>(!a.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="keyword">operator</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    Polynomial &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Polynomial &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">min</span>(<span class="built_in">SZ</span>(a), <span class="built_in">SZ</span>(rhs.a)) &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l_ = <span class="built_in">SZ</span>(a) + <span class="built_in">SZ</span>(rhs.a) - <span class="number">1</span>;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(SZ(a) + SZ(rhs.a) - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">SZ</span>(a); i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">SZ</span>(rhs.a); j++) &#123;</span><br><span class="line">                    ret[i + j] += (ll)a[i] * rhs.a[j] % mod;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ret[i + j] &gt;= mod)</span><br><span class="line">                        ret[i + j] -= mod;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            *<span class="keyword">this</span> = <span class="built_in">Polynomial</span>(std::<span class="built_in">move</span>(ret));</span><br><span class="line">            a.<span class="built_in">resize</span>(l_);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">SZ</span>(a) + <span class="built_in">SZ</span>(rhs.a) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l_ = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &amp; (l - <span class="number">1</span>))</span><br><span class="line">            l = <span class="number">1</span> &lt;&lt; (<span class="built_in">lg2</span>(l) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        a.<span class="built_in">resize</span>(l), <span class="built_in">DIF</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            Polynomial rhs_ = rhs;</span><br><span class="line">            rhs_.a.<span class="built_in">resize</span>(l), <span class="built_in">DIF</span>(rhs_.a);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">                a[i] = (ll)a[i] * rhs_.a[i] % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">                a[i] = (ll)a[i] * a[i] % mod;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DIT</span>(a);</span><br><span class="line">        a.<span class="built_in">resize</span>(l_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SZ</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SZ</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">resize</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> Polynomial <span class="keyword">operator</span>*(<span class="type">const</span> Polynomial &amp;x, <span class="type">const</span> Polynomial &amp;y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Polynomial</span>(x) *= y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Poly = Polynomial&lt;mod, <span class="number">3</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">5</span>,M=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,lim)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[lim]=<span class="built_in">qpow</span>(fac[lim],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">per</span>(i,lim<span class="number">-1</span>,<span class="number">0</span>)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s);</span><br><span class="line">    <span class="built_in">init</span>(<span class="built_in">max</span>(m,n));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line">    <span class="type">int</span> lim=<span class="built_in">min</span>(m,n/s);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,lim)&#123;</span><br><span class="line">        a.<span class="built_in">pb</span>(<span class="number">1ll</span>*<span class="built_in">C</span>(m,i)*<span class="built_in">C</span>(n,i*s)%mod*fac[s*i]%mod*<span class="built_in">qpow</span>(m-i,n-s*i)%mod*<span class="built_in">qpow</span>(ifac[s],i)%mod*fac[i]%mod);</span><br><span class="line">        b.<span class="built_in">pb</span>((i&amp;<span class="number">1</span>)?mod-ifac[i]:ifac[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">range</span>(a));</span><br><span class="line">    <span class="function">PL::Poly <span class="title">A</span><span class="params">(a)</span>,<span class="title">B</span><span class="params">(b)</span></span>;</span><br><span class="line">    PL::Poly F=A*B;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f=F.<span class="built_in">data</span>();</span><br><span class="line">    f.<span class="built_in">resize</span>(lim+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">range</span>(f));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,lim)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*f[i]*ifac[i]%mod*w[i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计数</tag>
        <tag>反演</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P4590</title>
    <url>/2023/12/13/P4590/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4590">P4590 [TJOI2018]
游园会</a></p>
<span id="more"></span>
<p>DP套DP的模板题。</p>
<p>定义 <span class="math inline">\(F(i,j,k)\)</span> 为：兑奖串中前
<span class="math inline">\(i\)</span> 位，和奖章串LCS为 <span
class="math inline">\(j\)</span>，当前末尾匹配了<code>NOI</code>中的前
<span class="math inline">\(k\)</span> 个。</p>
<p>发现仅仅转移一个 <span class="math inline">\(j\)</span>
不可行——对于每一个不同的 <span
class="math inline">\(i,k\)</span>，我们都不知道LCS到底匹配到了哪里，无法对LCS做转移。</p>
<p>也就是说，我们在 <span class="math inline">\(j\)</span>
这一维上要放DP求解LCS时的一整个DP数组。</p>
<p>这当然不行，要发掘DP求LCS的性质。</p>
<p>对于一般的LCS，一般的做法是：设 <span
class="math inline">\(L(i,j)\)</span> 为 <span
class="math inline">\(A\)</span> 串的前 <span
class="math inline">\(i\)</span> 位与 <span
class="math inline">\(B\)</span> 串的前 <span
class="math inline">\(j\)</span> 位匹配取得的LCS，<span
class="math inline">\(A\)</span> 为兑奖串，<span
class="math inline">\(B\)</span> 为奖章串。</p>
<p>有 <span
class="math inline">\(L(i,j)=\max(L(i-1,j),L(i,j-1),L(i-1,j-1)+[A_i=B_j])\)</span></p>
<p>注意到 <span class="math inline">\(B\)</span> 串长度（<span
class="math inline">\(K\)</span>）不超过 <span
class="math inline">\(15\)</span>，考虑状压。</p>
<p>发现 <span class="math inline">\(L(i,j)\)</span> 的每个 <span
class="math inline">\(j\)</span> 的状态都可以通过上一行，也就是 <span
class="math inline">\(L(i-1,x)\)</span> 得出。<span
class="math inline">\(F(i,L(i),k&#39;)\leftarrow
F(i-1,L(i-1),k)\)</span> （简记）。</p>
<p>显然 <span
class="math inline">\(L(i,j)-L(i,j-1)\in\{0,1\}\)</span>，我们可以对
<span class="math inline">\(L(i,j)\)</span>
的第二维做差分，对差分出的数组状压得到 <span
class="math inline">\(S(i)\)</span>，当作 <span
class="math inline">\(F(i,j,k)\)</span> 的 <span
class="math inline">\(j\)</span>。</p>
<p>总而言之，预处理出 <span class="math inline">\(S(i)\)</span>
下一行的差分状态 <span
class="math inline">\(nxt[S(i)]\)</span>，这样就可以做形如：<span
class="math inline">\(F(i,nxt[j],k&#39;)\leftarrow F(i-1,j,k)\)</span>
的转移。</p>
<p>不要忘了<code>NOI</code>不能连续出现的限制，不仅要对 <span
class="math inline">\(F\)</span> 加一维，还要对 <span
class="math inline">\(nxt\)</span> 加一维。</p>
<p>具体的，先枚举差分状态，根据差分状态还原出原 <span
class="math inline">\(L(i,j)\)</span>，枚举当前在奖章串上要匹配的，同时也是兑奖串上的末尾字符
<span class="math inline">\(x\)</span>，记录 <span
class="math inline">\(nxt[j][x]\)</span> 即可。</p>
<p>对 <span class="math inline">\(F\)</span>
做转移时要枚举兑奖串最后一个字符 和 <code>NOI</code>
目前匹配了几个，最后做累加：<span
class="math inline">\(ans[popcount(s)]\leftarrow
F(n,s,k),k\in[0,2]\)</span>，显然，差分数组上的 <span
class="math inline">\(1\)</span> 个数就是LCS长度。</p>
<p>注意到 <span class="math inline">\(F,L\)</span>
的处理均只和上一行有关，都滚掉第一维，优化空间。</p>
<p>时间复杂度 <span class="math inline">\(O(2^K(N+K))\)</span>。</p>
<p>总结：DP套DP 常用于解决一些字符串问题，预处理 <span
class="math inline">\(L\)</span>
本质上是在造自动机，将自动机得到的答案作为状态压进后面的 <span
class="math inline">\(F\)</span>
内，处理真正的答案，事实上代码中的写法较为偏向DP，也可以写的很像字符串题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e3</span>+<span class="number">5</span>)</span>,<span class="title">K</span><span class="params">(<span class="number">15</span>)</span>,<span class="title">mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> noi[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,m,L[<span class="number">2</span>][K+<span class="number">5</span>],a[N],F[<span class="number">2</span>][(<span class="number">1</span>&lt;&lt;K)+<span class="number">5</span>][<span class="number">3</span>],ans[N],nxt[(<span class="number">1</span>&lt;&lt;K)+<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;(str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;N&#x27;</span>)a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;O&#x27;</span>)a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;I&#x27;</span>)a[i]=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            L[<span class="number">0</span>][i+<span class="number">1</span>]=L[<span class="number">0</span>][i]+(s&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">                L[<span class="number">1</span>][i]=<span class="built_in">max</span>(L[<span class="number">1</span>][i<span class="number">-1</span>],L[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">if</span>(a[i]==j)L[<span class="number">1</span>][i]=<span class="built_in">max</span>(L[<span class="number">1</span>][i],L[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(L[<span class="number">1</span>][i]&gt;L[<span class="number">1</span>][i<span class="number">-1</span>])t|=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            nxt[s][j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> o=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(F[o^<span class="number">1</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(F[o^<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">2</span>&amp;&amp;j==<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    (F[o^<span class="number">1</span>][nxt[s][j]][noi[k][j]]+=F[o][s][k])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        o^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            (ans[__builtin_popcount(s)]+=F[o][s][i])%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>字符串</tag>
        <tag>DFA-DP</tag>
        <tag>有限状态自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P4585</title>
    <url>/2023/12/08/P4585/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4585">P4585 [FJOI2015]
火星商店问题</a></p>
<span id="more"></span>
<p>两种写法。</p>
<h2 id="线段树分治">线段树分治</h2>
<p>其实线段树分治就是对操作的时间分治。</p>
<p>把询问的区间（时间的区间）在线段树上切成 <span
class="math inline">\(\log\)</span> 段，挂在树上。</p>
<p>注意到修改会延续到最后一刻，所以修改只是左端点不一样而已，相当于一个后缀。</p>
<p>把修改按照位置排序（这个时候时间是乱序的），接着仿照线段树的形式按时间分治，在
<code>mid</code>
之前的修改，就扔到左边的数组里递归，否则就扔到右边的子树。这样就除掉了时间这一维的限制。</p>
<p>那么商店这一维,就用一个可持久化<code>01-Trie</code>来维护，具体做法在
<a href="https://h01yshhmy.github.io/2023/12/05/P4735/">P4735 |
h01yshhmy</a>，要先使用它将特殊商品的答案求出来。</p>
<p>注意最开始修改要按照商店编号排序，这样按照时间分拣之后它的商店编号依然是有序的，不妨把这些有修改的商店之间的其他商店都忽略掉，相当于不考虑特殊商品。一个修改挨着一个修改地构建可持久化<code>01-Trie</code>，保证了时间复杂度。</p>
<p>还有一个值得注意的问题，就是当把点加到可持久化字典树里的时候（<code>calc</code>函数），要重新从当前左端点构出字典树。</p>
<p>相当于清空这棵可持久化字典树，假如这个询问对应的答案是当前区间之前的某次修改加入的值，那么这个询问也一定会被丢到对应的线段树节点上计算，所以不用担心之前的修改会影响询问的答案。</p>
<p>为啥要这么写呢？因为就不用写撤销了，可以避免正常线段树分治的撤销操作带来的常数。</p>
<p>其实无论是思想还是写法都很像整体二分，总的来说还是一种：在线段树上转移，通过插入/撤销操作到达当前状态，并在当前状态中查询需要查询的答案——而线段树分治就是在同时利用自身性质优化：插入撤销次数和查询。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，空间复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<h2 id="树套树">树套树</h2>
<p>大力<code>DS</code>，太伟大。</p>
<p>显然是一个二维的最值问题，用线段树套<code>01-Trie</code>解决。线段树维护时间轴，<code>01-Trie</code>维护商店区间。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，空间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，常数较大，<code>2s,500MB</code>的题在洛谷跑了<code>1s,250MB</code>，主要赢在码量小，比较无脑。</p>
<p>下面分别贴上代码。</p>
<p>线段树分治：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc ((rt&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (rt&lt;&lt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;<span class="type">int</span> x,sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>)<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)sign=<span class="number">-1</span>;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> x*sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,cnt1,cnt2,tot,top;</span><br><span class="line"><span class="type">int</span> rt[maxn],ans[maxn],st[maxn];</span><br><span class="line"><span class="type">int</span> ch[maxn*<span class="number">20</span>][<span class="number">2</span>],sz[maxn*<span class="number">20</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">guest</span>&#123;<span class="type">int</span> l,r,L,R,x;&#125;p[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">buy</span>&#123;<span class="type">int</span> s,v,t;&#125;q[maxn],t1[maxn],t2[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> buy x,<span class="type">const</span> buy y)</span></span>&#123;<span class="keyword">return</span> x.s&lt;y.s;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> u,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now;now=x=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> d=w&amp;(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        ch[now][d^<span class="number">1</span>]=ch[u][d^<span class="number">1</span>];ch[now][d]=++tot;</span><br><span class="line">        now=ch[now][d];u=ch[u][d];</span><br><span class="line">        sz[now]=sz[u]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> d=w&amp;(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[r][d^<span class="number">1</span>]]-sz[ch[l][d^<span class="number">1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">            l=ch[l][d^<span class="number">1</span>],r=ch[r][d^<span class="number">1</span>],res+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">else</span> l=ch[l][d],r=ch[r][d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;R||r&lt;L||l&gt;R)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;a[rt].<span class="built_in">push_back</span>(x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">update</span>(lc,l,mid,L,R,x);<span class="built_in">update</span>(rc,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top=tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[++top]=q[i].s;</span><br><span class="line">        <span class="built_in">insert</span>(rt[top],rt[top<span class="number">-1</span>],q[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,sz=a[x].<span class="built_in">size</span>();i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=a[x][i];</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">upper_bound</span>(st+<span class="number">1</span>,st+<span class="number">1</span>+top,p[k].l<span class="number">-1</span>)-st<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">upper_bound</span>(st+<span class="number">1</span>,st+<span class="number">1</span>+top,p[k].r)-st<span class="number">-1</span>;</span><br><span class="line">        ans[k]=<span class="built_in">max</span>(ans[k],<span class="built_in">query</span>(rt[l],rt[r],p[k].x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span><span class="comment">//按时间分治</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> cn1=<span class="number">0</span>,cn2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">calc</span>(rt,L,R);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;i++)<span class="comment">//修改的区间右端点都是cnt1,相当于影响到之后的时间</span></span><br><span class="line">        <span class="keyword">if</span>(q[i].t&lt;=mid)t1[++cn1]=q[i];</span><br><span class="line">        <span class="keyword">else</span> t2[++cn2]=q[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn1;i++)q[i+L<span class="number">-1</span>]=t1[i];<span class="comment">//左端点在mid左边的放在左区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn2;i++)q[i+L<span class="number">-1</span>+cn1]=t2[i];<span class="comment">//否则放右边</span></span><br><span class="line">    <span class="built_in">divide</span>(lc,l,mid,L,L+cn1<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">divide</span>(rc,mid+<span class="number">1</span>,r,L+cn1,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">insert</span>(rt[i],rt[i<span class="number">-1</span>],<span class="built_in">gi</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,ty,l,r,x,d,s,v;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ty=<span class="built_in">gi</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ty)s=<span class="built_in">gi</span>(),v=<span class="built_in">gi</span>(),q[++cnt1]=(buy)&#123;s,v,cnt1&#125;;<span class="comment">//起点,价格,时间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l=<span class="built_in">gi</span>(),r=<span class="built_in">gi</span>(),x=<span class="built_in">gi</span>(),d=<span class="built_in">gi</span>();</span><br><span class="line">            ans[++cnt2]=<span class="built_in">query</span>(rt[l<span class="number">-1</span>],rt[r],x);</span><br><span class="line">            p[cnt2]=(guest)&#123;l,r,<span class="built_in">max</span>(<span class="number">1</span>,cnt1-d+<span class="number">1</span>),cnt1,x&#125;;</span><br><span class="line">            <span class="comment">//商店左端点,商店右端点,开始时间,结束时间,喜好密码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,cnt1,p[i].L,p[i].R,i);</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+cnt1,cmp);<span class="comment">//按照商店编号排序</span></span><br><span class="line">    <span class="built_in">divide</span>(<span class="number">1</span>,<span class="number">1</span>,cnt1,<span class="number">1</span>,cnt1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个是题解区的。</p>
<p>下面是我的树套树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">5e7</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],ch[M][<span class="number">2</span>],t[N*<span class="number">4</span>],las[M],ncnt,tim;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">18</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][c])ch[p][c]=++ncnt;</span><br><span class="line">        las[ch[p][c]]=<span class="built_in">max</span>(las[ch[p][c]],t);</span><br><span class="line">        p=ch[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">18</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[p][c^<span class="number">1</span>]&amp;&amp;las[ch[p][c^<span class="number">1</span>]]&gt;=t)&#123;</span><br><span class="line">            res+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            p=ch[p][c^<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> p=ch[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    t[rt]=++ncnt;</span><br><span class="line">    <span class="built_in">rep</span>(i,l,r)<span class="built_in">insert</span>(t[rt],a[i],inf);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(t[rt],v,tim);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> <span class="built_in">ask</span>(t[rt],x,d);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr,x,d));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr,x,d));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>,d=<span class="number">0</span>,x=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">            tim++;</span><br><span class="line">            <span class="built_in">read</span>(x,v);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r,x,d);</span><br><span class="line">            <span class="built_in">write</span>(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x,tim-d+<span class="number">1</span>),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树分治</tag>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>可持久化Trie</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4602</title>
    <url>/2024/01/09/P4602/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4602">P4602 [CTSC2018]
混合果汁</a></p>
<span id="more"></span>
<p>形式化题意。</p>
<p>每个询问 <span class="math inline">\(g,L\)</span>，求 <span
class="math inline">\(\max\limits_{S}\min\limits_{i\in
S}d_i\)</span>，其中 <span class="math inline">\(S\)</span>
满足存在一个序列 <span class="math inline">\(u\)</span>： <span
class="math inline">\(\sum\limits_{i\in S}p_iu_i\le
g,\,\sum\limits_{i\in S}u_i\ge L,\,\forall i\in S,u_i\le
l_i\)</span>。</p>
<p>最小值最大，对果汁排序，二分，求值转判定。</p>
<p>问题变为：是否存在一个合法 <span
class="math inline">\(S\)</span>，满足上述条件同时，其中所有 <span
class="math inline">\(i\)</span> 满足 <span class="math inline">\(d_i\ge
d_{mid}\)</span>。</p>
<p>首先 <span class="math inline">\(\sum p_iu_i\ge \sum
u_i\)</span>，所以必须满足 <span class="math inline">\(L\le
g\)</span>，不然无解。</p>
<p>注意到，<span class="math inline">\(\sum\limits_{i\in S}u_i\ge
L\)</span> 很好满足，而且它不区分具体是哪个果汁。</p>
<p>显然有一个贪心，优先放价格低的就好，这里价格指 <span
class="math inline">\(p_i\)</span>。</p>
<p>在按 <span class="math inline">\(d\)</span>
排序后的果汁序列上看，最终的选择方案一定是：当前 <span
class="math inline">\(d_i\ge d_{mid}\)</span>
的后缀上，放满某个前缀（<span
class="math inline">\(u_i=l_i\)</span>）然后再紧邻一个 <span
class="math inline">\(u_i&lt;l_i\)</span> 的 <span
class="math inline">\(i\)</span>。</p>
<p>判断存不存在这样的方案，可以通过数据结构维护。</p>
<p>按 <span class="math inline">\(d\)</span>
排序后建一个主席树，相当于是以 <span class="math inline">\(d\)</span>
为时间轴了。</p>
<p>对于时间轴上第 <span class="math inline">\(mid\)</span> 线段树，满足
<span class="math inline">\(d_i\ge d_{mid}\)</span> 的 <span
class="math inline">\(i\)</span>
是后缀；每个线段树维护序列后缀信息。</p>
<p>找线段树某个前缀，线段树二分，线段树维护 <span
class="math inline">\(\sum l\)</span> 和 <span
class="math inline">\(\sum p\times l\)</span>。每次判断 <span
class="math inline">\(\sum l,L\)</span> 和 <span
class="math inline">\(\sum p\times L,g\)</span> 的关系即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log ^2n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,nN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">juice</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,p,l;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    ll w,c;</span><br><span class="line">&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> rot[N],ncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll w,ll c)</span></span>&#123;</span><br><span class="line">    t[++ncnt]=t[rt],rt=ncnt;</span><br><span class="line">    t[rt].w+=w,t[rt].c+=c;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),l,mid,p,w,c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,w,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,ll w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> w*l;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(w&lt;=t[<span class="built_in">ls</span>(rt)].w)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,w);</span><br><span class="line">    <span class="keyword">return</span> t[<span class="built_in">ls</span>(rt)].c+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,w-t[<span class="built_in">ls</span>(rt)].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].d,a[i].p,a[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,[](juice x,juice y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.d&lt;y.d; </span><br><span class="line">    &#125;);</span><br><span class="line">    a[<span class="number">0</span>].d=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(rot[i]=rot[i+<span class="number">1</span>],<span class="number">0</span>,nN,a[i].p,a[i].l,<span class="number">1ll</span>*a[i].p*a[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    rot[<span class="number">0</span>]=rot[<span class="number">1</span>];</span><br><span class="line">    ll g=<span class="number">0</span>,lim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(g,lim);</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nN,mid=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(lim&lt;=t[rot[mid]].w&amp;&amp;<span class="built_in">query</span>(rot[mid],<span class="number">0</span>,nN,lim)&lt;=g)&#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(a[res].d,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P4606</title>
    <url>/2023/12/06/P4606/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4606">P4606 [SDOI2018]
战略游戏</a></p>
<span id="more"></span>
<p>是 <a href="https://www.luogu.com.cn/problem/P4320">P4320
道路相遇</a> 的严格强化版。</p>
<p>观察题目，要数割点。</p>
<p>考虑建圆方树。</p>
<p>问题转化为：在圆方树上，求 <span class="math inline">\(S\)</span>
中所有两点之间路径的并集中，圆点个数 <span
class="math inline">\(C\)</span>，答案为 <span
class="math inline">\(C-|S|\)</span>。</p>
<p><span class="math inline">\(C\)</span> 就是对 <span
class="math inline">\(S\)</span> 建虚树后，虚树内圆点个数。</p>
<p>可以直接建虚树，做完了。</p>
<p>也可以不建，将集合 <span class="math inline">\(S\)</span>
中元素放到数列 <span class="math inline">\(A\)</span> 内，对 <span
class="math inline">\(A\)</span> 以 <code>dfs</code> 序为关键字排序，将
<span class="math inline">\(A\)</span> 首尾相接连成环，<strong><span
class="math inline">\(C\)</span> 等于 <span
class="math inline">\(A\)</span> 中相邻两点距离之和除二加上 <span
class="math inline">\(lca(A_1,A_{|S|})\)</span>
的贡献</strong>，距离定义为两点之间边权和，边权定义为儿子的点权，圆点点权为
<span class="math inline">\(1\)</span>，方点为 <span
class="math inline">\(0\)</span>。</p>
<p>感觉这个还挺有用的。</p>
<p>试图证明：画一个树，按 <code>dfs</code>
序从第一个点走到最后一个，然后再走回来，会发所有有贡献的边都经过了两次，但是我们规定边权的方式，导致经过的所有点中，深度最浅的点的点权不在能走过的边集内，所以要加上
<span class="math inline">\(lca(A_1,A_{|S|})\)</span> 的点权贡献。</p>
<p>时间复杂度 <span class="math inline">\(O(T\sum|S|\log
n)\)</span>。</p>
<p>能不能少出点多测题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> Tes,n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],T[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],sta[N],tp,dfncnt,nid;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfncnt;</span><br><span class="line">    sta[++tp]=u;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">                <span class="type">int</span> o=<span class="number">0</span>;nid++;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    o=sta[tp--];</span><br><span class="line">                    T[o].<span class="built_in">pb</span>(nid),T[nid].<span class="built_in">pb</span>(o);</span><br><span class="line">                &#125;<span class="keyword">while</span>(o!=v);</span><br><span class="line">                T[u].<span class="built_in">pb</span>(nid),T[nid].<span class="built_in">pb</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="keyword">namespace</span> LCA&#123;</span><br><span class="line">    <span class="type">int</span> fa[N],top[N],hson[N],dep[N],siz[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(hson,<span class="number">0</span>,<span class="built_in">sizeof</span>(hson));</span><br><span class="line">        <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="built_in">sizeof</span>(dfn));</span><br><span class="line">        dfncnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">        siz[u]=<span class="number">1</span>,dep[u]=dep[f]+<span class="number">1</span>,fa[u]=f;</span><br><span class="line">        dfn[u]=++dfncnt;</span><br><span class="line">        dis[u]=dis[f]+(u&lt;=n);</span><br><span class="line">        <span class="built_in">each</span>(v,T[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init1</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">        top[u]=tp;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">init2</span>(hson[u],tp);</span><br><span class="line">        <span class="built_in">each</span>(v,T[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init2</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">init1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> LCA::lca;</span><br><span class="line"><span class="type">int</span> s[N],k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    nid=n,tp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    LCA::<span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="built_in">re</span>(i,k)<span class="built_in">read</span>(s[i]);</span><br><span class="line">        <span class="built_in">sort</span>(s+<span class="number">1</span>,s+k+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfn[x]&lt;dfn[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,k)&#123;</span><br><span class="line">            ans+=dis[s[i]]+dis[s[i%k+<span class="number">1</span>]]-dis[<span class="built_in">lca</span>(s[i],s[i%k+<span class="number">1</span>])]*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans/<span class="number">2</span>-k;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lca</span>(s[<span class="number">1</span>],s[k])&lt;=n)ans++;</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,nid)&#123;</span><br><span class="line">        T[i].<span class="built_in">clear</span>();</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    dfncnt=tp=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(Tes);</span><br><span class="line">    <span class="keyword">while</span>(Tes--)&#123;</span><br><span class="line">        <span class="built_in">Main</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>虚树</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>P4630</title>
    <url>/2023/12/02/P4630/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4630">P4630 [APIO2018]
铁人两项</a></p>
<span id="more"></span>
<p>圆方树基础应用。</p>
<p>观察题目，发现能对 <span class="math inline">\(s,f\)</span> 贡献的
<span class="math inline">\(c\)</span> 集合为：<span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(f\)</span> 所有简单路径的并。</p>
<p>无向图上要求路径上每个点最多走一次，想到点双。</p>
<p>因为将无向图中点双缩成点之后，图上是没有环的。</p>
<p>也就是说任意点双之间路径唯一，那么只有在 <span
class="math inline">\(s,f\)</span> 路径上的点双才能包含合法的 <span
class="math inline">\(c\)</span>。</p>
<p>设 <span class="math inline">\(s,f\)</span> 上点双的集合为 <span
class="math inline">\(D\)</span>。</p>
<p>对于其他点双，从 <span class="math inline">\(s,f\)</span>
路径上的某个点离开 <span class="math inline">\(D\)</span>，走到 <span
class="math inline">\(c,c\not\in D\)</span> 后，为了回到 <span
class="math inline">\(f\)</span>，一定还要再回到 <span
class="math inline">\(D\)</span> 中。</p>
<p>因为缩点后无环，所以只能原路返回——这会造成点的重复访问，不合法。</p>
<p>所以我们要求出 <span class="math inline">\(\sum(\sum_{i\in
D}size(i))-2\)</span>，<span class="math inline">\(s,f\)</span> 是减去的
<span class="math inline">\(2\)</span>。</p>
<p>将原图处理成圆方树，在树上算答案就好了。</p>
<p>关于圆方树性质：</p>
<ul>
<li>方点只会连圆点，圆点只会连方点</li>
<li>圆方树节点个数为 <span class="math inline">\(O(n)\)</span> 个。</li>
<li>若原图中有 <span class="math inline">\(k\)</span>
个连通块，圆方树就是 <span class="math inline">\(k\)</span>
棵树组成的森林。</li>
<li>两点之间割点个数是：圆方树上两点之间圆点个数。</li>
<li>两点之间点双个数是：圆方树上两点之间方点个数。</li>
</ul>
<p>如何建树：原图中的点都是圆点，对每个点双新建一个方点，将点双内全部圆点连到方点上，删除原图全部的边。</p>
<p>现在建出圆方树，考虑对圆方树上点赋点权。</p>
<p>方点点权为这个点双的大小，圆点点权为 <span
class="math inline">\(-1\)</span>。</p>
<p>现在问题转化为：图上全部圆点点对路径上权值和之和（顺便也不用考虑
<span class="math inline">\(-2\)</span> 了，因为起止点都是圆点）。</p>
<p>可以拆贡献，对每个点在dfs过程中算出有多少对圆点点对会经过这个点，点权乘个数加到答案里即可。</p>
<p>当然也可以写换根DP，但是没啥必要。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],T[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],dfncnt,val[N];</span><br><span class="line"><span class="type">int</span> sta[N],tp,nid;</span><br><span class="line"><span class="type">int</span> subn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    subn++;</span><br><span class="line">    dfn[u]=low[u]=++dfncnt;</span><br><span class="line">    sta[++tp]=u;</span><br><span class="line">    val[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">                nid++;</span><br><span class="line">                T[nid].<span class="built_in">pb</span>(u),T[u].<span class="built_in">pb</span>(nid);</span><br><span class="line">                val[nid]++;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    T[nid].<span class="built_in">pb</span>(sta[tp]),T[sta[tp]].<span class="built_in">pb</span>(nid);</span><br><span class="line">                    val[nid]++;</span><br><span class="line">                &#125;<span class="keyword">while</span>(sta[tp--]!=v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=u&lt;=n;</span><br><span class="line">    <span class="built_in">each</span>(v,T[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        ans+=<span class="number">2ll</span>*siz[u]*siz[v]*val[u];</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="number">2ll</span>*siz[u]*(subn-siz[u])*val[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    nid=n;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            subn=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>P4694</title>
    <url>/2024/01/02/P4694/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4694">P4694 [PA2013]
Raper</a></p>
<span id="more"></span>
<p>双倍经验：<a href="https://www.luogu.com.cn/problem/CF802O">April
Fools' Problem (hard)</a></p>
<p>有一个 <span class="math inline">\(\log\)</span>
的线段树做法，实际上不如双 <span
class="math inline">\(\log\)</span>，慢两倍。</p>
<p>有只用一个优先队列的做法，不影响本质，一样的。</p>
<p>题意的约束非常网络流。</p>
<p>考虑费用流，建立源 <span class="math inline">\(s\)</span>，汇 <span
class="math inline">\(t\)</span>，以及 <span
class="math inline">\(n\)</span> 个点 <span
class="math inline">\(v_{1\cdots n}\)</span>。</p>
<p>连边：<span class="math inline">\((s,v_i)\)</span>，流量 <span
class="math inline">\(1\)</span>，费用 <span
class="math inline">\(a_i\)</span>；<span
class="math inline">\((v_i,v_{i+1})\)</span>，流量 <span
class="math inline">\(\infty\)</span>，费用 <span
class="math inline">\(0\)</span>；<span
class="math inline">\((v_i,t)\)</span>，流量 <span
class="math inline">\(1\)</span>，费用 <span
class="math inline">\(b_i\)</span>。</p>
<p>边均为双向。那么一个流量为 <span class="math inline">\(k\)</span> 的
<span class="math inline">\(s-t\)</span>
流对应一个方案，需要最小化的代价就是费用。</p>
<p>应该是较为自然的。但是复杂度需要优化。</p>
<p>使用 wqs二分+模拟费用流。</p>
<p>设流量为 <span class="math inline">\(x\)</span>，最小费用 <span
class="math inline">\(f(x)\)</span>
的图像<strong>下凸</strong>（最大费用是上凸）。</p>
<p>费用流流量都是 <span
class="math inline">\(1\)</span>，相当于要选流量个物品，最小化权值和，模型还是比较
wqs二分 的。</p>
<p>钦定流量的费用流很难模拟，复杂度不行。所以要利用 <span
class="math inline">\(f(x)\)</span> 的凸性来做，我们在过程中二分切线斜率
<span class="math inline">\(d\)</span>。</p>
<p>考虑 <span class="math inline">\(f(x)\)</span> 图像上一个切线 <span
class="math inline">\(y=dx+c\)</span>，切到了下凸壳某个点 <span
class="math inline">\((x,f(x))\)</span>。</p>
<p>有 <span class="math inline">\(f(x)=dx+c\)</span>，也就是 <span
class="math inline">\(c=f(x)-dx\)</span>。</p>
<p><span class="math inline">\(f(x)\)</span> 的实际意义是流量为 <span
class="math inline">\(x\)</span> 的最小费用；<span
class="math inline">\(-dx\)</span>
可以理解为：对每一个流量流出来的费用，都扣掉 <span
class="math inline">\(d\)</span>。也就是说，<span
class="math inline">\(c\)</span> 相当于对所有费用 <span
class="math inline">\(-d\)</span>
后的<strong>最小费用可行流</strong>的费用，这样跑的时候就不用考虑流量的限制问题了。</p>
<p>这张图上的最小费用可行流可以模拟费用流优化，具体过程待会再说。</p>
<p>如何让只知道斜率的直线切 <span
class="math inline">\(f(x)\)</span>？为什么要凑 <span
class="math inline">\(c\)</span> 的式子？</p>
<p>有性质：对于切线 <span
class="math inline">\(y=dx+c\)</span>，相比于其他和 <span
class="math inline">\(f(x)\)</span> 相交的 <span
class="math inline">\(y=dx+c&#39;\)</span>，切线的 <span
class="math inline">\(c\)</span> 一定是最小的。</p>
<p>所以我们用模拟费用流最小化 <span class="math inline">\(c\)</span>
的时候，就相当于算出了切线。注意到，因为流量要求恰好为 <span
class="math inline">\(k\)</span>，最终二分出的斜率对应直线和 <span
class="math inline">\(f(x)\)</span> 的切点一定是 <span
class="math inline">\((k,f(k))\)</span>，所以对算出来的 <span
class="math inline">\(c\)</span> 加上 <span
class="math inline">\(d_{ans}\times k\)</span> 就是答案，显然 <span
class="math inline">\(d_{ans}\times k\)</span> 是个定值。</p>
<p>总而言之：二分 <span
class="math inline">\(d\)</span>；模拟费用流最小化 <span
class="math inline">\(c=f(x)-dx\)</span>，并给出对于当前 <span
class="math inline">\(c_{\min}\)</span>
的费用，要多少流量（其实就是切点横坐标）；而根据这个流量，二分再去调整
<span class="math inline">\(d\)</span>（实质上是调整切点横坐标，直到它为
<span class="math inline">\(k\)</span>）。</p>
<p>对于这个调整，具体的，如果流量大于 <span
class="math inline">\(k\)</span>，太靠右了，向左移动切点，不然就向右移动切点。对应成斜率分别是减小和增大。</p>
<p>上述是 wqs二分 的原理。</p>
<p>如何模拟最小费用可行流？</p>
<p>采用动态加点的做法，假设一开始 <span class="math inline">\(v_{1\cdots
n}\)</span> 都不在图中，依次加入 <span
class="math inline">\(v_i\)</span>，并更新导出子图的最小费用流。加入
<span class="math inline">\(v_i\)</span> 时，导出子图加入了 <span
class="math inline">\((s,v_i),(v_i,t),(v_{i-1},v_i)\)</span>。考虑此时可能产生的负权增广路或环。</p>
<ul>
<li><span class="math inline">\(s\to v_j\to v_{j+1}\to \cdots\to v_i\to
t\)</span>，即选一个 <span class="math inline">\(a\)</span>
中未被选且满足：<span class="math inline">\(a_j\)</span> 最小、<span
class="math inline">\(j\le i\)</span> 的 <span
class="math inline">\(j\)</span>，选取 <span
class="math inline">\(a_j,\,b_i\)</span>。</li>
<li><span class="math inline">\(t\to v_j\to v_{j+1}\to \cdots\to v_i\to
t\)</span>，即选中一个 <span class="math inline">\(b\)</span>
中未被选中且满足：<span class="math inline">\(b_j\)</span> 最大、<span
class="math inline">\(j&lt;i\)</span> 的 <span
class="math inline">\(j\)</span>，去掉 <span
class="math inline">\(b_j\)</span>，选取 <span
class="math inline">\(b_i\)</span>。</li>
</ul>
<p>所有情况可以分为 <span class="math inline">\((v_i,t)\)</span> 不流 和
<span class="math inline">\((v_i,t)\)</span>
流一次这两种情况，后者又有上面两种情况，共三种，取费用最小的一种更新图的最小费用流即可。</p>
<p>很好理解，可以从配对的角度考虑，要么 <span
class="math inline">\(b\)</span> 和没选过的 <span
class="math inline">\(a\)</span> 匹配，要么 <span
class="math inline">\(b\)</span> 替换掉之前的</p>
<p>本质上是反悔贪心。</p>
<p>过程可以使用优先队列模拟，复杂度为 <span
class="math inline">\(O(n\log n\log V)\)</span>。</p>
<p><code>check</code> 中一些负数，取反，减法，是优先队列的
<code>cmp</code> 相关，不影响思路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> +<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N], b[N], sum;</span><br><span class="line">priority_queue&lt;ll&gt;q[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span> <span class="params">(ll lim)</span> </span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1</span>) <span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>()) q[i].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">re</span>(i, n) a[i] -= lim;</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        q[<span class="number">0</span>].<span class="built_in">push</span>(-a[i]);</span><br><span class="line">        ll x = INF;</span><br><span class="line">        <span class="keyword">if</span>(!q[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ll u = q[<span class="number">0</span>].<span class="built_in">top</span>();</span><br><span class="line">            x = b[i] - u;</span><br><span class="line">        &#125;</span><br><span class="line">        ll y = INF;</span><br><span class="line">        <span class="keyword">if</span>(!q[<span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ll u = q[<span class="number">1</span>].<span class="built_in">top</span>();</span><br><span class="line">            y = b[i] - u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>(x, y) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; y) &#123;</span><br><span class="line">                ++sz;</span><br><span class="line">                sum += x;</span><br><span class="line">                q[<span class="number">0</span>].<span class="built_in">pop</span>();</span><br><span class="line">                q[<span class="number">1</span>].<span class="built_in">push</span>(b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += y;</span><br><span class="line">                q[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">                q[<span class="number">1</span>].<span class="built_in">push</span>(b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) a[i] += lim;</span><br><span class="line">    <span class="keyword">if</span>(sz &gt;= m) sum += sz - m;</span><br><span class="line">    <span class="keyword">return</span> sz &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="built_in">re</span>(i, n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">re</span>(i, n) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e9</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l +r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">check</span>(res);</span><br><span class="line">    <span class="built_in">write</span>(sum + <span class="number">1ll</span> * m * res,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>凸包</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>wqs二分</tag>
        <tag>费用流</tag>
        <tag>模拟费用流</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P4735</title>
    <url>/2023/12/05/P4735/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4735">P4735
最大异或和</a></p>
<span id="more"></span>
<p>可持久化 <code>Trie</code> 的模板。</p>
<p>首先对于区间 <code>xor</code> 问题，将 <span
class="math inline">\(\oplus_{i=p}^n a_i\)</span> 转化为 <span
class="math inline">\(s_n\oplus s_{p-1}\)</span>，<span
class="math inline">\(s\)</span> 为前缀异或和。</p>
<p>那么询问的 <span class="math inline">\(s_n\oplus s_{p-1} \oplus
x\)</span> 就可以看作：给一个定值 <span
class="math inline">\(val=s[n]\oplus x\)</span>，求最大的 <span
class="math inline">\(s_p \oplus val,p\in[l-1,r-1]\)</span>。</p>
<p>这个问题可以用可持久化 <code>Trie</code> 解决。</p>
<p>先考虑 <span class="math inline">\(p\le r-1\)</span>，查询第 <span
class="math inline">\(r-1\)</span> 个版本的答案即可。</p>
<p>怎么处理 <span class="math inline">\(p\ge
l-1\)</span>？处理出每个点的 <span class="math inline">\(las\)</span>
标记，代表这个子树最后一次被遍历到的时间戳，那么答案就只存在于 <span
class="math inline">\(las\ge l-1\)</span>
的子树，一次插入会影响链上的所有 <span
class="math inline">\(las\)</span>，直接动态维护，在满足条件前提下贪心的找异或最大值即可。</p>
<p>这也提示我们，做数据结构题，满足约束的方式不仅仅有在结构上做（可持久化，树套树，二维数点一类），还可以考虑能否直接维护
<code>tag</code> 做约束。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log V)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],s[N],rot[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>],las;</span><br><span class="line">&#125;t[N*<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> ncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> ver,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>)&#123;t[x].las=ver;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> c=s[ver]&gt;&gt;d&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y)t[x].son[c^<span class="number">1</span>]=t[y].son[c^<span class="number">1</span>];</span><br><span class="line">    t[x].son[c]=++ncnt;</span><br><span class="line">    <span class="built_in">insert</span>(t[x].son[c],t[y].son[c],ver,d<span class="number">-1</span>);</span><br><span class="line">    t[x].las=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(x)].las,t[<span class="built_in">rs</span>(x)].las);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>)<span class="keyword">return</span> s[t[x].las]^val;</span><br><span class="line">    <span class="type">int</span> c=val&gt;&gt;d&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[t[x].son[c^<span class="number">1</span>]].las&gt;=l)<span class="keyword">return</span> <span class="built_in">query</span>(t[x].son[c^<span class="number">1</span>],val,l,d<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(t[x].son[c],val,l,d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    t[<span class="number">0</span>].las=<span class="number">-1</span>,rot[<span class="number">0</span>]=++ncnt;</span><br><span class="line">    <span class="built_in">insert</span>(rot[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]^a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        rot[i]=++ncnt;</span><br><span class="line">        <span class="built_in">insert</span>(rot[i],rot[i<span class="number">-1</span>],i,<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            rot[++n]=++ncnt;</span><br><span class="line">            s[n]=s[n<span class="number">-1</span>]^x;</span><br><span class="line">            <span class="built_in">insert</span>(rot[n],rot[n<span class="number">-1</span>],n,<span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">            <span class="built_in">write</span>(<span class="built_in">query</span>(rot[r<span class="number">-1</span>],s[n]^x,l<span class="number">-1</span>,<span class="number">24</span>),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>P4841</title>
    <url>/2024/01/04/P4841/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4841">P4841
[集训队作业2013] 城市规划</a></p>
<span id="more"></span>
<p>数 <span class="math inline">\(n\)</span>
个点的简单有标号无向连通图个数。</p>
<p>尝试枚举做法，枚举到二项式形式，思考。</p>
<p>设 <span class="math inline">\(f(n)\)</span> 为答案。</p>
<p>一般情况下， 要找一个比 <span class="math inline">\(f\)</span>
约束更弱，非常好求的函数 <span class="math inline">\(g\)</span>。且
<span class="math inline">\(f\)</span> 可以通过一些形式得到 <span
class="math inline">\(g\)</span>。</p>
<p>重边自环看起来就不太会自然出现，<span
class="math inline">\(f\)</span> 的约束中最难做的就是 图连通。</p>
<p>那就去掉图连通，设 <span class="math inline">\(g(n)\)</span> 为 <span
class="math inline">\(n\)</span> 个点的图的方案数，显然 <span
class="math inline">\(g(n)=2^{\binom{n}{2}}\)</span>。</p>
<p>我们可以枚举<strong>某一个</strong>连通块的大小 <span
class="math inline">\(i\)</span>，算 <span class="math inline">\(\sum
f(i)\)</span>，而剩下的 <span class="math inline">\(n-i\)</span>
个随意，也就是 <span
class="math inline">\(g(n-i)\)</span>，这是计数的经典思想：人为指定一个“特别的部分”，对它钦定大小，并枚举全部的大小保证不重不漏，而对于这部分之外的个数，递归到子问题。</p>
<p>乘法原理一下，可以写出式子： <span class="math display">\[
g(n)=\sum_{i=1}^n\binom{n-1}{i-1}f(i)g(n-i)
\]</span> <span class="math inline">\(f(i),g(n-i)\)</span>
都是不指定“具体数哪些点”的，也就是说，<span
class="math inline">\(\binom{n-1}{i-1}\)</span>
数的必须是一个“明确”的连通块，这里钦定它是某个确定点所在的连通块，<span
class="math inline">\(i\)</span> 是这个块的大小。不需要乘 <span
class="math inline">\(n\)</span> 来计算“以每个点为确定点”，容易发现乘
<span class="math inline">\(n\)</span> 就数重了。</p>
<p>代换一手。 <span class="math display">\[
\begin{aligned}
&amp;2^{\binom{n}{2}}=\sum_{i=1}^n\binom{n-1}{i-1}f(i)2^{\binom{n-i}{2}}\\
&amp;2^{\binom{n}{2}}=\sum_{i=1}^n\frac{(n-1)!f(i)2^{\binom{n-i}{2}}}{(n-i)!(i-1)!}\\
&amp;\frac{2^\binom{n}{2}}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{2^\binom{n-i}{2}}{(n-i)!}\\
\end{aligned}
\]</span> 发现是卷积形式，定义生成函数： <span class="math display">\[
\begin{aligned}
&amp;F(x)=\sum_{n=1}^\infty\frac{f(n)}{(n-1)!}x^n\\
&amp;G(x)=\sum_{n=1}^\infty\frac{2^\binom{n}{2}}{n!}x^n\\
&amp;H(x)=\sum_{n=1}^\infty\frac{2^\binom{n}{2}}{(n-1)!}x^n\\
\end{aligned}
\]</span> 易得： <span class="math display">\[
H=F*G\mod x^{n+1}
\]</span> 需要 <span class="math inline">\(F\)</span>，变形： <span
class="math display">\[
F=H*G^{-1}\mod x^{n+1}
\]</span> <span class="math inline">\(H,G\)</span>
均已知，NTT做就可以。</p>
<p>代码注意多项式常数项，带入 <span class="math inline">\(n=0\)</span>
计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略多项式全家桶</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">130005</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,lim)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[lim]=<span class="built_in">qpow</span>(fac[lim],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">pe</span>(i,lim<span class="number">-1</span>)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vG,vH;</span><br><span class="line">    vG.<span class="built_in">pb</span>(<span class="number">1</span>),vH.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> pw=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pw=<span class="built_in">qpow</span>(<span class="number">2</span>,i*<span class="number">1ll</span>*(i<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        vG.<span class="built_in">pb</span>(<span class="number">1ll</span>*pw*ifac[i]%mod);</span><br><span class="line">        vH.<span class="built_in">pb</span>(<span class="number">1ll</span>*pw*ifac[i<span class="number">-1</span>]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">G</span><span class="params">(vG)</span>,<span class="title">H</span><span class="params">(vH)</span></span>;</span><br><span class="line">    Poly F=H*<span class="built_in">inv</span>(G);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1ll</span>*F[n]*fac[n<span class="number">-1</span>]%mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P4886</title>
    <url>/2023/12/02/P4886/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4886">P4886 快递员</a></p>
<span id="more"></span>
<p>点分治思想的好题。</p>
<p>题意：给一棵带边权的树，树上 <span class="math inline">\(m\)</span>
个点对 <span class="math inline">\((u_i,v_i)\)</span>，求 <span
class="math inline">\(\min\limits_{c\in
tree}\max_{i=1}^mdis(u_i,c)+dis(v_i,c)\)</span>。</p>
<p>先找一些性质。</p>
<p>设当前要判断最优点是否为 <span
class="math inline">\(c\)</span>，以<span
class="math inline">\(c\)</span> 为根，<span
class="math inline">\(d_i\)</span> 为 <span
class="math inline">\(dis(u_i,c)+dis(v_i,c)\)</span>，<span
class="math inline">\(S=\{(u_i,v_i)|d_i=\max_{j=1}^m
d_j\}\)</span>。</p>
<p>如果有 <span class="math inline">\((u,v)\in S\)</span> 满足 <span
class="math inline">\(u,v\)</span> 分别位于 <span
class="math inline">\(c\)</span> 的两个子树内，简单分讨可得，<span
class="math inline">\(c\)</span> 无论向哪里移动，都不会使 <span
class="math inline">\((u,v)\)</span> 到 <span
class="math inline">\(c\)</span> 的距离（也就是答案）更小，所以 <span
class="math inline">\(c\)</span> 就是最优点。</p>
<p>进一步想，如果 <span class="math inline">\(S\)</span>
中的点对并不都在同一棵子树，那么无论 <span
class="math inline">\(c\)</span>
向哪个子树移动，都会使其他子树中的点对距离更大，答案变大，所以 <span
class="math inline">\(c\)</span> 就是最优点。</p>
<p>综上，只有所有 <span class="math inline">\((u,v)\in S\)</span>
都在同一棵子树（设为 <span class="math inline">\(tree(v)\)</span>）
中，才需要继续递归到 <span
class="math inline">\(tree(v)\)</span>，否则就可以<code>return</code>输出答案了。</p>
<p>直接模拟上述过程，复杂度最坏为 <span
class="math inline">\(O(nm)\)</span>，不可接受。</p>
<p>发现递归问题时，选的新点 <span class="math inline">\(c\)</span>
所在位置并不重要，只要在子树内就行。</p>
<p>可以利用点分治的思想，每次以 <span
class="math inline">\(tree(v)\)</span> 中的重心做新的 <span
class="math inline">\(c\)</span>，去计算答案，因为重心的重儿子<code>size</code><span
class="math inline">\(\le \frac{size(tree(v))}{2}\)</span>
，所以递归的深度不会超过 <span class="math inline">\(\log
n\)</span>，这是点分治的经典分析。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mxp[N],siz[N],vis[N],rt,all;</span><br><span class="line">pii qr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>,mxp[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getRot</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        mxp[u]=<span class="built_in">max</span>(mxp[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[u]=<span class="built_in">max</span>(mxp[u],all-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mxp[u]&lt;mxp[rt])rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    bel[u]=id;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        <span class="built_in">getDis</span>(v,u,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="type">int</span> buc[N],tp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>,dis[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        dis[v]=e[i].w;</span><br><span class="line">        <span class="built_in">getDis</span>(v,u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">    tp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[qr[i].fi]+dis[qr[i].se]&gt;mx)&#123;</span><br><span class="line">            tp=<span class="number">0</span>;buc[++tp]=i;</span><br><span class="line">            mx=dis[qr[i].fi]+dis[qr[i].se];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[qr[i].fi]+dis[qr[i].se]==mx)&#123;</span><br><span class="line">            buc[++tp]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,mx);</span><br><span class="line">    <span class="built_in">re</span>(i,tp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[qr[buc[i]].fi]!=bel[qr[buc[i]].se])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!id)id=bel[qr[buc[i]].fi];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(id!=bel[qr[buc[i]].fi])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[rt=<span class="number">0</span>]=inf;</span><br><span class="line">    all=siz[id];</span><br><span class="line">    <span class="built_in">getRot</span>(id,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        qr[i]=<span class="built_in">mkp</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    all=n,mxp[rt=<span class="number">0</span>]=inf;</span><br><span class="line">    <span class="built_in">getRot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树的重心</tag>
        <tag>分治</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4931</title>
    <url>/2023/12/28/P4931/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4931">P4931 [MtOI2018]
情侣？给我烧了！（加强版）</a></p>
<span id="more"></span>
<p>记 <span class="math inline">\(f(n)\)</span> 为 <span
class="math inline">\(n\)</span>
对情侣全都<strong>不配对</strong>的方案数。</p>
<p>要计算<strong>恰好</strong> <span class="math inline">\(k\)</span>
对配对，男女分别 <span class="math inline">\(\dbinom{n}{k}\)</span>
种方案，<span class="math inline">\(k\)</span>
对随便排列，两排还能随意互换，剩下的需要全部不配对。</p>
<p>所以答案为 <span
class="math inline">\(\dbinom{n}{k}^2k!2^kf(n-k)\)</span>，现在问题在于怎么求
<span class="math inline">\(f(x),x\in[0,n]\)</span>。</p>
<p>组合意义，太强大。</p>
<p>对于 <span class="math inline">\(f(x)\)</span>，有 <span
class="math inline">\(x\)</span>
排座位，考虑其中一排，这一排一共三种情况：两男，两女，一男一女但是不配对。</p>
<ul>
<li><p>两男：顺次选两男的方案是 <span
class="math inline">\(x(x-1)\)</span>，这个要先乘上。然后考虑他们的配偶在之后的配对情况。</p>
<p>如果不配对，那么就要将这两男<strong>看作是配对了</strong>，即有一对不再是不配对，方案为
<span class="math inline">\(f(x-1)\)</span>。</p>
<p>如果配对，那么这两个都不再是不配对，分别剩下的 <span
class="math inline">\(x-1\)</span>
排中选一排，且两人顺序可以交换，方案为 <span
class="math inline">\(2(x-1)f(x-2)\)</span>。</p></li>
<li><p>两女：和两男同理。</p></li>
<li><p>一男一女：可以发现其实和两男还是一样：要么这一男一女自己配上了，方案
<span
class="math inline">\(f(x-1)\)</span>；要么分别和另一女一男配对，<span
class="math inline">\(2(x-1)f(x-2)\)</span>。注意一男一女也可以是一女一男，系数是
<span class="math inline">\(2x(x-1)\)</span>。</p></li>
</ul>
<p>综上，<span
class="math inline">\(f(x)=4x(x-1)(f(x-1)+2(x-1)f(x-2))\)</span>。</p>
<p>边界：易得，<span class="math inline">\(f(0)=1,f(1)=0\)</span>。</p>
<p>直接预处理就做完了。</p>
<p>有生成函数写法，比较抽象而且暴力，正赛不考，没啥学的价值。</p>
<p>时间复杂度 <span class="math inline">\(O(n+T)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>+<span class="number">5</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,fac[N],ifac[N],pw[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[n-m]%mod*ifac[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n,i);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1ll</span>*<span class="built_in">C</span>(n,i)*<span class="built_in">A</span>(n,i)%mod*pw[i]%mod*f[n-i]%mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=fac[<span class="number">1</span>]=ifac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-5</span>)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(mod-mod/i)*ifac[mod%i]%mod;</span><br><span class="line">        f[i]=<span class="number">4ll</span>*i*(i<span class="number">-1</span>)%mod*(f[i<span class="number">-1</span>]+<span class="number">2ll</span>*(i<span class="number">-1</span>)*f[i<span class="number">-2</span>]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,N<span class="number">-5</span>)&#123;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%mod;</span><br><span class="line">        pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P5251</title>
    <url>/2024/01/16/P5251/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5251">P5251 [LnOI2019]
第二代图灵机</a></p>
<span id="more"></span>
<p>需要支持单点修改权值，区间修改颜色。同时颜色对答案有约束。</p>
<p>虽然有约束，但颜色并不会算进答案，考虑分开做。</p>
<p>数据结构题当然要先想询问再想修改。</p>
<p>注意到，<span class="math inline">\(a_i,y\ge
1\)</span>，选子区间的决策具有<strong>单调性</strong>，可以考虑双指针；而且题目保证<strong>数据随机生成</strong>。</p>
<p>容易发现，对于操作三，一个颜色连续段如果选肯定全选；对于操作四，只有长度为
<span class="math inline">\(1\)</span> 的段可以选。</p>
<p>我们可以对段做双指针。</p>
<p>怎么动态维护颜色段？随机数据就已经有提示，用珂朵莉树。</p>
<p>注：这里随机数据保证的是操作三，四的复杂度，毕竟我们需要双指针扫一遍，遍历但不删除是只有期望复杂度正确的。</p>
<p>过程中需要查询区间和，加上操作一，用线段树做就行。</p>
<p>双指针过程比较显然，找到 <span class="math inline">\([l,r]\)</span>
中每个极长颜色段，用一个 <code>cnt</code>
记录每种颜色出现次数，按照询问要求做就好，具体见代码。</p>
<p>有一些启发：如果有一些特定性质，对序列“缩点”可能会使复杂度发生本质变化，数据结构题不要只想“信息”，“合并”，“标记”之类的做法，复杂度允许的情况下要灵活多变，采用双指针等较为“暴力”的东西。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2
n)\)</span>，随机数据的珂朵莉树做“遍历不删除”操作的复杂度就是两个 <span
class="math inline">\(\log\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,c,a[N],b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mx,mn,sum;</span><br><span class="line">    <span class="built_in">Seg</span>(<span class="type">int</span> mx_=-inf,<span class="type">int</span> mn_=inf,<span class="type">int</span> sum_=<span class="number">0</span>):<span class="built_in">mx</span>(mx_),<span class="built_in">mn</span>(mn_),<span class="built_in">sum</span>(sum_)&#123;&#125;</span><br><span class="line">    Seg <span class="keyword">operator</span>+(<span class="type">const</span> Seg&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        Seg c;</span><br><span class="line">        c.mx=<span class="built_in">max</span>(mx,b.mx);</span><br><span class="line">        c.mn=<span class="built_in">min</span>(mn,b.mn);</span><br><span class="line">        c.sum=sum+b.sum;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt]=t[<span class="built_in">ls</span>(rt)]+t[<span class="built_in">rs</span>(rt)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt]=<span class="built_in">Seg</span>(a[l],a[l],a[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt]=<span class="built_in">Seg</span>(v,v,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Seg <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    Seg res;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=res+<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=res+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,t;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> l_=<span class="number">0</span>,<span class="type">int</span> r_=<span class="number">0</span>,<span class="type">int</span> t_=<span class="number">0</span>):<span class="built_in">l</span>(l_),<span class="built_in">r</span>(r_),<span class="built_in">t</span>(t_)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;Node&gt; S;</span><br><span class="line"><span class="keyword">typedef</span> set&lt;Node&gt;::iterator sit;</span><br><span class="line"><span class="function">sit <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    sit p=S.<span class="built_in">lower_bound</span>(<span class="built_in">Node</span>(pos));</span><br><span class="line">    <span class="keyword">if</span>(p!=S.<span class="built_in">end</span>()&amp;&amp;p-&gt;l==pos)<span class="keyword">return</span> p;</span><br><span class="line">    p--;</span><br><span class="line">    Node tmp=*p;</span><br><span class="line">    S.<span class="built_in">erase</span>(p);</span><br><span class="line">    S.<span class="built_in">insert</span>(<span class="built_in">Node</span>(tmp.l,pos<span class="number">-1</span>,tmp.t));</span><br><span class="line">    <span class="keyword">return</span> S.<span class="built_in">insert</span>(<span class="built_in">Node</span>(pos,tmp.r,tmp.t)).fi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    sit p2=<span class="built_in">split</span>(r+<span class="number">1</span>),p1=<span class="built_in">split</span>(l);</span><br><span class="line">    S.<span class="built_in">erase</span>(p1,p2);</span><br><span class="line">    S.<span class="built_in">insert</span>(<span class="built_in">Node</span>(l,r,t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    <span class="keyword">if</span>(cnt[x]==<span class="number">1</span>)&#123;</span><br><span class="line">        tot++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span>(cnt[x]==<span class="number">0</span>)&#123;</span><br><span class="line">        tot--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAns_1</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,L,R).mn;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    sit p2=<span class="built_in">split</span>(R+<span class="number">1</span>),p1=<span class="built_in">split</span>(L),p=p1;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>,res=inf;</span><br><span class="line">    <span class="keyword">while</span>(p!=p2)&#123;</span><br><span class="line">        <span class="built_in">add</span>(p-&gt;t);</span><br><span class="line">        <span class="keyword">while</span>(tot==c)&#123;</span><br><span class="line">            t=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,p1-&gt;r,p-&gt;l).sum;</span><br><span class="line">            res=<span class="built_in">min</span>(res,t);</span><br><span class="line">            <span class="built_in">del</span>((p1++)-&gt;t);</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res==inf)res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAns_2</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    sit p2=<span class="built_in">split</span>(R+<span class="number">1</span>),p1=<span class="built_in">split</span>(L),p=p1;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>,res=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,L,R).mx;</span><br><span class="line">    <span class="keyword">while</span>(p!=p2)&#123;</span><br><span class="line">        cnt[p-&gt;t]++;</span><br><span class="line">        <span class="keyword">while</span>(p!=p1&amp;&amp;cnt[p-&gt;t]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            cnt[(p1++)-&gt;t]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p!=p1)&#123;</span><br><span class="line">            t=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,p1-&gt;r,p-&gt;l).sum;</span><br><span class="line">            res=<span class="built_in">max</span>(res,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;r-p-&gt;l&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=p1)cnt[(p1++)-&gt;t]--;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;</span><br><span class="line">    <span class="built_in">re</span>(i,n)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)cin&gt;&gt;b[i];</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">while</span>(b[p+<span class="number">1</span>]==b[p])p++;</span><br><span class="line">        S.<span class="built_in">insert</span>(<span class="built_in">Node</span>(i,p,b[i]));</span><br><span class="line">        i=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;t;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;t;</span><br><span class="line">            <span class="built_in">assign</span>(l,r,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">getAns_1</span>(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">getAns_2</span>(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>ODT</tag>
        <tag>线段树</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P5283</title>
    <url>/2023/12/05/P5283/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5283">P5283 [十二省联考
2019] 异或粽子</a></p>
<span id="more"></span>
<p>此题是求解异或问题的常用<code>trick</code>综合题。</p>
<p>题意：选 <span class="math inline">\(k\)</span> 个互不相同的区间
<span
class="math inline">\([l,r]\)</span>，其价值为区间内异或和，总价值为
<span class="math inline">\(k\)</span>
个区间价值之和，求最大总价值。</p>
<p>价值为 <span class="math inline">\(\oplus_{i=l}^r
a_i\)</span>，转化为 <span class="math inline">\(s_r\oplus
s_{l-1}\)</span>，<span class="math inline">\(s\)</span>
为前缀异或和。</p>
<p>题目转化为给一个 <span class="math inline">\(n+1\)</span> 的数组
<span class="math inline">\(s_i,i\in[0,n]\)</span>，求 <span
class="math inline">\(s_i\oplus s_j\)</span> 的 <span
class="math inline">\(\frac{n(n+1)}{2}\)</span> 种取值前 <span
class="math inline">\(k\)</span> 大之和。</p>
<p><span class="math inline">\(i&lt;j\)</span>
还带了个下标上的关系，比较麻烦，考虑交换 <span
class="math inline">\(i,j\)</span>，<span
class="math inline">\(s_i\oplus s_j=s_j\oplus s_i,s_i\oplus
s_i=0\)</span>，所以 <span class="math inline">\(n^2\)</span> 种无约束
<span class="math inline">\((i,j)\)</span> 中前 <span
class="math inline">\(2k\)</span> 大之和，就是答案的一半。</p>
<p>将全部 <span class="math inline">\(n^2\)</span>
个都排序显然不太现实，考虑用优先队列实现动态的加入/删除。</p>
<p>将对于一个 <span class="math inline">\(i\)</span> 的 的第 <span
class="math inline">\(n+1\)</span> 大 <span
class="math inline">\(s_i\oplus s_j\)</span>
先塞进优先队列，同时存一下目前取到了第几大。</p>
<p>取 <code>top</code>，<code>pop</code>
之后，对答案做贡献，如果目前最大元素取到了第 <span
class="math inline">\(m\)</span> 大（<span
class="math inline">\(m&gt;0\)</span>），再塞进第 <span
class="math inline">\(m-1\)</span> 大即可。</p>
<p>上述操作执行 <span class="math inline">\(2k\)</span> 次即可。</p>
<p>那么对于一个 <span class="math inline">\(i\)</span>，如何找到第 <span
class="math inline">\(m\)</span> 大的 <span
class="math inline">\(s_i\oplus s_j,j\in[1,n]\)</span> 呢？</p>
<p>使用高位浅，低位深的 <code>01-Trie</code>。</p>
<p>类比线段树二分写法，找第 <span class="math inline">\(m\)</span>
大即可。</p>
<p>时间复杂度为 <span class="math inline">\(O((n+k)(\log V+\log
n))\)</span>。</p>
<p>总结一下本题中相关的 <code>trick</code>：</p>
<ol type="1">
<li>做异或前缀和，区间异或和转化为两数异或和；</li>
<li>补全上三角形转化为求矩形的值；</li>
<li>求两两异或的第 <span class="math inline">\(k\)</span>
大值：从高位到低位，<code>Trie</code> 上贪心；</li>
<li>对原数组排序后，<code>Trie</code>
的一个子树对应数组的一个区间。</li>
</ol>
<p>此题还有可持久化 <code>Trie</code> 的写法，先鸽了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>],cnt;</span><br><span class="line">&#125;t[N*<span class="number">35</span>];</span><br><span class="line"><span class="type">int</span> n,k,ncnt=<span class="number">1</span>,a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw=<span class="number">1</span>;t[nw].cnt++;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">33</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        ll x=(v&gt;&gt;i)&amp;<span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[nw].son[x])t[nw].son[x]=++ncnt;</span><br><span class="line">        nw=t[nw].son[x];</span><br><span class="line">        t[nw].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nw=<span class="number">1</span>;ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">33</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        ll x=(v&gt;&gt;i)&amp;<span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[t[nw].son[x]].cnt&gt;=k)nw=t[nw].son[x];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k-=t[t[nw].son[x]].cnt;</span><br><span class="line">            nw=t[nw].son[x^<span class="number">1</span>];</span><br><span class="line">            res|=(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pqNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,k;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> pqNode&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pqNode&gt; q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    k*=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]^=a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i,n+<span class="number">1</span>,<span class="built_in">query</span>(a[i],n+<span class="number">1</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        pqNode x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=x.v;</span><br><span class="line">        <span class="keyword">if</span>(x.k)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x.id,x.k<span class="number">-1</span>,<span class="built_in">query</span>(a[x.id],x.k<span class="number">-1</span>)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans/<span class="number">2</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂项</category>
        <category>异或相关</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P5304</title>
    <url>/2023/12/02/P5304/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5304">P5304
[GXOI/GZOI2019] 旅行者</a></p>
<span id="more"></span>
<p>此题有两种复杂度的做法，都写在下文。</p>
<h3 id="二进制分组">二进制分组</h3>
<p>这是一种稍暴力的做法。</p>
<p>考虑将 <span class="math inline">\(k\)</span> 个点分为 <span
class="math inline">\(A,B\)</span> 两组，点 <span
class="math inline">\(st\)</span> 向 <span
class="math inline">\(A\)</span> 中连单向边，<span
class="math inline">\(B\)</span> 中点向 <span
class="math inline">\(ed\)</span> 连单向边（边权均为 <span
class="math inline">\(0\)</span>），那么到的最短路就为 <span
class="math inline">\(A\)</span> 内点到 <span
class="math inline">\(B\)</span> 内点的某条最短路径。（原因显然）</p>
<p>那么我们可以按照关键点编号的每一个二进制位分组，一共分 <span
class="math inline">\(\log k\)</span>
次，每次做上述连边然后跑最短路，过程中取 <span
class="math inline">\(\min\)</span> 就是答案。</p>
<p>为什么是对的？假设最终答案是 <span class="math inline">\(u,v\)</span>
的最短路，<span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>
之间至少有一个二进制位不同，只要分别在不同的组内，答案就一定会被算到。</p>
<p>时间复杂度 <span class="math inline">\(O(Tm\log n\log
k)\)</span>，不放代码了。</p>
<h3 id="正反图染色">正反图染色</h3>
<p>设 <span class="math inline">\(dis_1[p]\)</span> 为关键点到 <span
class="math inline">\(p\)</span> 最短路，<span
class="math inline">\(dis_2[p]\)</span> 为 <span
class="math inline">\(p\)</span> 到关键点最短路。</p>
<p>答案似乎变得明了：</p>
<p><span class="math inline">\(\min(\min\limits_{(u,v,w)\in
E}dis_1[u]+dis_2[v]+w,\min\limits_{u\in
V}dis_1[u]+dis_2[u])\)</span></p>
<p>这真的是答案吗？</p>
<p>有点问题：如果 <span class="math inline">\(dis_1[u]\)</span> 和 <span
class="math inline">\(dis_2[v]\)</span>
取到的是到同一个关键点的最短路怎么办？</p>
<p>所以我们需要在跑最短路的时候，记录 <span
class="math inline">\(dis_1[u]\)</span> 和 <span
class="math inline">\(dis_2[u]\)</span> 对应的关键点编号，分别记为 <span
class="math inline">\(f[u]\)</span> 和 <span
class="math inline">\(g[u]\)</span>。</p>
<p>计算 <span class="math inline">\(\min\limits_{(u,v,w)\in
E}dis_1[u]+dis_2[v]+w\)</span> 的过程中，只对 <span
class="math inline">\(f[u]\ne g[v]\)</span> 的边取 <span
class="math inline">\(\min\)</span>。</p>
<p>计算 <span class="math inline">\(\min\limits_{u\in
V}dis_1[u]+dis_2[u]\)</span> 的过程中，只对 <span
class="math inline">\(f[u]\ne g[u]\)</span> 且不是关键点的点取 <span
class="math inline">\(\min\)</span>。</p>
<p>这为啥是对的？</p>
<p><del>没整理出像样的证明，看洛谷题解区吧</del></p>
<p>时间复杂度 <span class="math inline">\(O(Tm\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a[N],X[M],Y[M],W[M],col[<span class="number">2</span>][N],head[N],tot;</span><br><span class="line">ll dis[<span class="number">2</span>][N],ans;<span class="type">bool</span> vis[N],iscity[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,next,val;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll dis;<span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">node</span>(ll _dis=<span class="number">0</span>,<span class="type">int</span> _id=<span class="number">0</span>):<span class="built_in">dis</span>(_dis),<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].to=y;</span><br><span class="line">    e[tot].val=w;</span><br><span class="line">    e[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(ll *dis,<span class="type">int</span> *col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) dis[a[i]]=<span class="number">0</span>,col[a[i]]=a[i],pq.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>,a[i]));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=pq.<span class="built_in">top</span>().id;pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].val)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].val;</span><br><span class="line">                col[v]=col[u];</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">node</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="type">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y,w);</span><br><span class="line">        <span class="keyword">if</span>(x!=y) <span class="built_in">addedge</span>(x,y,w);</span><br><span class="line">        X[i]=x;Y[i]=y;W[i]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">read</span>(a[i]),iscity[a[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(dis[<span class="number">0</span>],col[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(X[i]!=Y[i]) <span class="built_in">addedge</span>(Y[i],X[i],W[i]);</span><br><span class="line">    <span class="built_in">Dijkstra</span>(dis[<span class="number">1</span>],col[<span class="number">1</span>]);</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=X[i];y=Y[i];w=W[i];</span><br><span class="line">        <span class="keyword">if</span>(col[<span class="number">0</span>][x]&amp;&amp;col[<span class="number">1</span>][y]&amp;&amp;col[<span class="number">0</span>][x]!=col[<span class="number">1</span>][y])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][x]+dis[<span class="number">1</span>][y]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!iscity[i]&amp;&amp;col[<span class="number">0</span>][i]&amp;&amp;col[<span class="number">0</span>][i]!=col[<span class="number">1</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=iscity[i]=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P5308</title>
    <url>/2024/01/03/P5308/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5308">P5308
[COCI2018-2019#4] Akvizna</a></p>
<span id="more"></span>
<p>显然DP。</p>
<p>有很自然的设计：</p>
<p>设 <span class="math inline">\(f(i,j)\)</span>
为<strong>倒数</strong>第 <span class="math inline">\(i\)</span>
轮（倒着正着转移而已，正着比较顺手，所以倒着做了，没本质区别），当前场上还剩
<span class="math inline">\(j\)</span> 个对手的最多奖金。注意是还剩，这
<span class="math inline">\(j\)</span> 个对手要留着。 <span
class="math display">\[
f(i,j)=\max_{p=0}^{j-1}f(i-1,p)+\frac{j-p}{j}
\]</span> <span class="math inline">\(p\)</span>
是枚举这一轮剩下多少。直接做是 <span
class="math inline">\(O(n^2k)\)</span> 的。</p>
<p>观察转移式，容易发现，<span
class="math inline">\(\frac{j-p}{j}\)</span> 对于固定的 <span
class="math inline">\(j\)</span> 来说有单调性。</p>
<p>对于决策 <span class="math inline">\(0\le q&lt;p\le j-1\)</span>，有
<span class="math inline">\(p\)</span> 优于 <span
class="math inline">\(q\)</span>，即： <span class="math display">\[
\begin{aligned}
f(i,p)+\frac{j-p}{j}&amp;&gt;f(i,q)+\frac{j-q}{j}\\
f(i,p)-f(i,q)&amp;&gt;\frac{p-q}{j}\\
\frac{f(i,p)-f(i,q)}{p-q}&amp;&gt;\frac{1}{j}
\end{aligned}
\]</span> 斜率形式。</p>
<p>单调队列维护这个上凸壳。使队头最优，保证队列中斜率 <span
class="math inline">\(\le \frac{1}{j}\)</span>
且单减。容易发现满足我们的需求。</p>
<p>复杂度 <span class="math inline">\(O(nk)\)</span>，还是不行。</p>
<p>恰好 <span class="math inline">\(k\)</span>，想到 wqs二分。</p>
<p>设 <span class="math inline">\(g(i)\)</span> 为恰好 <span
class="math inline">\(i\)</span> 轮的最优解，就是前面的第一维。</p>
<p>容易发现 <span class="math inline">\(g(i)\)</span>
是个<strong>上凸壳</strong>（打表或者瞪眼法或者注意到或者搞成费用流，凭感觉吧）。</p>
<p>按照套路，用斜率为 <span class="math inline">\(d\)</span> 的直线
<span class="math inline">\(l\)</span> 去切 <span
class="math inline">\(g(i)\)</span> 图像。切点为 <span
class="math inline">\((k,g(k))\)</span> 时满足恰好 <span
class="math inline">\(k\)</span> 个。</p>
<p>找切线还需要截距。有 <span
class="math inline">\(dx+b=g(x)\)</span>，变形，得 <span
class="math inline">\(g(x)-dx=b\)</span>。</p>
<p><span class="math inline">\(g(x)-dx\)</span>
的实际意义就是对每一轮的贡献都减去 <span
class="math inline">\(d\)</span>。</p>
<p>上凸壳的切线截距一定是所有斜率相同的有交点的直线中最大的。DP最大化
<span class="math inline">\(g(x)-dx\)</span>
就可以求出截距，过程中算出需要多少轮（切点横坐标）。</p>
<p>不断二分直到直线切 <span class="math inline">\((k,g(k))\)</span>
即可，答案为 <span class="math inline">\(b_{ans}+d_{ans}\times
k\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-12</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, k, cnt[N];</span><br><span class="line"><span class="type">int</span> q[N], head, tail;</span><br><span class="line">ld f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">slope</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[x] - f[y]) / (x - y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(ld d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; head &lt; tail &amp;&amp; <span class="built_in">slope</span>(q[head], q[head + <span class="number">1</span>]) - <span class="number">1.0</span> / i &gt; eps; ++head);</span><br><span class="line">        f[i] = f[q[head]] + (ld)(i - q[head]) / i - d;</span><br><span class="line">        cnt[i] = cnt[q[head]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; head &lt; tail &amp;&amp; <span class="built_in">slope</span>(q[tail - <span class="number">1</span>], q[tail]) - <span class="built_in">slope</span>(q[tail], i) &lt; -eps; --tail);</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[n] &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ld l = <span class="number">0</span>, r = <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(l);</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">9</span>) &lt;&lt; f[n] + k * mid &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>wqs二分</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P5385</title>
    <url>/2023/12/05/P5385/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5385">P5385 [Cnoi2019]
须臾幻境</a></p>
<span id="more"></span>
<p>值得看看的<code>LCT</code>使用技巧。</p>
<p>读完题，感觉十分抽象。</p>
<p>并查集？没法做。</p>
<p>在询问上多想一想，只需要得出连通块个数即可，不询问具体连通块是什么。</p>
<p>所以可以在另一个角度思考。</p>
<p>对不连通的图求生成树，最终会生成一个森林，森林中树的个数 等于
图连通块个数 等于 整个森林的 <span
class="math inline">\(|V|-|E|\)</span>。</p>
<p>平时被认为太过复杂/复杂度过高（相比并查集）的图论算法，在这里比并查集更优，因为可以用
<code>LCT</code>。</p>
<p>新增 <span class="math inline">\(m\)</span>
个虚点，分别代表每条边，边权（也就是边的编号）为这 <span
class="math inline">\(m\)</span> 个点的点权，加边 <span
class="math inline">\((u,v)\)</span> 时，就让 <span
class="math inline">\(u,v\)</span> 连向 代表 <span
class="math inline">\((u,v)\)</span> 的点。</p>
<p>用 <code>LCT</code>
维护该过程，当发现两端点已经连通，要形成环时，就删去环上最早加入的一条边，同时记录这条边被删除的时间
<code>del</code>，这里的时间就是当前想要加入的这条边的编号，相当于是在动态维护最大生成树。</p>
<p>为什么要最大生成树呢，这样每条边都尽可能的选用出现时间晚的，这就使得
<span class="math inline">\(r\)</span> 所对应的主席树中区间 <span
class="math inline">\([l,r]\)</span>
中边的出现是最多的，所以就保证了正确性。</p>
<p>有了删除时间，答案就变为 <span class="math inline">\(n-\sum_{i=l}^r
[del_i&gt;
r]\)</span>。这是一个二维数点，为了应付强制在线，写主席树即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,q,online;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>],fa,val,mn,rev;</span><br><span class="line">    &#125;t[N];</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isrot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">fa</span>(x))==x||<span class="built_in">rs</span>(<span class="built_in">fa</span>(x))==x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        t[x].mn=<span class="built_in">min</span>(&#123;t[x].val,t[<span class="built_in">ls</span>(x)].mn,t[<span class="built_in">rs</span>(x)].mn&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updrev</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="built_in">ls</span>(x),<span class="built_in">rs</span>(x));</span><br><span class="line">        t[x].rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[x].rev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ls</span>(x))<span class="built_in">updrev</span>(<span class="built_in">ls</span>(x));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">rs</span>(x))<span class="built_in">updrev</span>(<span class="built_in">rs</span>(x));</span><br><span class="line">            t[x].rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">fa</span>(x),z=<span class="built_in">fa</span>(y),k=<span class="built_in">rs</span>(y)==x,w=t[x].son[!k];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isrot</span>(y))t[z].son[<span class="built_in">rs</span>(z)==y]=x;</span><br><span class="line">        t[x].son[!k]=y;t[y].son[k]=w;</span><br><span class="line">        <span class="keyword">if</span>(w)<span class="built_in">fa</span>(w)=y;</span><br><span class="line">        <span class="built_in">fa</span>(y)=x,<span class="built_in">fa</span>(x)=z;</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sta[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> y=x,z=<span class="number">0</span>;</span><br><span class="line">        sta[++z]=y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isrot</span>(y))sta[++z]=y=<span class="built_in">fa</span>(y);</span><br><span class="line">        <span class="keyword">while</span>(z)<span class="built_in">pushdown</span>(sta[z--]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isrot</span>(x))&#123;</span><br><span class="line">            y=<span class="built_in">fa</span>(x),z=<span class="built_in">fa</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isrot</span>(y))<span class="built_in">rotate</span>((<span class="built_in">ls</span>(y)==x)^(<span class="built_in">ls</span>(z)==y)?x:y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;x=<span class="built_in">fa</span>(y=x))&#123;</span><br><span class="line">            <span class="built_in">splay</span>(x),<span class="built_in">rs</span>(x)=y,<span class="built_in">pushup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makerot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x),<span class="built_in">splay</span>(x),<span class="built_in">updrev</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findrot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x),<span class="built_in">splay</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ls</span>(x))<span class="built_in">pushdown</span>(x),x=<span class="built_in">ls</span>(x);</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x),<span class="built_in">access</span>(y),<span class="built_in">splay</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findrot</span>(y)!=x)<span class="built_in">fa</span>(x)=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">makerot</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findrot</span>(y)==x&amp;&amp;<span class="built_in">fa</span>(y)==x&amp;&amp;!<span class="built_in">ls</span>(y))&#123;</span><br><span class="line">            <span class="built_in">fa</span>(y)=<span class="built_in">rs</span>(x)=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">split</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> t[y].mn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SegT&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>],cnt;</span><br><span class="line">    &#125;t[N*<span class="number">40</span>];</span><br><span class="line">    <span class="type">int</span> ncnt,rot[N],tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        tmp=++ncnt;</span><br><span class="line">        t[tmp]=t[rt],t[tmp].cnt++,rt=tmp;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].cnt;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res+=<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res+=<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> SegT::rot;</span><br><span class="line"><span class="type">int</span> del[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q,online);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)LCT::t[i].val=LCT::t[i].mn=inf;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(e[i].u,e[i].v);</span><br><span class="line">        LCT::t[i+n].val=LCT::t[i+n].mn=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        u=e[i].u,v=e[i].v;</span><br><span class="line">        rot[i]=rot[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">            del[i]=i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(LCT::<span class="built_in">findrot</span>(u)==LCT::<span class="built_in">findrot</span>(v))&#123;</span><br><span class="line">            <span class="type">int</span> p=LCT::<span class="built_in">ask</span>(u,v);</span><br><span class="line">            LCT::<span class="built_in">cut</span>(e[p].u,p+n);</span><br><span class="line">            LCT::<span class="built_in">cut</span>(e[p].v,p+n);</span><br><span class="line">            del[p]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        LCT::<span class="built_in">link</span>(u,i+n);</span><br><span class="line">        LCT::<span class="built_in">link</span>(v,i+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!del[i])del[i]=m+<span class="number">1</span>;</span><br><span class="line">        rot[i]=rot[i<span class="number">-1</span>];</span><br><span class="line">        SegT::<span class="built_in">modify</span>(rot[i],<span class="number">1</span>,m+<span class="number">1</span>,del[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="keyword">if</span>(online)l=(l+ans)%m+<span class="number">1</span>,r=(r+ans)%m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">        ans=n-SegT::<span class="built_in">query</span>(rot[r],<span class="number">1</span>,m,r,m+<span class="number">1</span>)+SegT::<span class="built_in">query</span>(rot[l<span class="number">-1</span>],<span class="number">1</span>,m,r,m+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>主席树</tag>
        <tag>生成树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>P5556</title>
    <url>/2024/01/08/P5556/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5556">P5556
圣剑护符</a></p>
<span id="more"></span>
<p>对于查询操作，转化题意。</p>
<p>考虑 <span class="math inline">\(A\oplus
0=A\)</span>，也就是说，只要存在一个异或和为 <span
class="math inline">\(0\)</span> 的子集 <span
class="math inline">\(B\)</span>，那么对于任意的 <span
class="math inline">\(A\)</span>，满足 <span class="math inline">\(A\cap
B=\varnothing\)</span>，两个集合 <span class="math inline">\(A\cup
B,A\)</span> 就符合要求。</p>
<p>问题转为是否存在异或和为 <span class="math inline">\(0\)</span>
的点权。</p>
<p>这是线性基基本操作：将集合内的数插入线性基，如果插入失败，就说明有子集异或和为
<span class="math inline">\(0\)</span>。</p>
<p>插入失败，具体来讲，就是这组基中每一个线性基都不为 <span
class="math inline">\(0\)</span>。</p>
<p>点权值域为 <span class="math inline">\([0,2^{30})\)</span>，只有
<span class="math inline">\(30\)</span> 个线性基，也就是说，只要 <span
class="math inline">\(dis(u,v)&gt;30\)</span> 就一定存在。</p>
<p><span class="math inline">\(\le 30\)</span> 就直接暴力查询。</p>
<p>修改可以树剖，用树状数组维护即可。</p>
<p>时间复杂度 <span class="math inline">\(O((n+q)\log n+q\log
^2v)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,Lg=<span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> n,q,val[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N],top[N],siz[N],hson[N],dep[N];</span><br><span class="line"><span class="type">int</span> dfn[N],idx[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">init1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp,idx[u]=++dfncnt,dfn[dfncnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">init2</span>(hson[u],tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==hson[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">init2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(x;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))c[x]^=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(l,v);</span><br><span class="line">        <span class="built_in">add</span>(r+<span class="number">1</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(x;x;x-=<span class="built_in">lowbit</span>(x))res^=c[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LB</span>&#123;</span><br><span class="line">    <span class="type">int</span> b[Lg+<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,Lg)b[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(i,<span class="number">30</span>,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!b[i])&#123;</span><br><span class="line">                    b[i]=x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> x^=b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        t.<span class="built_in">add</span>(idx[top[u]],idx[u],w);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(idx[u]&gt;idx[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    t.<span class="built_in">add</span>(idx[u],idx[v],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">init2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        t.<span class="built_in">add</span>(i,val[dfn[i<span class="number">-1</span>]]^val[dfn[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> w=<span class="number">0</span>,lca=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            <span class="built_in">modify</span>(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            ans.<span class="built_in">clear</span>();</span><br><span class="line">            lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">            <span class="type">int</span> flg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dep[u]+dep[v]-dep[lca]*<span class="number">2</span>+<span class="number">1</span>&gt;=Lg)flg=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ans.<span class="built_in">insert</span>(t.<span class="built_in">ask</span>(idx[lca])))flg=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(u!=lca)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flg)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(!ans.<span class="built_in">insert</span>(t.<span class="built_in">ask</span>(idx[u])))flg=<span class="number">1</span>;</span><br><span class="line">                u=fa[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(v!=lca)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flg)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(!ans.<span class="built_in">insert</span>(t.<span class="built_in">ask</span>(idx[v])))flg=<span class="number">1</span>;</span><br><span class="line">                v=fa[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flg)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>树状数组</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>P6122</title>
    <url>/2024/01/03/P6122/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6122">P6122 [NEERC2016]
Mole Tunnels</a></p>
<span id="more"></span>
<p>考虑暴力费用流。</p>
<p>要回答每个鼹鼠前缀的答案，比较困难，硬写暴力可能还要跑 <span
class="math inline">\(m\)</span> 次费用流。</p>
<p>试试能不能模拟费用流。其实这种特殊简单图跑模拟费用流还是比较好做的。</p>
<p>先写出暴力费用流的建图：</p>
<ul>
<li><span class="math inline">\(S\to p_i\)</span>，容量 <span
class="math inline">\(1\)</span>，费用 <span
class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\(u\to fa(u)\)</span>，容量 <span
class="math inline">\(+\infty\)</span>，费用为 <span
class="math inline">\(1\)</span>。</li>
<li><span class="math inline">\(i\to T\)</span>，容量 <span
class="math inline">\(c_i\)</span>，费用为 <span
class="math inline">\(0\)</span>。</li>
</ul>
<p>注意，边是“流单向”的，当然建图要双向边。</p>
<p>考虑动态加入流量（鼹鼠）。</p>
<p>当前加入第 <span class="math inline">\(i\)</span>
个点，因为保证一定存在合法方案，<span class="math inline">\(S\)</span>
与前 <span class="math inline">\(i-1\)</span>
个点之间的流量肯定是满了，每一个流量都能流到 <span
class="math inline">\(T\)</span>，没有回流。</p>
<p>要找 <span class="math inline">\(s\to t\)</span>
的增广路，不太好找。注意到，加入新点 <span
class="math inline">\(i\)</span> 的时候，只有 <span
class="math inline">\(i\)</span> 满足“还有流量可以流”，也就是说只要找到
<span class="math inline">\(i\to t\)</span>
的增广路。因为是最小费用，那就贪心的找最近且还有食物的点。</p>
<p>动态维护即可。</p>
<p>记一个 <span class="math inline">\(f(i)\)</span> 表示 <span
class="math inline">\(p_i\)</span>
到它子树中最近的还有食物的点的距离，<span
class="math inline">\(g(i)\)</span> 表示这个最近点的编号，以下记 <span
class="math inline">\(p_i\)</span> 为 <span
class="math inline">\(i\)</span>。这里的距离是和流量相关的，是费用流定义下的距离（就是费用）。</p>
<p>因为这个树的形态固定，且高度为 <span class="math inline">\(\log
n\)</span>，所以可以暴力做。</p>
<p>找最近的点，子树内直接用 <span
class="math inline">\(g(i)\)</span>，子树外虽然无法到达，但这是费用流，给容量加一就好（反向边），暴力上跳。</p>
<p>找到距离 <span class="math inline">\(i\)</span> 最近的食物点 <span
class="math inline">\(v\)</span> 后，我们要走的路径是 <span
class="math inline">\(i\to lca(i,v)\to v\)</span>。</p>
<p>注意到方向的不同，在 <span class="math inline">\(i\to
lca(i,v)\)</span> 上，走的是正向边，容量减一；而 <span
class="math inline">\(lca(i,v)\to v\)</span>
是反向边，容量加一，过程中维护 <span
class="math inline">\(f,g\)</span>。</p>
<p>最后从 <span class="math inline">\(lca(i,v)\)</span>
再暴力上跳，修改到根的链上的 <span
class="math inline">\(f,g\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,c[N],p[N],f[N*<span class="number">2</span>],g[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;a)a=x,b=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flow[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    f[x]=inf;</span><br><span class="line">    <span class="keyword">if</span>(c[x])f[x]=<span class="number">0</span>,g[x]=x;</span><br><span class="line">    <span class="built_in">chk</span>(f[x],g[x],f[<span class="built_in">ls</span>(x)]+(flow[<span class="built_in">ls</span>(x)]&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>),g[<span class="built_in">ls</span>(x)]);</span><br><span class="line">    <span class="built_in">chk</span>(f[x],g[x],f[<span class="built_in">rs</span>(x)]+(flow[<span class="built_in">rs</span>(x)]&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>),g[<span class="built_in">rs</span>(x)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">upd</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="type">int</span> x=inf,v=<span class="number">0</span>,u=p[i],t=<span class="number">0</span>,lca=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;f[u]+t)x=f[u]+t,v=g[u],lca=u;</span><br><span class="line">            t+=(flow[u]&gt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">            u&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u=p[i];</span><br><span class="line">        ans+=x;</span><br><span class="line">        <span class="keyword">while</span>(u!=lca)&#123;</span><br><span class="line">            flow[u]--;</span><br><span class="line">            u&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">upd</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        c[v]--;</span><br><span class="line">        <span class="built_in">upd</span>(v);</span><br><span class="line">        <span class="keyword">while</span>(v!=lca)&#123;</span><br><span class="line">            flow[v]++;</span><br><span class="line">            v&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">upd</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(lca)<span class="built_in">upd</span>(lca),lca&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>模拟费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P6189</title>
    <url>/2023/12/02/P6189/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6189">P6189 [NOI Online #1
入门组] 跑步</a></p>
<span id="more"></span>
<p>此题是一道裸的拆分数问题，本质上也是 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(k\)</span> 均无标号的第二类斯特林数问题。</p>
<p>我们可以想到两个DP。</p>
<ol type="1">
<li>设 <span class="math inline">\(f[i][j]\)</span>：总和为 <span
class="math inline">\(i\)</span>，拆成的数不大于 <span
class="math inline">\(j\)</span> 的方案。</li>
<li>设 <span class="math inline">\(g[i][j]\)</span>：总和为 <span
class="math inline">\(i\)</span>，拆成了 <span
class="math inline">\(j\)</span> 个数的方案。</li>
</ol>
<p>他们的转移分别为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=f[i][j-1]+f[i-j][j]
&amp;g[i][j]=g[i-1][j-1]+g[i-j][j]
\end{aligned}
\]</span></p>
<p>第一种转移：<span class="math inline">\(\le j-1\)</span>
的方案加上至少有一个等于 <span class="math inline">\(j\)</span>
的方案。</p>
<p>第二种转移：前面的部分是拆出来一个 <span
class="math inline">\(1\)</span>；后面的意为把所有拆出来的数都加 <span
class="math inline">\(1\)</span>，总和也就从 <span
class="math inline">\(i-j\)</span> 变成 <span
class="math inline">\(i\)</span> 了。</p>
<p>两种DP的时间复杂度均为 <span
class="math inline">\(O(n^2)\)</span>，不能满足我们的要求。</p>
<p>但是可以两个一起用。</p>
<p>发现他们的状态设计很有趣：有一种根号分治的感觉。</p>
<p>且两种状态设计似乎分别是根号分治的两部分。</p>
<p>我们对于 <span class="math inline">\(f\)</span> 可以只转移拆出来的数
<span class="math inline">\(&lt;\sqrt{n}\)</span> 的部分，对于 <span
class="math inline">\(g\)</span> 只转移拆出来的数 <span
class="math inline">\(\ge \sqrt{n}\)</span> 的部分。</p>
<p>具体的，用 <span class="math inline">\(f\)</span> 求出 <span
class="math inline">\(j&lt;\sqrt{n}\)</span> 的方案，然后再改一改 <span
class="math inline">\(g\)</span> ，让他只转移 <span
class="math inline">\(\ge \sqrt{n}\)</span>
的数字，也就是第一维的“步长”为 <span
class="math inline">\(\sqrt{n}\)</span>即可。</p>
<p>最后用 <span class="math inline">\(f,g\)</span> 拼成一个 <span
class="math inline">\(n\)</span>：枚举 <span
class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span>
分成小块，<span class="math inline">\(n-i\)</span>
分成大块，两种方案相乘，再将所有 <span class="math inline">\(i\)</span>
的对应的方案相加即可。</p>
<p>由定义可得，<span class="math inline">\(f\)</span> 和 <span
class="math inline">\(g\)</span>
统计的两部分是互斥的，不会重复计数；同时正好可以覆盖 <span
class="math inline">\(n\)</span> 的全部方案。</p>
<p>总复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，可以通过。</p>
<p>另外一种做法是GF推五边形数定理递推式，比较抽象。</p>
<p>有一些链接：<a
href="https://www.luogu.com.cn/blog/StudyingFather/pentagonal-number-and-number-partitions">五边形数与整数拆分问题</a>，<a
href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86">费马多边形数定理</a>，<a
href="https://blog.csdn.net/visit_world/article/details/52734860">五边形数定理的一种证明</a>，内容没看懂，笔者太菜不写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span> + <span class="number">5</span>)</span>, <span class="title">sqN</span><span class="params">(<span class="number">320</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, p, B, S;</span><br><span class="line"><span class="type">int</span> f[N][sqN], g[N][sqN], X[N], Y[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, p);</span><br><span class="line">    B = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    S = n / B + <span class="number">1</span>; X[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, B - <span class="number">1</span>)f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j, B - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p;</span><br><span class="line">            X[i] = f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span>; Y[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lim = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        lim = <span class="built_in">min</span>(S, i);</span><br><span class="line">        <span class="built_in">re</span>(j, lim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B)(g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j)(g[i][j] += g[i - j][j]) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        <span class="built_in">re</span>(j, S) &#123;</span><br><span class="line">            (Y[i] += g[i][j]) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        (ans += <span class="number">1ll</span> * X[i] * Y[n - i] % p) %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P6442</title>
    <url>/2023/12/02/P6442/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6442">P6442
[COCI2011-2012#6] KOŠARE</a></p>
<span id="more"></span>
<p>（大概）三倍经验：CF449D，CF165E</p>
<p>这是一道高维前缀和（子集和DP）+ 容斥的 模板。</p>
<p>简单的想法是设 <span class="math inline">\(f[i][s]\)</span> 表示前
<span class="math inline">\(i\)</span> 个箱子，出现过的种类构成的集合为
<span class="math inline">\(s\)</span>
的方案数，只需要转移选还是不选当前箱子。</p>
<p>时间复杂度 <span
class="math inline">\(O(n2^m)\)</span>，不能通过本题。</p>
<p>考虑容斥 设 <span class="math inline">\(f[s]\)</span> 为种类集合为
<span class="math inline">\(s\)</span> 子集的箱子数。</p>
<p>可以通过高维前缀和在的时间复杂度内求出。</p>
<p>如何计算答案呢？</p>
<p>设 <span class="math inline">\(g[s]\)</span> 为：集合 <span
class="math inline">\(s\)</span> 中种类都不选，其他随便选的方案；</p>
<p><span class="math inline">\(c\)</span> 为 <span
class="math inline">\(s\)</span> 对全部种类的补集。</p>
<p><span class="math inline">\(g[s]=2^{f[c]}-1\)</span>。</p>
<p>原因显然：补集内随便选非空子集都可以。</p>
<p>设 <span class="math inline">\(ans_s\)</span> 为 <span
class="math inline">\(s\)</span> 内种类全都被选的方案</p>
<p>有：<span class="math inline">\(ans_s=\sum\limits_{i\subseteq
s}(-1)^{ |i| }g[i]\)</span>。</p>
<p>关于上式：设 <span class="math inline">\(A_i\)</span> 为种类 <span
class="math inline">\(i\)</span> 被选了的方案。</p>
<p>有容斥经典式子：<span
class="math inline">\(\left|\bigcap\limits_{i\in
U}A_i\right|=\sum\limits_{s\subseteq U}(-1)^{ |s|
}\left|\bigcap\limits_{i\in s}\overline A_i\right|\)</span></p>
<p>复杂度 <span class="math inline">\(O(m2^m)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span>,<span class="title">N</span><span class="params">(<span class="number">1.1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,box[N];</span><br><span class="line">ll f[N],pw2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="built_in">re</span>(j,k)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            box[i]|=(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        f[box[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s]+=f[s^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    pw2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)pw2[i]=pw2[i<span class="number">-1</span>]*<span class="number">2</span>%Mod;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ss=((<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)^i;</span><br><span class="line">        <span class="type">int</span> k=(__builtin_popcount(i)&amp;<span class="number">1</span>)?Mod<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        (ans+=k*<span class="number">1ll</span>*(pw2[f[ss]]<span class="number">-1</span>)%Mod)%=Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>子集和DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P6620</title>
    <url>/2023/12/28/P6620/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6620">P6620 [省选联考 2020
A 卷] 组合数问题</a></p>
<span id="more"></span>
<p>双倍经验：CF932E。</p>
<p>有组合意义的思路，但是没有普世价值，不写了。</p>
<blockquote>
<p>组合意义天地灭，代数推导保平安。</p>
</blockquote>
<p>没啥头绪，先把 <span class="math inline">\(f\)</span> 拆了。 <span
class="math display">\[
\begin{aligned}
&amp;\sum_{k=0}^nf(k)\times x^k\times \binom{n}{k}\\
=&amp;\sum_{k=0}^n\sum_{i=0}^ma_ik^i\times x^k\times \binom{n}{k}\\
=&amp;\sum_{i=0}^ma_i\sum_{k=0}^nk^ix^k\binom{n}{k}
\end{aligned}
\]</span> 考虑如何计算第二个和式。</p>
<p><del>众所周知</del>，第二类斯特林数有一个性质： <span
class="math display">\[
k^i=\sum_{j=0}^i{i\brace j}k^{\underline j}
\]</span> 可以对第二个和式做推导。 <span class="math display">\[
\begin{aligned}
&amp;\sum_{k=0}^nk^ix^k\binom{n}{k}\\
=&amp;\sum_{k=0}^nx^k\binom{n}{k}\sum_{j=0}^i{i\brace j}k^{\underline
j}\\
=&amp;\sum_{j=0}^i{i\brace j}\sum_{k=0}^n\binom{n}{k}k^{\underline
j}x^k\\
=&amp;\sum_{j=0}^i{i\brace j}\sum_{k=0}^n\binom{n}{k}\binom{k}{j}j!x^k\\
=&amp;\sum_{j=0}^i{i\brace
j}j!\sum_{k=0}^n\binom{n}{j}\binom{n-j}{k-j}x^k\\
=&amp;\sum_{j=0}^i{i\brace
j}\binom{n}{j}j!\sum_{k=0}^n\binom{n-j}{k-j}x^k\\
=&amp;\sum_{j=0}^i{i\brace j}n^{\underline
j}x^j\sum_{k=0}^{n-j}\binom{n-j}{k}x^k\\
=&amp;\sum_{j=0}^i{i\brace j}n^{\underline j}x^j(x+1)^{n-j}
\end{aligned}
\]</span>
最后一步是二项式定理，中间有一些众所周知的组合数变换，可以自行推推式子，不再赘述。</p>
<p>代回原式。 <span class="math display">\[
\begin{aligned}
\sum_{k=0}^nf(k)\times x^k\times \binom{n}{k}
=\sum_{i=0}^ma_i\sum_{j=0}^i{i\brace j}n^{\underline j}x^j(x+1)^{n-j}
\end{aligned}
\]</span> 第二类斯特林数递推式： <span class="math display">\[
{i\brace j}=j{i-1\brace j}+{i-1\brace j-1}
\]</span> 多做点预处理，省掉快速幂的 <span
class="math inline">\(\log\)</span>，复杂度 <span
class="math inline">\(O(m^2)\)</span>。</p>
<p>如果模数 <span class="math inline">\(p\)</span>
为质数，可以写多项式快速幂达到 <span class="math inline">\(O(m\log
m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n, x, P, m;</span><br><span class="line"><span class="type">int</span> a[N], S[N][N], px1[N], px2[N], J[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>)</span><br><span class="line">            ret = ret * <span class="number">1ll</span> * x % P;</span><br><span class="line">        x = x * <span class="number">1ll</span> * x % P, a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; P &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">re</span>(j, i)</span><br><span class="line">        &#123;</span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * <span class="number">1ll</span> * S[i - <span class="number">1</span>][j] % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        px1[i] = <span class="built_in">qpow</span>(x, i);</span><br><span class="line">        px2[i] = <span class="built_in">qpow</span>(x + <span class="number">1</span>, n - i);</span><br><span class="line">    &#125;</span><br><span class="line">    J[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, m)</span><br><span class="line">    &#123;</span><br><span class="line">        J[i] = J[i - <span class="number">1</span>] * <span class="number">1ll</span> * (n - i + <span class="number">1</span>) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, i)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + S[i][j] * <span class="number">1ll</span> * J[j] % P * px2[j] % P * px1[j]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + res * <span class="number">1ll</span> * a[i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>P6624</title>
    <url>/2024/01/01/P6624/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6624">P6624 [省选联考 2020
A 卷] 作业题</a></p>
<span id="more"></span>
<p>二合一题。</p>
<p>在数论无关的地方出现了 <span
class="math inline">\(\gcd\)</span>。</p>
<p>众所周知： <span class="math display">\[
\varphi*1=\textrm{id}
\]</span> 做欧拉反演，变式子，有： <span class="math display">\[
\begin{aligned}
&amp;\sum_{T}\left(\sum_{i=1}^{n-1}w_{e_i}\right)\times
\gcd(w_{e_1},\cdots,w_{e_{n-1}})\\
=&amp;\sum_{T}\left(\sum_{i=1}^{n-1}w_{e_i}\right)\times
\sum_{d|w_{e_1},\cdots,d|w_{e_{n-1}}}\varphi(d)\\
=&amp;\sum_{d}\varphi(d)\sum_{T,\;d|w_{e_1},\cdots,d|w_{e_{n-1}}}\left(\sum_{i=1}^{n-1}w_{e_i}\right)
\end{aligned}
\]</span> 考虑内层如何计算。</p>
<p>矩阵树定理所计算的是： <span class="math display">\[
\sum_{T}\prod_{e\in E}w_e
\]</span> 我们需要的是： <span class="math display">\[
\sum_{T}\sum_{e\in E}w_e
\]</span> 如何在乘法中找加法？</p>
<p>我们需要一种对象，可以通过某种 “与乘法性质相同的运算” 快速获得 <span
class="math inline">\(\sum w\)</span>。</p>
<p>都是线性变换。将 <span class="math inline">\(\prod\)</span> 中的
<span class="math inline">\(w\)</span>
变成一个多项式，或是向量，怎么理解都行。</p>
<p>对于 <span class="math inline">\(F(x)=w_ex+1\)</span>，容易发现：
<span class="math display">\[
[x^1]\prod_{e\in E} F(x)=\sum_{e\in E}w_e
\]</span> 所以维护一个多项式（实际上就两项）矩阵，高斯消元算任意 <span
class="math inline">\(n-1\)</span>
阶主子式的行列式，取一次项系数即可。</p>
<p>思想上和生成函数有点像的。</p>
<p>在多项式运算中，只需要维护前两项，也就是说，一直在 <span
class="math inline">\(\textrm{mod}\; x^2\)</span> 意义下进行。</p>
<p>对于多项式加减，直接对应加减。</p>
<p>多项式乘：<span
class="math inline">\((a+bx)(c+dx)=ac+(ad+bc)x\)</span>。</p>
<p>多项式除：<span
class="math inline">\(\dfrac{a+bx}{c+dx}=\dfrac{a}{c}+\dfrac{bc-ad}{c^2}x\)</span>。</p>
<p>多项式除的式子是怎么出来的：</p>
<p>设 <span class="math inline">\(C+Dx=\dfrac{1}{c+dx}\)</span>，即
<span class="math inline">\((C+Dx)(c+dx)\equiv1\mod x^2\)</span>。</p>
<p>拆开，<span class="math inline">\(Cc+Cdx+cDx+Ddx^2\equiv1\mod
x^2\)</span>。</p>
<p><span class="math inline">\(1\)</span> 是不含 <span
class="math inline">\(x\)</span> 的常数，<span
class="math inline">\(Ddx^2\)</span> 被模掉了，易得 <span
class="math inline">\(Cc=1,\,Cdx+cDx=0\)</span>，即 <span
class="math inline">\(C=\dfrac{1}{c},\,Cd+cD=0\)</span>。</p>
<p>代换，有 <span
class="math inline">\(\dfrac{d}{c}+cD=0\)</span>，易得：<span
class="math inline">\(D=-\dfrac{d}{c^2}\)</span>。</p>
<p>综上，<span
class="math inline">\(C+Dx=\dfrac{1}{c+dx}=\dfrac{1}{c}-\dfrac{dx}{c^2}\)</span>。</p>
<p>写一下，<span
class="math inline">\(\dfrac{a+bx}{c+dx}=(a+bx)(\dfrac{1}{c}-\dfrac{dx}{c^2})=\dfrac{a}{c}-\dfrac{adx}{c^2}+\dfrac{bx}{c}-\dfrac{bdx^2}{c^2}=\dfrac{a}{c}+\dfrac{bc-ad}{c^2}\mod
x^2\)</span>。</p>
<p>回到外层的约束。</p>
<p>枚举 <span class="math inline">\(d\)</span>，将满足 <span
class="math inline">\(d|w_e\)</span> 的 <span
class="math inline">\(e\)</span>
加入矩阵，算出答案后全部加起来就好。</p>
<p>注意处理 <span class="math inline">\(|E|&lt;n-1\)</span>
的情况，也就是图一定不连通的情况，这样就不用跑矩阵树了（贡献肯定是 <span
class="math inline">\(0\)</span>），时间得到优化。</p>
<p>可以预处理一下每个 <span class="math inline">\(d\)</span> 对应的
<span class="math inline">\(|E|\)</span>，根号的复杂度。</p>
<p>时间复杂度上界为 <span
class="math inline">\(O(n\sqrt{w}+\frac{\sum\sigma_0(w)}{n-1}\times
n^3)=O(n^2\sum\sigma_0(w))\)</span>，实际比较快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">poly</span>(<span class="type">int</span> _x=<span class="number">0</span>,<span class="type">int</span> _y=<span class="number">0</span>)&#123;x=_x,y=_y;&#125;</span><br><span class="line">    poly <span class="keyword">operator</span>+(<span class="type">const</span> poly&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">poly</span>((x+b.x)%mod,(y+b.y)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    poly <span class="keyword">operator</span>-(<span class="type">const</span> poly&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">poly</span>((x-b.x+mod)%mod,(y-b.y+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    poly <span class="keyword">operator</span>*(<span class="type">const</span> poly&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">poly</span>(<span class="number">1ll</span>*x*b.x%mod,(<span class="number">1ll</span>*x*b.y+<span class="number">1ll</span>*y*b.x)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    poly <span class="keyword">operator</span>/(<span class="type">const</span> poly&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="type">static</span> poly c;</span><br><span class="line">        <span class="type">int</span> ix=<span class="built_in">qpow</span>(b.x,mod<span class="number">-2</span>);</span><br><span class="line">        c.x=<span class="number">1ll</span>*x*ix%mod;</span><br><span class="line">        c.y=((<span class="number">1ll</span>*y*b.x<span class="number">-1ll</span>*x*b.y)%mod+mod)%mod*ix%mod*ix%mod;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss</span><span class="params">(vector&lt;vector&lt;poly&gt;&gt; g,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> rev=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i][i].x==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j][i].x)&#123;</span><br><span class="line">                    rev^=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">swap</span>(g[i],g[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        poly inv=<span class="built_in">poly</span>(<span class="number">1</span>,<span class="number">0</span>)/g[i][i];</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n)&#123;</span><br><span class="line">            poly d=g[j][i]*inv;</span><br><span class="line">            <span class="built_in">rep</span>(k,i,n)&#123;</span><br><span class="line">                g[j][k]=g[j][k]-d*g[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">poly <span class="title">ans</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)ans=ans*g[i][i];</span><br><span class="line">    <span class="keyword">if</span>(rev)ans=<span class="built_in">poly</span>()-ans;</span><br><span class="line">    <span class="keyword">return</span> ans.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(m+<span class="number">1</span>)</span>,<span class="title">y</span><span class="params">(m+<span class="number">1</span>)</span>,<span class="title">w</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> V=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x[i],y[i],w[i]);</span><br><span class="line">        V=<span class="built_in">max</span>(V,w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(V+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> getDiv=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i*i!=x)cnt[x/i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">getDiv</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">phi</span><span class="params">(V+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,V)&#123;</span><br><span class="line">        <span class="keyword">if</span>(phi[i])<span class="keyword">continue</span>;</span><br><span class="line">        phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=V;j+=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[j])phi[j]=j;</span><br><span class="line">            phi[j]=phi[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> getMat=[&amp;](<span class="type">int</span> div)&#123;</span><br><span class="line">        vector&lt;vector&lt;poly&gt;&gt; <span class="built_in">g</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;poly&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]%div)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> u=x[i],v=y[i];</span><br><span class="line">            g[u][u]=g[u][u]+<span class="built_in">poly</span>(<span class="number">1</span>,w[i]);</span><br><span class="line">            g[v][v]=g[v][v]+<span class="built_in">poly</span>(<span class="number">1</span>,w[i]);</span><br><span class="line">            g[u][v]=g[u][v]-<span class="built_in">poly</span>(<span class="number">1</span>,w[i]);</span><br><span class="line">            g[v][u]=g[v][u]-<span class="built_in">poly</span>(<span class="number">1</span>,w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">re</span>(i,V)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&lt;n<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*phi[i]*<span class="built_in">Gauss</span>(<span class="built_in">getMat</span>(i),n<span class="number">-1</span>)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>反演</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title>P6655</title>
    <url>/2023/12/02/P6655/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6655">P6655 [YsOI2020]
制高</a></p>
<span id="more"></span>
<p>直接数也能数，但是我写了期望相关。</p>
<p>我们可以求答案的期望，最后再乘上全部方案个数。</p>
<p>设制高点权值为 <span class="math inline">\(1\)</span>，否则为 <span
class="math inline">\(0\)</span>，<span
class="math inline">\(f[u]\)</span> 为点 <span
class="math inline">\(u\)</span> 的期望权值。</p>
<p>期望的线性性，有 <span
class="math inline">\(E(ans)=\sum\limits_{i=1}^nf[i]\)</span></p>
<p>考虑如何求 <span class="math inline">\(f[i]\)</span>。</p>
<p>式子非常直观：<span
class="math inline">\(f[i]=\dfrac{\sum_{j=l[i]}^{r[i]}f[j]\times
[h[i]\ge h[j]]}{(r[i]-l[i]+1)}\)</span></p>
<p>就是总权值除以总方案而已。</p>
<p>因为题目保证 <span class="math inline">\(1\le l[i]\le r[i]&lt;
i\)</span>，被贡献的部分都已经算完了，所以这样转移是正确的。</p>
<p>发现上面的和式是一个二维数点的形式，在主席树上在线做 或
按排序后树状数组离线做 均可。</p>
<p>最后通过期望算出答案：<span class="math inline">\(ans=E(ans)\times
\prod\limits_{i=1}^n(r[i]-l[i]+1)\)</span></p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>代码写的树状数组，比较简短。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span> + <span class="number">5</span>)</span>, <span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll c[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (x; x &lt;= n; x += <span class="built_in">lowbit</span>(x))c[x] = (c[x] + v) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (x; x; x -= <span class="built_in">lowbit</span>(x))res = (res + c[x]) % Mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ba;</span><br><span class="line"><span class="type">int</span> h[N], l[N], r[N], p[N];</span><br><span class="line">ll f[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n)inv[i] = (Mod - (Mod / i)) * inv[Mod % i] % Mod;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i], r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n)p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[x] == h[y])<span class="keyword">return</span> x &lt; y;</span><br><span class="line">        <span class="keyword">return</span> h[x] &lt; h[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        j = p[i];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            f[j] = <span class="number">1</span>;</span><br><span class="line">            ba.<span class="built_in">add</span>(j, f[j]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[j] = (ba.<span class="built_in">ask</span>(r[j]) - ba.<span class="built_in">ask</span>(l[j] - <span class="number">1</span>) + Mod) * inv[r[j] - l[j] + <span class="number">1</span>] % Mod;</span><br><span class="line">        ba.<span class="built_in">add</span>(j, f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>, prod = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)ans = (ans + f[i]) % Mod;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        prod = prod * (r[i] - l[i] + <span class="number">1</span>) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * prod % Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>主席树</tag>
        <tag>概率与期望</tag>
        <tag>DP优化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P6793</title>
    <url>/2024/01/15/P6793/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6793">P6793 [SNOI2020]
字符串</a></p>
<span id="more"></span>
<p>题目是一个匹配问题。为了先想明白题，转化成二分图匹配。</p>
<p>将 <span class="math inline">\(A,B\)</span>
中元素作为点，放在图两侧，对于点 <span class="math inline">\(s_1\in
A,s_2\in B\)</span>，边 <span class="math inline">\((s_1,s_2)\in
E\)</span> 的权值为 <span
class="math inline">\(k-\textrm{LCP}(s_1,s_2)\)</span>，答案就是二分图最小权匹配。</p>
<p>对于边权无性质的二分图带权匹配问题并没有（至少我不会）低于 <span
class="math inline">\(O(n^2)\)</span> 的解法，考虑边权性质。</p>
<p>定义 <span
class="math inline">\(w(s_1,s_2)=k-\textrm{LCP}(s_1,s_2)\)</span>，为了好做，我们可以将
<span class="math inline">\(s_1,s_2\)</span> 做延伸。<span
class="math inline">\(\textrm{LCP}(s_1,s_2)\)</span> 就是 <span
class="math inline">\(s_1,s_2\)</span> 开头位置 <span
class="math inline">\(i,j\)</span> 的后缀的 <span
class="math inline">\(\textrm{LCP}\)</span> 与 <span
class="math inline">\(|s_1|,|s_2|\)</span> 的 <span
class="math inline">\(\min\)</span>。</p>
<p>外层取 <span class="math inline">\(\min\)</span> 看起来比较烦人，因为
<span class="math inline">\(|s_1|=|s_2|\)</span>，需要再取 <span
class="math inline">\(\min\)</span> 只有 <span
class="math inline">\(s_1=s_2\)</span>
的情况，我们可以先将这种情况放着（最后会发现不需要做任何处理）。</p>
<p>现在可以重定义 <span
class="math inline">\(w(i,j)=k-\textrm{LCP}(i,j)\)</span>，这里 <span
class="math inline">\(\textrm{LCP}(i,j)\)</span> 是后缀 <span
class="math inline">\(i\)</span> 和后缀 <span
class="math inline">\(j\)</span> 之间的，<span
class="math inline">\(w(i,j)\)</span> 依然和每条边构成双射。</p>
<p>看到后缀 <span
class="math inline">\(\textrm{LCP}\)</span>，将两个串拼起来，想到后缀数组，想到
<span class="math inline">\(height\)</span> 区间 <span
class="math inline">\(\textrm{min}\)</span>。</p>
<p>以下关于下标的讨论，均以 <span class="math inline">\(height\)</span>
这个数列为“轴”。</p>
<p>因为是区间 <span class="math inline">\(\min\)</span>，容易发现，<span
class="math inline">\(\textrm{LCP}\)</span>
满足<strong>四边形不等式</strong>，怎么证都行，可以分讨最小值所在位置，可以用一些区间
<span class="math inline">\(\min\)</span> 的恒不等式。</p>
<p><span class="math inline">\(k\)</span> 是定值，那么 <span
class="math inline">\(w\)</span>
也就有四边形不等式的形式，不过是反过来的。</p>
<p>也就是说，<span class="math inline">\(w\)</span>
的相交大于等于包含，包含一定不劣。</p>
<p>对于 <span class="math inline">\(A=\{a,b\},B=\{c,d\}\)</span>
来说：</p>
<ul>
<li><span class="math inline">\(a&lt;c&lt;b&lt;d\)</span>，显然 <span
class="math inline">\((a,c),(b,d)\)</span> 匹配最优，这样 <span
class="math inline">\(\textrm{LCP}\)</span> 尽可能大。</li>
<li><span
class="math inline">\(a&lt;b&lt;c&lt;d\)</span>，我们有四边形不等式的形式，<span
class="math inline">\(\textrm{LCP}(a,c)+\textrm{LCP}(b,d)\le
\textrm{LCP}(a,d)+\textrm{LCP}(b,c)\)</span>，所以 <span
class="math inline">\(w(a,d)+w(b,c)\le w(a,c)+w(b,d)\)</span>，<span
class="math inline">\((a,d),(b,c)\)</span> 匹配更优。</li>
<li>容易发现其他情况和上述本质相同。</li>
</ul>
<p>综上，均遵循贪心规则：优先匹配 <span
class="math inline">\(\textrm{LCP}\)</span>
最长的。也就是优先匹配“最近的”，整体上来看就是一直在“包含”，而不是“相交”。</p>
<p>接下来比较 trivial，从大到小枚举 <span
class="math inline">\(\textrm{LCP}\)</span> 的长度 <span
class="math inline">\(l\)</span>，每次合并 <span
class="math inline">\(height[i]=l\)</span> 的 <span
class="math inline">\(sa_i,sa_{i-1}\)</span>
的信息，用并查集维护。具体的，需要维护集合内 <span
class="math inline">\(A\)</span> 集合元素数和 <span
class="math inline">\(B\)</span> 集合元素数，因为优先匹配 <span
class="math inline">\(\textrm{LCP}\)</span>
最长的，所以每次合并要尽可能多的匹配。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="keyword">namespace</span> SA</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sa[N], sa2[N], bin[N], rk[N], rk2[N], h[N], m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i, m) bin[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i, n) bin[rk[i]]++;</span><br><span class="line">        <span class="built_in">re</span>(i, m) bin[i] += bin[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">pe</span>(i, n) sa[bin[rk[sa2[i]]]--] = sa2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m = <span class="number">128</span>;</span><br><span class="line">        <span class="built_in">re</span>(i, n) rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, sa2[i] = i;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, n - k + <span class="number">1</span>, n) sa2[++cur] = i;</span><br><span class="line">            <span class="built_in">re</span>(i, n) <span class="keyword">if</span> (sa[i] &gt; k) sa2[++cur] = sa[i] - k;</span><br><span class="line">            <span class="built_in">Bsort</span>();</span><br><span class="line">            rk2[sa[<span class="number">1</span>]] = cur = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rk[sa[i]] != rk[sa[i - <span class="number">1</span>]] || rk[sa[i] + k] != rk[sa[i - <span class="number">1</span>] + k])</span><br><span class="line">                &#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">                rk2[sa[i]] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">            <span class="keyword">if</span> (cur == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            m = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k = h[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k)</span><br><span class="line">                k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k])</span><br><span class="line">                k++;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">            vec[k].<span class="built_in">pb</span>(rk[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace SA</span></span><br><span class="line"><span class="keyword">using</span> SA::h, SA::sa;</span><br><span class="line"><span class="type">int</span> fa[N], asiz[N], bsiz[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">leader</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">leader</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> lcp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">leader</span>(x), y = <span class="built_in">leader</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">min</span>(asiz[x], bsiz[y]);</span><br><span class="line">    ans += <span class="number">1ll</span> * <span class="built_in">max</span>(<span class="number">0</span>, k - lcp) * d, asiz[x] -= d, bsiz[y] -= d;</span><br><span class="line">    d = <span class="built_in">min</span>(bsiz[x], asiz[y]);</span><br><span class="line">    ans += <span class="number">1ll</span> * <span class="built_in">max</span>(<span class="number">0</span>, k - lcp) * d, bsiz[x] -= d, asiz[y] -= d;</span><br><span class="line">    asiz[y] += asiz[x];</span><br><span class="line">    bsiz[y] += bsiz[x];</span><br><span class="line">    fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> on = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; on &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; (s + on + <span class="number">2</span>);</span><br><span class="line">    s[on + <span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    n = on * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    SA::<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">re</span>(i, n) fa[i] = i;</span><br><span class="line">    <span class="built_in">re</span>(i, on) asiz[i] = (i + k - <span class="number">1</span> &lt;= on);</span><br><span class="line">    <span class="built_in">rep</span>(i, on + <span class="number">2</span>, n) bsiz[i] = (i - on - <span class="number">1</span> + k - <span class="number">1</span> &lt;= on);</span><br><span class="line">    <span class="built_in">per</span>(lcp, on, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : vec[lcp])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">merge</span>(sa[i], sa[i - <span class="number">1</span>], lcp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>四边形不等式</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>P6864</title>
    <url>/2023/12/02/P6864/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6864">P6864 [RC-03]
记忆</a></p>
<span id="more"></span>
<p>（NFLS 23-11-02 div2C）</p>
<p>先找前两种操作的性质。</p>
<p>发现在当前串后面加上一个 <span
class="math inline">\(()\)</span>，可以使答案增加最外层括号块个数，然后最外层括号块个数
<span class="math inline">\(+1\)</span>。</p>
<p>而将整个串包起来，可以使整个串变成一个括号块。</p>
<p>忽略撤销操作的前提下，
对答案的贡献序列形如：<code>1+2+3+4+1+1+2+3+4+5+1+2</code></p>
<p>（变成 <span class="math inline">\(1\)</span>
时就是操作二，线性增长时就是操作一）</p>
<p>发现撤销操作本质上是单点改操作序列。</p>
<p>为了保证复杂度显然需要数据结构维护，直接维护贡献序列并不好做。</p>
<p>我们可以把操作序列看成一个递推过程，这个过程可以通过矩阵加速。</p>
<p>设当前答案为 <span
class="math inline">\(f\)</span>（也就是贡献序列的一个前缀和），前缀的最后一个加数为
<span class="math inline">\(g\)</span> ，容易得到：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\begin{bmatrix}f&amp;g&amp;1\end{bmatrix}\times
\begin{bmatrix}1&amp;0&amp;0\\1&amp;1&amp;0\\1&amp;1&amp;1\end{bmatrix}=\begin{bmatrix}f+g+1&amp;g+1&amp;1\end{bmatrix}\\
&amp;\begin{bmatrix}f&amp;g&amp;1\end{bmatrix}\times
\begin{bmatrix}1&amp;0&amp;0\\0&amp;0&amp;0\\1&amp;1&amp;1\end{bmatrix}=\begin{bmatrix}f+1&amp;1&amp;1\end{bmatrix}
\end{aligned}
\]</span></p>
<p>这两种转移矩阵分别对应操作一和操作二。</p>
<p>将所有操作的转移矩阵挂在线段树上维护乘法即可。</p>
<p>撤销时可能会出现撤销了撤销操作，可以写类似于并查集的东西（路径压缩之类）</p>
<p>删除矩阵时只需要将对应位置改为单位矩阵即可。</p>
<p>时间复杂度 <span class="math inline">\(O(q\times 27\log
n)\)</span>，因为都是下三角矩阵，所以实现的好一点可以少点常数，但我摆了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123;</span><br><span class="line">    ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        a[<span class="number">2</span>][<span class="number">0</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">2</span>]=a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        mat c;c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            c.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> mat&amp; b)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]!=b.a[i][j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mat a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        mat val;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].val=t[<span class="built_in">ls</span>(rt)].val*t[<span class="built_in">rs</span>(rt)].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].val.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].val=a[pos];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> x[N],op[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    mat ans,op1,op2;</span><br><span class="line">    op1.<span class="built_in">set1</span>();</span><br><span class="line">    op2.<span class="built_in">set2</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)a[i].<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op[i]);</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            a[i]=op1;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">2</span>)&#123;</span><br><span class="line">            a[i]=op2;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x[i]);</span><br><span class="line">            <span class="keyword">if</span>(op[x[i]]==<span class="number">3</span>)&#123;</span><br><span class="line">                x[i]=x[x[i]];</span><br><span class="line">                <span class="keyword">if</span>(op[x[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[x[i]]==op1)a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">                    <span class="keyword">else</span> a[x[i]]=op1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[x[i]]==op2)a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">                    <span class="keyword">else</span> a[x[i]]=op2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">reset</span>();</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>]=ans.a[<span class="number">0</span>][<span class="number">1</span>]=ans.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        ans=ans*t.t[<span class="number">1</span>].val;</span><br><span class="line">        <span class="built_in">write</span>(ans.a[<span class="number">0</span>][<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P7214</title>
    <url>/2023/12/25/P7214/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7214">P7214 [JOISC2020]
治療計画</a></p>
<span id="more"></span>
<p>这道题有点牛的，算是势能线段树优化建图。</p>
<p>对题目做转化，变成最短路问题，这里很难说怎么想到最短路，说实话没啥逻辑上的东西，凭感觉吧，确实看起来是很像的。</p>
<p>可能会想到：以当前整个局面为状态，在状态之间连边，然后跑从全感染状态到全健康状态的最短路，但是这东西难做，没前途。</p>
<p>画图。找其他形式。</p>
<p>我们画一个二维平面，时间为纵轴，房屋为横轴，每次治疗是平行于横轴的线段。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/dwp0kc4f.png"
alt="sample" />
<figcaption aria-hidden="true">sample</figcaption>
</figure>
<p>发现治疗必须<strong>拼接</strong>成整个 <span
class="math inline">\([1,n]\)</span>，可以将线段之间的覆盖关系作为边，在治疗方案之间连边，以所有
<span class="math inline">\([1,*]\)</span> 为起点集合，<span
class="math inline">\([*,n]\)</span> 为终点集合，跑最短路。</p>
<p>这和第一种建模思路大相径庭，平时做题还是要多画图多观察。</p>
<p>直接建图为 <span class="math inline">\(O(m^2)\)</span>
级别，跑不过去。</p>
<p>考虑优化，线段树优化建图，线段树叶子是所有治疗方案，那么具体是能对哪个区间连边呢？</p>
<p>对于两个治疗方案 <span
class="math inline">\(i,j\)</span>，显然并不是只要 <span
class="math inline">\([L_i,R_i]\cap[L_j,R_j]\ne \varnothing\)</span>
就可以连边。易得，需要满足 <span class="math inline">\(R_i-L_j+1\ge
|T_i-T_j|\)</span>。</p>
<p>将方案按 <span class="math inline">\(T\)</span> 排序，对于 <span
class="math inline">\(i\le j\)</span> 来说（向右连的边），有 <span
class="math inline">\(R_i+T_i+1\ge L_j+T_j\)</span>；对于 <span
class="math inline">\(i&gt;j\)</span> 来说（向左连的边），有 <span
class="math inline">\(R_i-T_i+1\ge L_j-T_j\)</span>。</p>
<p>我们成功统一了下标，将这两个值当作点的属性，用两个线段树维护第二个属性的两种值（向左向右）。</p>
<p>对于当前点 <span
class="math inline">\(j\)</span>，在线段树上依照第一个属性暴力找符合条件的
<span
class="math inline">\(i\)</span>，此题是点权最短路，点权最短路有一个很好的性质：每个点只需要被转移一次，所以可以暴力。</p>
<p>具体的，线段树维护第二个属性的区间最小值，在线段树中遍历全部符合条件的
<span class="math inline">\(i\)</span>，打 <code>vis</code>
标记，然后将维护的值改为 <span
class="math inline">\(+\infty\)</span>，代表这个点不会再满足任何要求，不被访问。</p>
<p>关于复杂度：每次修改会使一条叶子到根的链上 <span
class="math inline">\(+\infty\)</span> 个数 <span
class="math inline">\(+1\)</span>，当个数等于长度的时候就不再访问子树，容易发现复杂度得到保证。</p>
<p>由于每个点只需要转移一次，我们甚至不需要建图，在对线段树搜索的时候直接对
<code>priority_queue</code> 做 <code>push</code> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p>
<p>注意 <span class="math inline">\(+\infty\)</span>
不能过小，<code>0x3f3f3f3f</code> 会错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,l,r;</span><br><span class="line">    ll c;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; pli;</span><br><span class="line">priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt;q;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">ll dis[N],dist;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="type">int</span> t[N*<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">SegT</span>()&#123;<span class="built_in">fill</span>(t,t+(N*<span class="number">8</span>),<span class="number">2e9</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt]=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)],t[<span class="built_in">rs</span>(rt)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt]=<span class="built_in">min</span>(t[rt],v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[l])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist+a[l].c,l&#125;);</span><br><span class="line">                vis[l]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t[rt]=<span class="number">2e9</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)]&lt;=v&amp;&amp;ml&lt;=mid)<span class="built_in">transfer</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">rs</span>(rt)]&lt;=v&amp;&amp;mr&gt;mid)<span class="built_in">transfer</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T1,T2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].t,a[i].l,a[i].r,a[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,[](Info x,Info y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.t&lt;y.t;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].l==<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a[i].c,i&#125;);</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T1.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,m,i,a[i].l-a[i].t);</span><br><span class="line">        T2.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,m,i,a[i].l+a[i].t);</span><br><span class="line">        dis[i]=<span class="number">1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">tie</span>(dist,u)=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        dis[u]=dist;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;<span class="number">1</span>)T1.<span class="built_in">transfer</span>(<span class="number">1</span>,<span class="number">1</span>,m,<span class="number">1</span>,u<span class="number">-1</span>,a[u].r+<span class="number">1</span>-a[u].t);</span><br><span class="line">        <span class="keyword">if</span>(u&lt;m)T2.<span class="built_in">transfer</span>(<span class="number">1</span>,<span class="number">1</span>,m,u+<span class="number">1</span>,m,a[u].r+<span class="number">1</span>+a[u].t);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].r==n)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e18</span>)ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>优化建图</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P7322</title>
    <url>/2023/12/02/P7322/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7322">P7322
「PMOI-4」排列变换</a></p>
<span id="more"></span>
<p>求 <span
class="math inline">\(\sum\limits_pw(f(p))\)</span>，考虑拆贡献。</p>
<p>因为是排列，所以出现过的最大值被取代之后 不会再出现第二次</p>
<p>所以可以将 <span class="math inline">\(w(a)\)</span> 转化为 <span
class="math inline">\(a\)</span> 内元素变动次数 <span
class="math inline">\(+1\)</span>（后文先暂时忽略这个 <span
class="math inline">\(+1\)</span> ）</p>
<p>那么什么时候当前窗口最大值产生变动呢？</p>
<p>最大值被弹出：</p>
<p><span
class="math inline">\(\sum\limits_{i=k}^nA_{i-1}^{k-1}(n-k)(n-k)!\)</span></p>
<p><span class="math inline">\(i\)</span> 为枚举到弹出的最大值，<span
class="math inline">\(A_{i-1}^{k-1}\)</span>为小于 <span
class="math inline">\(i\)</span> 的值域中随便选 <span
class="math inline">\(k-1\)</span> 个数，放在窗口内的排列数。</p>
<p><span class="math inline">\(n-k\)</span> 为窗口有 <span
class="math inline">\(n-k\)</span> 个位置个数，<span
class="math inline">\((n-k)!\)</span>为窗口外其他元素随意排列。</p>
<p>加入的是最大值的方案数同理，会发现和上式一样（两种操作是对称的）</p>
<p>但这里需要去重：可能会出现弹出旧最大值之后放入的数为新最大值，而这样的情况会被数两次。</p>
<p>钦定加入的数大于弹出的数，去掉的部分为：</p>
<p><span
class="math inline">\(\sum\limits_{i=k+1}^n\dbinom{i-1}{k}(k-1)!(n-k)(n-k+1)!\)</span></p>
<p><span class="math inline">\(i\)</span> 为加入的数，当前需要考虑 <span
class="math inline">\(k+1\)</span> 个数。</p>
<p>组合数为小于值域内选 <span class="math inline">\(k\)</span>
个数。<span
class="math inline">\((k-1)!\)</span>为除了加入弹出的两个最大值之外的数的全排列，<span
class="math inline">\(n-k\)</span> 为窗口位置，<span
class="math inline">\((n-k+1)!\)</span> 为窗口外元素全排列。</p>
<p>弹出大于加入同理。所以要去掉上式 <span class="math inline">\(\times
2\)</span></p>
<p>最后不要忘了在前文忽略掉的 <span
class="math inline">\(+1\)</span>，每个排列都会贡献至少 <span
class="math inline">\(1\)</span> ，所以应加上 <span
class="math inline">\(n!\)</span></p>
<p>注：排列的计数，要学会钦定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%Mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n],Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">pe</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">5e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,k,n)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(i<span class="number">-1</span>,k<span class="number">-1</span>))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*<span class="number">2ll</span>*fac[n-k]%Mod*(n-k)%Mod*fac[k<span class="number">-1</span>]%Mod;</span><br><span class="line">    <span class="type">int</span> del=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,k+<span class="number">1</span>,n)&#123;</span><br><span class="line">        del=(del+<span class="built_in">C</span>(i<span class="number">-1</span>,k))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    del=del*<span class="number">2ll</span>*fac[n-k<span class="number">-1</span>]%Mod*(n-k)%Mod*fac[k<span class="number">-1</span>]%Mod;</span><br><span class="line">    ans=(ans+fac[n])%Mod;</span><br><span class="line">    ans=(<span class="number">1ll</span>*ans-del+Mod)%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P7357</title>
    <url>/2023/12/11/P7357/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7357">P7357
「PMOI-1」中位数</a></p>
<span id="more"></span>
<p>是 <a href="https://h01yshhmy.github.io/2023/12/02/P2839/">P2839 |
h01yshhmy</a> 的树上带修版本。</p>
<p>先考虑询问：中位数，当然要二分。</p>
<p>问题转化为二分一个 <span
class="math inline">\(mid\)</span>，判断是否各自存在 <span
class="math inline">\(x,y\)</span> 在 <span
class="math inline">\(u,v\)</span> 为根子树内，满足 <span
class="math inline">\(x,y\)</span> 路径上点权大于等于 <span
class="math inline">\(mid\)</span> 的个数减去小于 <span
class="math inline">\(mid\)</span> 的个数 <span
class="math inline">\(\ge 0\)</span>，这是经典的。</p>
<p>路径相关，考虑树上差分，设 <span class="math inline">\(x_i=[w_i\ge
mid]-[w_i&lt;mid]\)</span>，<span class="math inline">\(d_u=\sum_{i\in
Anc(u)}w_i\)</span>，<span class="math inline">\(Anc(u)\)</span> 为
<span class="math inline">\(u\)</span> 的祖先集合，<span
class="math inline">\(x,y\)</span> 路径上权值和为：<span
class="math inline">\(d_x+d_y-2\times
d_{lca(u,v)}+x_{lca(u,v)}\)</span>，后两项均为定值，想要让这个值尽可能
<span class="math inline">\(\ge 0\)</span>，最大化前两项即可。</p>
<p>用主席树维护，时间轴为 <span
class="math inline">\(mid\)</span>，也就是值域——当然为了便于存根，最好离散化一下；第
<span class="math inline">\(i\)</span> 棵线段树内维护 当 <span
class="math inline">\(mid=i\)</span> 时，子树内最大 <span
class="math inline">\(d\)</span>，<span
class="math inline">\(mid+1\)</span> 的时候考虑有多少位置从 <span
class="math inline">\(+1\)</span> 变成 <span
class="math inline">\(-1\)</span>，需要做区间 <span
class="math inline">\(-2\)</span>，因为一个点的 <span
class="math inline">\(x\)</span> 被影响，会影响子树内全部 <span
class="math inline">\(d\)</span>。</p>
<p>现在考虑修改。</p>
<p>发现对一个数异或 <span class="math inline">\(1\)</span>
只会反复对它加一或减一，且一定是交替进行。</p>
<p>考虑修改一个数，会造成什么影响。</p>
<p>设 <span class="math inline">\(t\)</span> 为大于等于 <span
class="math inline">\(x\)</span> 的最小奇数。</p>
<p>显然 <span class="math inline">\(x\)</span> 反复异或 <span
class="math inline">\(1\)</span> 的取值范围是 <span
class="math inline">\([t-1,t]\)</span>，那么对于 <span
class="math inline">\(mid&gt;t\)</span> 和 <span
class="math inline">\(mid\le t-1\)</span>
的版本，不会发生改变，简单分讨就能得到。</p>
<p>也就是说只有 <span class="math inline">\(t\)</span>
会被影响，算出每个数会影响的版本 <span
class="math inline">\(t\)</span>，做区间修改即可，注意不能沿用 <span
class="math inline">\(t\)</span>
这个位置的老版本——可能会有多个版本包含老版本中的线段树节点，对于它们是不能修改的。</p>
<p>代码均使用标记永久化，比lazy tag好写很多，（其实不确定能不能用lazy
tag，等研究明白再写明）。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>],mx,tag;</span><br><span class="line">&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> ncnt,rot[N],n,q,a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],tL[N],tR[N],dfn[N],dfncnt;</span><br><span class="line"><span class="type">int</span> top[N],hson[N],siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[f]+<span class="number">1</span>,tL[u]=++dfncnt,fa[u]=f;</span><br><span class="line">    dfn[dfncnt]=u,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tR[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp;</span><br><span class="line">    <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx)+t[rt].tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    rt=++ncnt,t[rt].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt].mx=dep[dfn[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt||rt==o)rt=++ncnt,t[rt]=t[o];</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        t[rt].mx+=v,t[rt].tag+=v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),<span class="built_in">ls</span>(o),l,mid,ml,mr,v);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),<span class="built_in">rs</span>(o),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mx;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=-inf;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> res+t[rt].tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bas[N],effect[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; buc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        bas[++m]=a[i];</span><br><span class="line">        bas[++m]=a[i]^<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(bas+<span class="number">1</span>,bas+m+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">unique</span>(bas+<span class="number">1</span>,bas+m+<span class="number">1</span>)-bas<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(rot[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        effect[i]=<span class="built_in">lower_bound</span>(bas+<span class="number">1</span>,bas+m+<span class="number">1</span>,a[i])-bas;</span><br><span class="line">        buc[effect[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">        effect[i]+=(a[i]&amp;<span class="number">1</span>)^<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        rot[i]=rot[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:buc[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">modify</span>(rot[i],rot[i],<span class="number">1</span>,n,tL[j],tR[j],<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="type">int</span> p=effect[x];</span><br><span class="line">            <span class="built_in">modify</span>(rot[p],rot[p],<span class="number">1</span>,n,tL[x],tR[x],<span class="number">2</span>-(<span class="number">4</span>*(a[x]&amp;<span class="number">1</span>)));</span><br><span class="line">            a[x]^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(x,y);</span><br><span class="line">            <span class="type">int</span> lc=<span class="built_in">lca</span>(x,y),l=<span class="number">0</span>,r=m,mid=<span class="number">0</span>,sum=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                mid=l+r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">                sum+=<span class="built_in">query</span>(rot[mid],<span class="number">1</span>,n,tL[x],tR[x]);</span><br><span class="line">                sum+=<span class="built_in">query</span>(rot[mid],<span class="number">1</span>,n,tL[y],tR[y]);</span><br><span class="line">                sum-=<span class="number">2</span>*<span class="built_in">query</span>(rot[mid],<span class="number">1</span>,n,tL[lc],tL[lc])+(a[lc]&gt;=bas[mid]?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>)l=mid+<span class="number">1</span>,res=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write</span>(bas[res],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P7361</title>
    <url>/2023/12/22/P7361/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7361">P7361
「JZOI-1」拜神</a></p>
<span id="more"></span>
<p>有点毒瘤的串串题。</p>
<p>注：此题有个人感觉略带抽象的 <span
class="math inline">\(\textrm{SAM}\)</span>
做法，不是很会，之后看情况补一下。</p>
<p>题意：给一个字符串 <span class="math inline">\(s\)</span>，<span
class="math inline">\(q\)</span> 次询问，每次给 <span
class="math inline">\(l,r\)</span>，求 <span
class="math inline">\(s[l,r]\)</span> 中最长的子串，满足这个子串在 <span
class="math inline">\(s[l,r]\)</span>
中出现至少两次，输出这个子串的长度。</p>
<p>字符串题，还是考虑前后缀，要求出现至少两次，那就枚举一下。</p>
<p>在 <span class="math inline">\([l,r]\)</span> 中枚举 <span
class="math inline">\(p,q\)</span>，以这两个位置为两个串的开头，那么如果存在
<span class="math inline">\(p,q\in [l,r-L+1],p\ne q\)</span>，满足 <span
class="math inline">\(\textrm{LCP}(s[p:],s[q:])\ge L\)</span>，<span
class="math inline">\(L\)</span> 就可以成为答案。</p>
<p>不好直接求 <span
class="math inline">\(L\)</span>，发现对于合法的判断是满足可二分性的，可以对
<span class="math inline">\(L\)</span> 二分答案。</p>
<p>对于两个后缀的 <span
class="math inline">\(\textrm{LCP}\)</span>，我们用后缀数组求 <span
class="math inline">\(height\)</span> 来解决这个问题（简记 <span
class="math inline">\(h\)</span>）。经典的，<span
class="math inline">\(\textrm{LCP}(s[p:],s[q:])\ge L\)</span>
当且仅当所有 <span class="math inline">\(h_i\ge L\)</span> 的 <span
class="math inline">\(h_i=\textrm{LCP}(sa_{i-1},sa_i)\)</span>
对应的两个位置 <span class="math inline">\(sa_{i-1},sa_i\)</span>
连边时，<span class="math inline">\(p,q\)</span> 在同一个连通块。</p>
<p>这种东西每次询问都跑一次太浪费了，应该思考怎么预处理，并用结构存下信息，方便每次查询。</p>
<p>类似于 <a
href="https://h01yshhmy.github.io/2023/12/13/CF802I/">CF802I |
h01yshhmy</a> 的第二种写法，将 <span class="math inline">\(h\)</span>
从大到小排序，从大到小的合并 <span class="math inline">\(h\)</span>
对应的 <span
class="math inline">\(sa_{i-1},sa_i\)</span>，用并查集维护连通性。</p>
<p>但这显然不够，我们需要判断“是否存在一个点 <span
class="math inline">\(p\in [l,r-L+1]\)</span>，满足在 <span
class="math inline">\(L\)</span> 对应的连通块内存在一个点 <span
class="math inline">\(q\in[l,r-L+1],q\ne p\)</span>”。</p>
<p>可以利用一个贪心的思想，使用主席树 <span
class="math inline">\(T_{*}\)</span>，<span
class="math inline">\(T_L\)</span> 记录 <span
class="math inline">\(L\)</span> 的信息，线段树维护点 <span
class="math inline">\(p\)</span> 右边<strong>第一个</strong>和 <span
class="math inline">\(p\)</span> 在同一个连通块内的点编号 <span
class="math inline">\(nxt_p\)</span>，只要查询 <span
class="math inline">\([l,r-L]\)</span> 中的最小值要 <span
class="math inline">\(\le r-L+1\)</span>，就一定在某个地方存在合法 <span
class="math inline">\((p,q)\)</span>。</p>
<p>怎么求 <span class="math inline">\(nxt_p\)</span>
呢，需要在并查集合并连通块的同时做启发式合并维护信息，这部分比较trivial，思维难度主要在前面。</p>
<p>对并查集每个连通块的 <span class="math inline">\(fa\)</span> 维护一个
<code>set</code>，每次将 <span class="math inline">\(x\)</span> 插入
<span class="math inline">\(S\)</span>
的时候，<code>lower_bound</code>找到 <span
class="math inline">\(x\)</span> 的前驱 <span
class="math inline">\(i\)</span> 后继 <span
class="math inline">\(j\)</span>，在当前 <span
class="math inline">\(T_L\)</span> 上更新 <span
class="math inline">\(nxt_i\leftarrow x,nxt_x\leftarrow
j\)</span>，和链表插入是一样的结构。</p>
<p>可以每次将所有修改先存下来并排序，在处理完一个 <span
class="math inline">\(L\)</span>
后，再统一做主席树上的操作，这样重复经过的节点少一些，常数小。</p>
<p>容易发现每个 <span class="math inline">\(L\)</span>
的启发式合并可能会有 <span class="math inline">\(\log n\)</span>
次插入，所以主席树每个版本可能会增加 <span class="math inline">\(\log^2
n\)</span> 级别的节点（实际上没这么多），所以空间上要多开一点。</p>
<p>时间和空间复杂度均为 <span class="math inline">\(O(n\log^2
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e4</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line"><span class="type">int</span> sa[N], sa2[N], bin[N], rk[N], rk2[N], h[N], m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) bin[rk[i]]++;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] += bin[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">pe</span>(i, n) sa[bin[rk[sa2[i]]]--] = sa2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, sa2[i] = i;</span><br><span class="line">    <span class="built_in">Bsort</span>();</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, n - k + <span class="number">1</span>, n) sa2[++cur] = i;</span><br><span class="line">        <span class="built_in">re</span>(i, n) <span class="keyword">if</span> (sa[i] &gt; k) sa2[++cur] = sa[i] - k;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        rk2[sa[<span class="number">1</span>]] = cur = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[sa[i]] != rk[sa[i - <span class="number">1</span>]] || rk[sa[i] + k] != rk[sa[i - <span class="number">1</span>] + k]) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rk2[sa[i]] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">        <span class="keyword">if</span> (cur == n) <span class="keyword">break</span>;</span><br><span class="line">        m = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            k = h[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k) k--;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k++;</span><br><span class="line">        h[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace SA</span></span><br><span class="line"><span class="keyword">using</span> SA::h, SA::sa;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>], val;</span><br><span class="line">&#125; t[N * <span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> ncnt, rot[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    rt = ++ncnt, t[rt].val = N;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pii&gt; modi;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].val = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].val, t[<span class="built_in">rs</span>(rt)].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt, <span class="type">int</span> old, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modi.<span class="built_in">empty</span>() || modi.<span class="built_in">back</span>().fi &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    rt = ++ncnt;</span><br><span class="line">    t[rt] = t[old], t[rt].val = N;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[rt].val = modi.<span class="built_in">back</span>().se;</span><br><span class="line">        modi.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">ls</span>(rt), <span class="built_in">ls</span>(old), l, mid);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt), <span class="built_in">rs</span>(old), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; qr || (!rt)) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt].val;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>, res = N;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N], upd[N], id[N], cnt;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; S[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!upd[pos]) id[++cnt] = pos;</span><br><span class="line">    upd[pos] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x), y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (S[x].<span class="built_in">size</span>() &lt; S[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : S[y]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = S[x].<span class="built_in">lower_bound</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (p != S[x].<span class="built_in">end</span>()) <span class="built_in">update</span>(i, *p);</span><br><span class="line">        <span class="keyword">if</span> (p != S[x].<span class="built_in">begin</span>()) <span class="built_in">update</span>(*--p, i);</span><br><span class="line">        S[x].<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    S[y].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    SA::<span class="built_in">getSA</span>();</span><br><span class="line">    SA::<span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="built_in">build</span>(rot[n], <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">static</span> pii p[N];</span><br><span class="line">    <span class="built_in">re</span>(i, n) fa[i] = i, S[i].<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">re</span>(i, n - <span class="number">1</span>) p[i] = &#123; h[i + <span class="number">1</span>], i + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, pt = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>, modi.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (pt &amp;&amp; p[pt].fi == i) &#123;</span><br><span class="line">            <span class="type">int</span> q = p[pt].se;</span><br><span class="line">            <span class="built_in">merge</span>(sa[q - <span class="number">1</span>], sa[q]);</span><br><span class="line">            pt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pe</span>(i, cnt) &#123;</span><br><span class="line">            modi.<span class="built_in">pb</span>(&#123; id[i], upd[id[i]] &#125;);</span><br><span class="line">            upd[id[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modi.<span class="built_in">empty</span>())</span><br><span class="line">            rot[i] = rot[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">modify</span>(rot[i], rot[i + <span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ql = <span class="number">0</span>, qr = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, q) &#123;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">        l = <span class="number">0</span>, r = qr - ql;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(rot[mid], <span class="number">1</span>, n, ql, qr - mid) &lt;= qr - mid + <span class="number">1</span>) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>启发式合并</tag>
        <tag>并查集</tag>
        <tag>字符串</tag>
        <tag>扫描线</tag>
        <tag>SA</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>P7453</title>
    <url>/2023/12/11/P7453/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7453">P7453 [THUSCH2017]
大魔法师</a></p>
<span id="more"></span>
<p>在做这道题之前一直以为 <span
class="math inline">\(A[i]=A[i]+B[i]\times k,i\in [l,r]\)</span> 这种
两个数组区间上相加的 转移是不好做的，所以写个题解。</p>
<p>显然要线段树。</p>
<p>一开始的思路是对 <span class="math inline">\(A,B,C\)</span>
分别维护线段树，但是并不能做，<span class="math inline">\(A,B,C\)</span>
需要塞到一起才能完成题目中的修改操作。</p>
<p>可以都放到同一个矩阵内，直接给</p>
<p><span class="math display">\[
\begin{bmatrix}A&amp;B&amp;C&amp;1\end{bmatrix}
\]</span></p>
<p>乘上对应的 <span class="math inline">\(4\times 4\)</span>
转移矩阵即可，比较简单。</p>
<p>查询就维护一个区间内矩阵和即可，和是对应位置直接相加。</p>
<p>注意常数，注意状态矩阵都是 <span class="math inline">\(1\times
4\)</span> 的，将部分 <span class="math inline">\(4^3\)</span>
的矩阵乘法改为 <span class="math inline">\(4^2\)</span>
就能过了，不然会被疯狂卡常。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n\times
w^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2.5e5</span>+<span class="number">5</span>)</span>,<span class="title">mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,A[N],B[N],C[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span>&#123;</span><br><span class="line">    <span class="type">int</span> m[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">zero</span><span class="params">()</span></span>&#123;<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)m[i][j]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)m[i][j]=(i==j);&#125;</span><br><span class="line">    <span class="keyword">inline</span> Mat <span class="keyword">operator</span>+(<span class="type">const</span> Mat &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        Mat c;c.<span class="built_in">zero</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            c.m[i][j]=(m[i][j]+b.m[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Mat <span class="keyword">operator</span>*(<span class="type">const</span> Mat &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        Mat c;c.<span class="built_in">zero</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            c.m[i][j]=(c.m[i][j]+<span class="number">1ll</span>*m[i][k]*b.m[k][j]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Mat <span class="keyword">operator</span>^(<span class="type">const</span> Mat &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        Mat c;c.<span class="built_in">zero</span>();</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            c.m[<span class="number">0</span>][j]=(c.m[<span class="number">0</span>][j]+<span class="number">1ll</span>*m[<span class="number">0</span>][k]*b.m[k][j]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j]!=b.m[i][j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;O;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    Mat sum,lz;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].sum=t[<span class="built_in">ls</span>(rt)].sum+t[<span class="built_in">rs</span>(rt)].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    t[rt].sum.<span class="built_in">zero</span>();</span><br><span class="line">    t[rt].lz.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt].sum.m[<span class="number">0</span>][<span class="number">0</span>]=A[l];</span><br><span class="line">        t[rt].sum.m[<span class="number">0</span>][<span class="number">1</span>]=B[l];</span><br><span class="line">        t[rt].sum.m[<span class="number">0</span>][<span class="number">2</span>]=C[l];</span><br><span class="line">        t[rt].sum.m[<span class="number">0</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">const</span> Mat&amp; k)</span></span>&#123;</span><br><span class="line">    t[rt].sum=t[rt].sum^k;</span><br><span class="line">    t[rt].lz=t[rt].lz*k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz==O)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">    t[rt].lz.<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">const</span> Mat &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        <span class="built_in">update</span>(rt,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,k);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,k);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;Mat res;res.<span class="built_in">zero</span>();</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=res+<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=res+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(A[i],B[i],C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    O.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="type">int</span> op,l,r,v;</span><br><span class="line">    Mat k;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op,l,r);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">4</span>&lt;=op&amp;&amp;op&lt;=<span class="number">6</span>)<span class="built_in">read</span>(v);</span><br><span class="line">        k.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)k.m[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)k.m[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>)k.m[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>)k.m[<span class="number">3</span>][<span class="number">0</span>]=v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">5</span>)k.m[<span class="number">1</span>][<span class="number">1</span>]=v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">6</span>)k.m[<span class="number">3</span>][<span class="number">2</span>]=v,k.m[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(op&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">write</span>(k.m[<span class="number">0</span>][<span class="number">0</span>],<span class="string">&#x27; &#x27;</span>,k.m[<span class="number">0</span>][<span class="number">1</span>],<span class="string">&#x27; &#x27;</span>,k.m[<span class="number">0</span>][<span class="number">2</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P7561</title>
    <url>/2023/12/18/P7561/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7561">P7561 [JOISC 2021
Day2] 道路の建設案 (Road Construction)</a></p>
<span id="more"></span>
<p>曼哈顿距离的式子过于丑陋，转为切比雪夫距离：<a
href="https://h01yshhmy.github.io/2023/12/02/P3964/">P3964 |
h01yshhmy</a>，以下全部 <span class="math inline">\(x_i,y_i\)</span>
都是转化后的切比雪夫距离。</p>
<p>问题变为：求 <span
class="math inline">\(\max(|x_i-x_j|,|y_i-y_j|)\)</span> 的前 <span
class="math inline">\(k\)</span> 小。</p>
<p>二分，二分第 <span class="math inline">\(k\)</span> 小的值 <span
class="math inline">\(mid\)</span>，再 <code>check</code> 一下有没有至少
<span class="math inline">\(k\)</span> 个值 <span
class="math inline">\(\le mid\)</span>。</p>
<p>怎么找是否有 <span class="math inline">\(k\)</span> 个 <span
class="math inline">\(\le mid\)</span>
的距离呢？用队列+<code>multiset</code>分别维护 <span
class="math inline">\(x,y\)</span> 坐标即可。</p>
<p>先将所有点按照 <span class="math inline">\(x\)</span>
坐标排序。<code>check</code>时，枚举到第 <span
class="math inline">\(i\)</span> 个点，先不管 <span
class="math inline">\(y\)</span> 坐标，至少要满足 <span
class="math inline">\(x_i-x\le mid\)</span>，将不合法的 <code>pop</code>
掉，并在 <code>multiset</code> 中删除不合法点。对于 <span
class="math inline">\(y\)</span> 坐标，<code>multiset</code> 以 <span
class="math inline">\(y\)</span> 为关键字维护，直接在
<code>multiset</code> 中暴力找合法点即可，为保证复杂度，如果已经统计到
<span class="math inline">\(k\)</span> 个，就立刻
<code>return true</code>，最后加入当前 <span
class="math inline">\((x_i,y_i)\)</span>。</p>
<p>为了好写，在<code>check</code>时记录了答案，这样最后
<code>check</code> 一下 <span class="math inline">\(l-1\)</span>
就可以输出了。</p>
<p>时间复杂度 <span class="math inline">\(O((n+k)\log n\log
V)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2.5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snode</span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Snode&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&lt;b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">multiset&lt;Snode&gt; s;</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span></span>&#123;</span><br><span class="line">    q=<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    s=<span class="built_in">multiset</span>&lt;Snode&gt;();</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;p[i].x-p[q.<span class="built_in">front</span>()].x&gt;mid)&#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(&#123;<span class="number">0</span>,p[q.<span class="built_in">front</span>()].y&#125;));</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it=s.<span class="built_in">lower_bound</span>(&#123;<span class="number">0</span>,p[i].y-mid&#125;);</span><br><span class="line">        <span class="keyword">while</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;(*it).y&lt;=p[i].y+mid)&#123;</span><br><span class="line">            ans[++cnt]=<span class="built_in">max</span>(<span class="built_in">abs</span>((*it).x-p[i].x),<span class="built_in">abs</span>((*it).y-p[i].y));</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;p[i].x,p[i].y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        p[i].x=x-y;</span><br><span class="line">        p[i].y=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">4e9</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(l<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,k-cnt)&#123;</span><br><span class="line">        <span class="built_in">write</span>(l,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>二分</tag>
        <tag>距离相关</tag>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>P7563</title>
    <url>/2023/12/15/P7563/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7563">P7563 [JOISC 2021
Day4] 最悪の記者 4 (Worst Reporter 4)</a></p>
<span id="more"></span>
<p>设计状态要直击要点，做什么操作就放什么状态。</p>
<p>连 <span class="math inline">\(i\to a_i\)</span>
的边，可以发现，最终会连成内向基环森林。</p>
<p>发现环上点权值一定相等，但先不关注环，想前两个sub。</p>
<p>考虑DP。</p>
<p>设 <span class="math inline">\(f(u,i)\)</span>：将 <span
class="math inline">\(h_u\)</span> 改为 <span
class="math inline">\(i\)</span> 后，点 <span
class="math inline">\(u\)</span>
子树内想要满足不等关系所需的最小花费，设 <span
class="math inline">\(m\)</span> 为离散化后 <span
class="math inline">\(h\)</span> 的上界，有转移：</p>
<p><span class="math display">\[
f(u,i)=c_i\times[i\ne h_u]+\sum_{v\in son(u)}\min_{i\le j\le m}f(v,j)
\]</span></p>
<p>如何优化？</p>
<p>发现第一维是子树/儿子相关，第二维是区间相关，可以将第二维用线段树维护，第一维在DFS过程中线段树合并。</p>
<p>换一换式子，将答案设为 <span class="math inline">\(\min f(1,i)+\sum
c\)</span>。</p>
<p><span class="math display">\[
f(u,i)=\sum_{v\in son(u)}\min_{i\le j\le m}f(v,j)-c_u\times[i=h_u]
\]</span></p>
<p>合并树 <span class="math inline">\(u,v\)</span>
时，记录两棵树内<strong>后缀</strong>最小值（式子内的 <span
class="math inline">\(\min\)</span> 是取后缀），用于更新新的 <span
class="math inline">\(f(u&#39;,i)\)</span>，所以合并时需要先合并右儿子再合并左儿子，来保证访问每个叶子的顺序是从右往左的，满足我们<strong>后缀</strong>最小值的要求。</p>
<p>为什么要这么取 <span class="math inline">\(\min\)</span>
呢，因为合并本来就要遍历所有点，这样写是很方便的，不然还要写区间 <span
class="math inline">\(\min\)</span>，这里要注意，写带区间修改的线段树合并时，要注意<code>pushdown</code>的节点是否有儿子，如果两个儿子都为空，就让懒标记停留在这个点，不要继续向下传递，不然时空都会炸。</p>
<p>将每个儿子 <span class="math inline">\(v\)</span> 合并到 <span
class="math inline">\(u\)</span> 之后，在对应的 <span
class="math inline">\(i=h_u\)</span> 位置减掉 <span
class="math inline">\(c_u\)</span>。</p>
<p>现在可以做无环版本了，考虑基环树怎么办。</p>
<p>发现环上点权值一定相等（x2），可以缩点，进一步的，环上的值，要么是
<span
class="math inline">\(1\)</span>（最小值），要么就是环上某个点的值。</p>
<p>用拓扑排序找到每个环，遍历全部的环，将环看成点，把连到这个点上的全部子树的线段树都合并起来，枚举环的最终取值，在线段树中查询区间
<span class="math inline">\([h_u,m],u\in\)</span> 环
的最小值，同时更新答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,NumE,rb,tot,a[N],Fir[N],d[N],in[N],dfn[N];</span><br><span class="line">ll Ret,h[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> v,nxt;&#125;E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    E[++NumE]=&#123;v,Fir[u]&#125;;</span><br><span class="line">    Fir[u]=NumE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Seg &#123;</span><br><span class="line">    <span class="type">int</span> cnt,rt[N],nt[N],ls[N*<span class="number">54</span>],rs[N*<span class="number">54</span>];</span><br><span class="line">    ll d1,d2,v[N*<span class="number">54</span>],t[N*<span class="number">54</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Chg</span><span class="params">(<span class="type">int</span> x,ll u)</span> </span>&#123;<span class="keyword">if</span> (x) v[x]+=u,t[x]+=u;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;v[x]=<span class="built_in">min</span>(v[ls[x]],v[rs[x]]);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dw</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t[x]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Chg</span>(ls[x],t[x]),<span class="built_in">Chg</span>(rs[x],t[x]),t[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) x=++cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">            v[x]=k;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Dw</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p&lt;=mid) ls[x]=<span class="built_in">Upd</span>(ls[x],l,mid,p,k);</span><br><span class="line">        <span class="keyword">else</span> rs[x]=<span class="built_in">Upd</span>(rs[x],mid+<span class="number">1</span>,r,p,k);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Up</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">Qry</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> v[x];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Dw</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll Res=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (L&lt;=mid) Res=<span class="built_in">min</span>(Res,<span class="built_in">Qry</span>(ls[x],l,mid,L,R));</span><br><span class="line">        <span class="keyword">if</span> (R&gt;mid) Res=<span class="built_in">min</span>(Res,<span class="built_in">Qry</span>(rs[x],mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mrg_Dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            d2=<span class="built_in">min</span>(d2,v[q]),<span class="built_in">Chg</span>(q,d1);</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q) &#123;</span><br><span class="line">            d1=<span class="built_in">min</span>(d1,v[p]),<span class="built_in">Chg</span>(p,d2);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">            d1=<span class="built_in">min</span>(d1,v[p]),d2=<span class="built_in">min</span>(d2,v[q]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (v[p]+d2&lt;=v[q]+d1) &#123;</span><br><span class="line">                v[p]+=d2;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v[q]+=d1;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Dw</span>(p),<span class="built_in">Dw</span>(q);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        rs[p]=<span class="built_in">Mrg_Dfs</span>(rs[p],rs[q],mid+<span class="number">1</span>,r);</span><br><span class="line">        ls[p]=<span class="built_in">Mrg_Dfs</span>(ls[p],ls[q],l,mid);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Up</span>(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mrg</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        d1=d2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mrg_Dfs</span>(x,y,<span class="number">1</span>,rb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Seg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cir</span> &#123;</span><br><span class="line">    ll h,c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Cir&amp; rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> h&lt;rhs.h;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Cir&gt; cr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=Fir[x];i;i=E[i].nxt) &#123;</span><br><span class="line">        <span class="built_in">Dfs</span>(E[i].v);</span><br><span class="line">        rt[x]=<span class="built_in">Mrg</span>(rt[x],rt[E[i].v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt[x]=<span class="built_in">Upd</span>(rt[x],<span class="number">1</span>,rb,h[x],<span class="built_in">Qry</span>(rt[x],<span class="number">1</span>,rb,h[x],rb)-c[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushT</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x]=tot;</span><br><span class="line">    cr[tot].<span class="built_in">push_back</span>(&#123;h[x],c[x]&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!dfn[a[x]]) <span class="built_in">PushT</span>(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopS</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q=<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!--in[a[u]]) q.<span class="built_in">push</span>(a[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!dfn[i] &amp;&amp; in[i])</span><br><span class="line">        tot++,<span class="built_in">PushT</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!in[i] &amp;&amp; in[a[i]])</span><br><span class="line">        <span class="built_in">Dfs</span>(i),nt[dfn[a[i]]]=<span class="built_in">Mrg</span>(nt[dfn[a[i]]],rt[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,tot) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(cr[i].<span class="built_in">begin</span>(),cr[i].<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        ll Cnt=v[nt[i]],sh=cr[i][<span class="number">0</span>].h,sc=cr[i][<span class="number">0</span>].c;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,cr[i].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (sh==cr[i][j].h) sc+=cr[i][j].c;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Cnt=<span class="built_in">min</span>(Cnt,<span class="built_in">Qry</span>(nt[i],<span class="number">1</span>,rb,sh,rb)-sc);</span><br><span class="line">                sh=cr[i][j].h,sc=cr[i][j].c;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        Cnt=<span class="built_in">min</span>(Cnt,<span class="built_in">Qry</span>(nt[i],<span class="number">1</span>,rb,sh,rb)-sc);</span><br><span class="line">        Ret+=Cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">Read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        a[i]=<span class="built_in">Read</span>(),h[i]=<span class="built_in">Read</span>(),c[i]=<span class="built_in">Read</span>();</span><br><span class="line">        <span class="built_in">AddE</span>(a[i],i),in[a[i]]++,d[i]=h[i],Ret+=c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>);</span><br><span class="line">    rb=<span class="built_in">unique</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>)-d<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) h[i]=<span class="built_in">lower_bound</span>(d+<span class="number">1</span>,d+rb+<span class="number">1</span>,h[i])-d;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TopS</span>(n),<span class="built_in">Calc</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树合并</tag>
        <tag>线段树</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>P7565</title>
    <url>/2023/12/16/P7565/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7565">P7565 [JOISC 2021
Day3] ビーバーの会合 2</a></p>
<span id="more"></span>
<p>很多种做法，本来想都写写，但只想到了点分治，别的写法在题解区。</p>
<p>看到回答 <span class="math inline">\(j\in [1,n]\)</span>
的全部问题，可能会想一些 <span class="math inline">\(F(j,*)\to
F(j+1,*&#39;)\)</span> 的算法，但是不太好写。</p>
<p>所以将思路转到可期待点的性质上。</p>
<p>显然，可期待点是 <span class="math inline">\(j\)</span>
个点有权值的带权重心。根据重心的性质，所有可期待点一定连成<strong>一条链</strong>。</p>
<p>现在假设在这条链上，<span class="math inline">\(u\)</span>
是可期待点，且与 <span class="math inline">\(u\)</span> 相邻的 <span
class="math inline">\(v\)</span> 也是可期待点。将边 <span
class="math inline">\((u,v)\)</span> 断开，<span
class="math inline">\(u\)</span> 一侧的关键点个数一定要和 <span
class="math inline">\(v\)</span> 一侧关键点个数相等——这要求 <span
class="math inline">\(j\)</span> 是偶数，所以奇数 <span
class="math inline">\(j\)</span> 答案一定为 <span
class="math inline">\(1\)</span>。</p>
<p>进一步的想，这条链上不可能放关键点，那么关键点只能放在链两端的子树内。<span
class="math inline">\(j\)</span> 个点的分布是不定的，所以不需要具体考虑
<span class="math inline">\(j\)</span>
个点怎么放，只需要两端子树内有足够空间放 <span
class="math inline">\(\frac{j}{2}\)</span> 个即可。</p>
<p>问题转化为找树上一个最长的链，使得链两端的子树大小均 <span
class="math inline">\(\ge \frac{j}{2}\)</span>，<span
class="math inline">\(j\)</span> 为偶数。</p>
<p>点分治即可，处理出 <span class="math inline">\(mx[s]\)</span>
表示子树大小为 <span class="math inline">\(s\)</span>
的子树根到当前分治中心的最大距离，求 <span
class="math inline">\(mx\)</span> 的后缀最大值 <span
class="math inline">\(suf[s]\)</span>，得到 <span
class="math inline">\(\ge s\)</span> 的答案，同时对于每个 <span
class="math inline">\(s\)</span>，处理出，分治中心连接的，在前面已经处理过的儿子的最大
<span
class="math inline">\(suf[s]\)</span>，分治中心作为链的顶端，答案要从某两个儿子中得出。</p>
<p>这些操作直接做就好，复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> siz[N],vis[N];</span><br><span class="line"><span class="type">int</span> mx[N],suf[N],ans[N],othmx[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getmx</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getmx</span>(v,u,d+<span class="number">1</span>);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    mx[siz[u]]=<span class="built_in">max</span>(mx[siz[u]],d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt,tot,mn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getrot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;<span class="type">int</span> mxp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getrot</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        mxp=<span class="built_in">max</span>(mxp,siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    mxp=<span class="built_in">max</span>(mxp,tot-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mxp&lt;mn)&#123;</span><br><span class="line">        mn=mxp,rt=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> all)</span></span>&#123;</span><br><span class="line">    tot=mn=all;<span class="built_in">getrot</span>(u,<span class="number">0</span>);u=rt;</span><br><span class="line">    vis[u]=<span class="number">1</span>;<span class="type">int</span> mxs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        mxs=<span class="built_in">max</span>(mxs,siz[v]);</span><br><span class="line">        <span class="built_in">getmx</span>(v,u,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pe</span>(i,siz[v])suf[i]=<span class="built_in">max</span>(suf[i+<span class="number">1</span>],mx[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,siz[v])ans[i*<span class="number">2</span>]=<span class="built_in">max</span>(ans[i*<span class="number">2</span>],othmx[i]+suf[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,siz[v])othmx[i]=<span class="built_in">max</span>(othmx[i],suf[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,siz[v])mx[i]=suf[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,mxs)othmx[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">solve</span>(v,siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i]+<span class="number">1</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树的重心</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P7834</title>
    <url>/2023/12/02/P7834/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7834">P7834 [ONTAK2010]
Peaks 加强版</a></p>
<span id="more"></span>
<p>二合一题，重点在重构树上。</p>
<p>需要先了解 <strong>Kruskal重构树</strong> 的概念。</p>
<p>建树方式：跑Kruskal，将两个并查集合并的时候，新建一个点与两个并查集的<code>fa</code>连边，新点的点权为当前边的边权，并将这个新点作为合并后并查集的<code>fa</code>。</p>
<p>性质：</p>
<ul>
<li>重构树的叶子节点是原图中所有点，其余的每个点都是原图中的部分边。</li>
<li>如果是最小生成树，那么重构树满足 <span class="math inline">\(\forall
v\in subtree(u),w[v]\le w[u]\)</span>，最大生成树为 <span
class="math inline">\(\forall v\in subtree(u),w[v]\ge
w[u]\)</span>。</li>
<li>如果是最小生成树，重构树上两个叶子节点 <span
class="math inline">\(u,v\)</span> 的 <span
class="math inline">\(lca\)</span> 的权值代表原图中 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>
所有路径上最大边权的最小值，最大生成树就是最小边权最大值。</li>
<li>如果原图是连通图且有 <span class="math inline">\(V\)</span>
个点，重构树会有 <span class="math inline">\(2V-1\)</span> 个点。</li>
</ul>
<p>此题要用到性质二，三。</p>
<p>在最小生成树的重构树上，由性质二得，如果 <span
class="math inline">\(w[u]\le x\)</span>，那么以 <span
class="math inline">\(u\)</span> 为根的子树内节点权值也都 <span
class="math inline">\(\le x\)</span>，都可以走。</p>
<p>找 <span class="math inline">\(u\)</span> 到根的链上深度最浅的 <span
class="math inline">\(i\)</span> 满足 <span
class="math inline">\(w[i]\le x\)</span>
，用树上倍增优化跳父亲过程即可。</p>
<p>现在问题变为找一个子树的所有叶子节点内的第 <span
class="math inline">\(k\)</span> 大权值，主席树直接做，板子。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, ls, rs;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="type">int</span> ntot, T[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = ++ntot;</span><br><span class="line">    tr[i].l = l;</span><br><span class="line">    tr[i].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[i].ls = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tr[i].rs = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = ++ntot;</span><br><span class="line">    tr[i] = tr[pre];</span><br><span class="line">    tr[i].sum++;</span><br><span class="line">    <span class="keyword">if</span> (tr[i].l == tr[i].r)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="type">int</span> mid = tr[i].l + tr[i].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        tr[i].ls = <span class="built_in">upd</span>(tr[pre].ls, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tr[i].rs = <span class="built_in">upd</span>(tr[pre].rs, x);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[L].l == tr[L].r)</span><br><span class="line">        <span class="keyword">return</span> tr[L].l;</span><br><span class="line">    <span class="type">int</span> dif = tr[tr[R].ls].sum - tr[tr[L].ls].sum;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= dif)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tr[L].ls, tr[R].ls, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tr[L].rs, tr[R].rs, k - dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, w;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">read</span>(x, y, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[N];</span><br><span class="line"><span class="type">int</span> to[N], head[N], nxt[N], edgec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++edgec] = v;</span><br><span class="line">    nxt[edgec] = head[u];</span><br><span class="line">    head[u] = edgec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N], h[N], lsh[N], val[N], num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]); &#125;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], lb[N], rb[N], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = fat;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    lb[x] = tot;</span><br><span class="line">    <span class="keyword">if</span> (head[x] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lb[x] = tot;</span><br><span class="line">        rb[x] = ++tot;</span><br><span class="line">        T[tot] = <span class="built_in">upd</span>(T[tot - <span class="number">1</span>], <span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + num, h[x]) - lsh);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = nxt[i])</span><br><span class="line">        <span class="built_in">dfs</span>(to[i], x);</span><br><span class="line">    rb[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">read</span>(n, m, q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]), lsh[i] = h[i];</span><br><span class="line">    <span class="built_in">sort</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + n);</span><br><span class="line">    num = <span class="built_in">unique</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + n) - lsh - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        E[i].<span class="built_in">input</span>();</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(E[i].x), fy = <span class="built_in">find</span>(E[i].y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = f[fy] = ++cnt;</span><br><span class="line">        <span class="built_in">add</span>(cnt, fx);</span><br><span class="line">        <span class="built_in">add</span>(cnt, fy);</span><br><span class="line">        val[cnt] = E[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    T[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, num);</span><br><span class="line">    <span class="built_in">dfs</span>(cnt, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= q; _++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, x, k;</span><br><span class="line">        <span class="built_in">read</span>(v, x, k);</span><br><span class="line">        v = (v ^ lastans) % n + <span class="number">1</span>;</span><br><span class="line">        k = (k ^ lastans) % n + <span class="number">1</span>;</span><br><span class="line">        x = x ^ lastans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (fa[v][i] &amp;&amp; val[fa[v][i]] &lt;= x)</span><br><span class="line">                v = fa[v][i];</span><br><span class="line">        <span class="type">int</span> l = lb[v], r = rb[v];</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; k)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(lastans = lsh[<span class="built_in">query</span>(T[l], T[r], r - l - k + <span class="number">1</span>)], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>主席树</tag>
        <tag>Kruskal重构树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P7990</title>
    <url>/2023/12/02/P7990/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7990">P7990 [USACO21DEC]
Closest Cow Wins S</a></p>
<span id="more"></span>
<p>显然是一个贪心题。</p>
<p>考虑怎么贪。</p>
<p>发现Nhoj的牛将这些草地划分成了若干个草地段。</p>
<p>观察性质，发现在一个草地段内，John最多只需要放两个牛。</p>
<p>因为我们只需要将两端放上牛，这一整段草地，最近的牛就都是John的了。</p>
<p>也就是说，放两个牛就可以全部占领这一段。</p>
<p>我们现在只需要求出每一个段放一个牛的贡献即可。</p>
<p>可以发现，一个牛可以占领草地的一个区间，我们只需要用双指针扫一遍当前草地段的每一个合法区间，取贡献最大值即可。</p>
<p>具体的说，设当前段，左边Nhoj的牛在 <span
class="math inline">\(l\)</span>，右边Nhoj的牛在 <span
class="math inline">\(r\)</span>，John的牛在 <span
class="math inline">\(p\)</span>，会发现能贡献答案的区间的两端分别是是线段
<span class="math inline">\(lp\)</span> 和线段 <span
class="math inline">\(pr\)</span> 的中点，也就是 <span
class="math inline">\((\frac{l+p}{2},\frac{p+r}{2})\)</span>，因为距离相等算Nhoj的，所以是开区间。</p>
<p>将每一段放一个牛的贡献塞进优先队列，如果当前用了一个牛的方案，再将对应段内两个牛与一个牛的贡献之差塞进去就好了。</p>
<p>其实上面这种贪心的正确性需要条件：设一个牛贡献为 <span
class="math inline">\(A\)</span>，两个牛的贡献为 <span
class="math inline">\(B\)</span>，有 <span class="math inline">\(B-A\le
A\)</span>。如果不满足，有可能出现选一个会不优，所以本应被放进队列的
选两个的情况，没有被放进队列。</p>
<p>为什么有这个不等式？</p>
<p>我们设 <span class="math inline">\(sum(l,r)\)</span> 是区间 <span
class="math inline">\((l,r)\)</span> 的草地贡献和。</p>
<p>根据上面那个贡献区间可知，<span class="math inline">\(A\ge
sum(l,\frac{l+r}{2}),A\ge sum(\frac{l+r}{2},r)\)</span>，那么有 <span
class="math inline">\(2A\ge
sum(l,\frac{l+r}{2})+sum(\frac{l+r}{2},r)=sum(l,r)=B\)</span></p>
<p>移项后也就是 <span class="math inline">\(B-A\le A\)</span> 了。</p>
<p>注：代码中deque对美味值没有单调性，只是这样写双指针比较顺手。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Deque</span>&#123;</span><br><span class="line">    T q[N];</span><br><span class="line">    <span class="type">int</span> frt,bak;</span><br><span class="line">    <span class="built_in">Deque</span>()&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;q[<span class="number">1</span>]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[frt];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[bak];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bak-frt+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;frt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;bak--;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;q[++bak]=x;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (bak-frt+<span class="number">1</span>)&gt;<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> K,m,n,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Grass</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,t;</span><br><span class="line">&#125;ga[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,num;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;x.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;u;</span><br><span class="line">Deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line">ll f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(K,m,n);</span><br><span class="line">    <span class="built_in">re</span>(i,K)&#123;</span><br><span class="line">        <span class="built_in">read</span>(ga[i].p,ga[i].t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ga+<span class="number">1</span>,ga+K+<span class="number">1</span>,[](Grass x,Grass y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.p&lt;y.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>]=-inf,a[m+<span class="number">1</span>]=inf;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len=(a[i]-a[i<span class="number">-1</span>]+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">// 这里+1为了上取整</span></span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=K&amp;&amp;ga[now].p&lt;a[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;ga[q.<span class="built_in">front</span>()].p+len&lt;=ga[now].p)&#123;</span><br><span class="line">                sum-=ga[q.<span class="built_in">front</span>()].t;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(now);</span><br><span class="line">            sum+=ga[now].t; </span><br><span class="line">            f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],sum);</span><br><span class="line">            f[i][<span class="number">1</span>]+=ga[now++].t;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>((node)&#123;i,<span class="number">1</span>,f[i][<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    node u;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;n&amp;&amp;(!pq.<span class="built_in">empty</span>()))&#123;</span><br><span class="line">        u=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=u.val;</span><br><span class="line">        <span class="keyword">if</span>(u.num==<span class="number">1</span>)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>((node)&#123;u.id,<span class="number">2</span>,f[u.id][<span class="number">1</span>]-f[u.id][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P8021</title>
    <url>/2023/12/02/P8021/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8021">P8021 [ONTAK2015]
Bajtman i Okrągły Robin</a></p>
<span id="more"></span>
<p>难度在读题和转化模型。</p>
<p>题意：<span class="math inline">\(n\)</span>
个区间，每个区间有权值，对于每个时间段来说，可以在覆盖这个时间段的所有区间中选择一个区间，但是每个区间只能被选一次，求通过选区间能获得的最大权值。</p>
<p>说实话我觉得读题挺有难度的，没想出来翻译全责。</p>
<p>显然可以将区间和每个时间段当做点，分别放在二分图两侧，区间向覆盖到的时间段连带权边，跑二分图最大权匹配。</p>
<p>但边数为 <span class="math inline">\(O(n^2)\)</span>
量级，无法通过。</p>
<p>考虑优化，发现点向一段区间连边的操作可以用线段树优化连边，也就是
中转点 的思想，线段树中父亲与儿子连 <span
class="math inline">\(0\)</span>
权边，将一段区间分散到线段树上连带权边即可。</p>
<p>边数变成 <span class="math inline">\(O(n\log
n)\)</span>，代码写了最大费用最大流跑匹配，<code>EK</code>+<code>SPFA</code>的复杂度比较抽象，在这种二叉树+二分图上的复杂度我也不会算，所以复杂度就是
<span class="math inline">\(O(AC)\)</span> 了，最大点 <span
class="math inline">\(4s\)</span>，时限 <span
class="math inline">\(10s\)</span>，问题不大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,sour,conv;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].c=c;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,w,c);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,-w,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l[N],r[N],c[N];</span><br><span class="line"><span class="type">int</span> lim;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">af</span>(sour,rt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        lim=<span class="built_in">max</span>(lim,rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">af</span>(<span class="built_in">ls</span>(rt),rt,<span class="number">0</span>,mid-l+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">af</span>(<span class="built_in">rs</span>(rt),rt,<span class="number">0</span>,r-mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> tar,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        <span class="built_in">af</span>(rt,tar,w,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">connect</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,tar,w);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">connect</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,tar,w);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> dis[N],vis[N],flow[N],pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,conv)dis[i]=-inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(sour);</span><br><span class="line">    vis[sour]=<span class="number">1</span>,dis[sour]=<span class="number">0</span>,flow[sour]=inf;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u],e[i].c);</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[conv]!=-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxflow,maxcost;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,mn,p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        u=conv;</span><br><span class="line">        maxflow+=flow[conv];</span><br><span class="line">        maxcost+=flow[conv]*dis[conv];</span><br><span class="line">        <span class="keyword">while</span>(u!=sour)&#123;</span><br><span class="line">            e[pre[u]].c-=flow[conv];</span><br><span class="line">            e[pre[u]^<span class="number">1</span>].c+=flow[conv];</span><br><span class="line">            u=e[pre[u]^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    sour=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i],r[i],c[i]);</span><br><span class="line">        r[i]--;</span><br><span class="line">        m=<span class="built_in">max</span>(m,r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    conv=lim+n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">connect</span>(<span class="number">1</span>,<span class="number">1</span>,m,l[i],r[i],lim+i,c[i]);</span><br><span class="line">        <span class="built_in">af</span>(lim+i,conv,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MCMF</span>();</span><br><span class="line">    <span class="built_in">write</span>(maxcost,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>二分图</tag>
        <tag>线段树</tag>
        <tag>优化建图</tag>
        <tag>费用流</tag>
        <tag>图的匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>P8026</title>
    <url>/2023/12/02/P8026/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8026">P8026 [ONTAK2015]
Bajtocja</a></p>
<span id="more"></span>
<p>答案只和连通性相关，考虑并查集。</p>
<p>判断两个点是否在每层图上都在一个连通块内并不好做。</p>
<p>将点在每个图内所属连通块的 <span class="math inline">\(fa\)</span>
串起来，看成一个长为 <span class="math inline">\(d\)</span> 的序列.</p>
<p>发现我们只是在判断两个点对应的序列是否相同。</p>
<p>有一种比较厉害的写法：为每一层随机一个权值 <span
class="math inline">\(wei[k]\)</span>，对每个点维护 <span
class="math inline">\(fa\)</span> 序列的哈希值之和（哈希值被定义为 <span
class="math inline">\(A[k]\times
wei[k]\)</span>），开桶（哈希表）记录每个哈希值对应的点个数，动态计算答案。</p>
<p>这里的哈希并不是传统的 <span class="math inline">\(base\)</span>
进制数形式的哈希，这里的第 <span class="math inline">\(i\)</span>
“位”（已经没有进制的位概念了，只是一些项加起来）是 <span
class="math inline">\(i\times wei[k]\)</span>，而不是 <span
class="math inline">\(base^i\times i\times
wei[k]\)</span>，这被称作和哈希。</p>
<p>由于随机变量的存在，他的正确率还是很高的。</p>
<p>我们用启发式合并去维护目前每一层每个连通块内放了哪些点。</p>
<p>在对 <span class="math inline">\((u,v)\)</span> 连边的时候，将 <span
class="math inline">\(u,v\)</span>
所属集合合并，然后贡献答案，将他们在这一层的对应哈希位置改成新的值即可。</p>
<p>关于贡献答案：加入哈希值要先算再加，删除要先减再算，和一些莫队是一样的。<span
class="math inline">\(\times
2+1\)</span>的原因显然（可以和之前的每个成员组成两个有序二元组，然后自己也可以和自己组成一个）。</p>
<p>因为启发式合并是把小集合合并到大集合，每次集合大小至少 <span
class="math inline">\(\times 2\)</span>，初始有 <span
class="math inline">\(dn\)</span> 个集合，每个集合大小至多为 <span
class="math inline">\(n\)</span>，所以时间复杂度为 <span
class="math inline">\(O(dn\log n)\)</span>，可以通过。</p>
<p>注：随机权值最好范围大一些，错误率会降低很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">D</span><span class="params">(<span class="number">205</span>)</span>,<span class="title">N</span><span class="params">(<span class="number">5e3</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> d,n,m,fa[D][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s[D][N];</span><br><span class="line">ull has[N],wei[D];</span><br><span class="line">unordered_map&lt;ull,<span class="type">int</span>&gt; cnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ull h)</span></span>&#123;</span><br><span class="line">    ans+=cnt[h]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    cnt[h]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(ull h)</span></span>&#123;</span><br><span class="line">    cnt[h]--;</span><br><span class="line">    ans-=cnt[h]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(d,n,m);</span><br><span class="line">    <span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="built_in">re</span>(i,d)&#123;</span><br><span class="line">        wei[i]=<span class="built_in">rnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,d)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            fa[i][j]=j;</span><br><span class="line">            s[i][j].<span class="built_in">pb</span>(j);</span><br><span class="line">            has[j]+=j*wei[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">add</span>(has[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,k);</span><br><span class="line">        u=fa[k][u],v=fa[k][v];</span><br><span class="line">        <span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">            <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[k][u].<span class="built_in">size</span>()&lt;s[k][v].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">swap</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:s[k][v])&#123;</span><br><span class="line">            s[k][u].<span class="built_in">pb</span>(x);</span><br><span class="line">            fa[k][x]=u;</span><br><span class="line">            <span class="built_in">del</span>(has[x]);</span><br><span class="line">            has[x]+=(u-v)*wei[k];</span><br><span class="line">            <span class="built_in">add</span>(has[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        s[k][v].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>RANDOM</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>并查集</tag>
        <tag>哈希</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>P8058</title>
    <url>/2023/12/31/P8058/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8058">P8058 [BalkanOI2003]
Farey 序列</a></p>
<span id="more"></span>
<p>两个写法，写法一复杂度优一些。</p>
<p>看起来很离谱的第 <span class="math inline">\(k\)</span>
小问题，求值转判定，二分。</p>
<h2 id="写法一">写法一</h2>
<p>假设目前要判断 <span
class="math inline">\(\frac{x}{y}\)</span>，那么序列中比它小的数的个数为：
<span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^i[i\perp j][\frac{j}{i}&lt;\frac{x}{y}]
\]</span> 对于互质判断，套路的，用莫比乌斯反演消掉。 <span
class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^i[i\perp j][\frac{j}{i}&lt;\frac{x}{y}]\\
=&amp;\sum_{i=1}^n\sum_{j=1}^i[\gcd(i,j)=1][\frac{j}{i}&lt;\frac{x}{y}]\\
=&amp;\sum_{i=1}^n\sum_{j=1}^i\sum_{d|\gcd(i,j)}\mu(d)[\frac{j}{i}&lt;\frac{x}{y}]\\
=&amp;\sum_{d}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^i[\frac{j}{i}&lt;\frac{x}{y}]
\end{aligned}
\]</span> <span
class="math inline">\([\frac{j}{i}&lt;\frac{x}{y}]\)</span> 变为 <span
class="math inline">\([j&lt;\frac{ix}{y}]\)</span>，式子变成： <span
class="math display">\[
\sum_{d}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\left\lfloor\frac{ix}{y}\right\rfloor
\]</span> 对于第一个和式，杜教筛套整除分块，对于每个有贡献的上界 <span
class="math inline">\(\lfloor\frac{n}{d}\rfloor\)</span>
和式，加上系数。</p>
<p>对于第二个和式，类欧板子。</p>
<p>我们记这一整个式子为 <span
class="math inline">\(f(\frac{x}{y})\)</span>。</p>
<p>现在可以写 <code>check</code> 了，但是要怎么二分一个最简真分数 <span
class="math inline">\(\frac{x}{y}\)</span> 呢？</p>
<p>考虑一个叫 Stern-Brocot 树的东西，大概长这样：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oeqik4ed.png"
alt="sample" />
<figcaption aria-hidden="true">sample</figcaption>
</figure>
<p>以下全部内容都只看左半边的真分数部分，也就是 <span
class="math inline">\(\frac{1}{2}\)</span> 的子树。</p>
<p>这张图的每一行是这棵二叉树遍历深度不超过当前行的中序遍历序列。</p>
<p>假设我们已经得到了只遍历前 <span class="math inline">\(i-1\)</span>
层的中序遍历序列，其中 <span
class="math inline">\(\frac{a}{b},\frac{c}{d}\)</span>
是相邻的两项，那么将 <span
class="math inline">\(\frac{a+c}{b+d}\)</span>
插入它们之间，得到的就是只遍历前 <span class="math inline">\(i\)</span>
层的中序遍历序列。</p>
<p>有建树的伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">  tr[++ndnum].p = a + c; tr[ndnum].q = b + d;</span><br><span class="line">  tr[ndnum].ls = <span class="built_in">build</span>(a, b, a + c, b + d);</span><br><span class="line">  tr[ndnum].rs = <span class="built_in">build</span>(a + c, b + d, c, d);</span><br><span class="line">  <span class="keyword">return</span> ndnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然不能真建出树来，这棵树是无限大的。</p>
<p>对于这棵树，有结论：</p>
<ul>
<li>中序遍历序列一定单增</li>
<li>中序遍历序列一定都是最简真分数</li>
</ul>
<p>证明：考虑归纳法。</p>
<p>单增：若 <span class="math inline">\(\frac{a}{b}&lt;
\frac{c}{d}\)</span>，显然 <span
class="math inline">\(\frac{a}{b}&lt;\frac{a+c}{b+d}&lt;\frac{c}{d}\)</span>。</p>
<p>最简真分数：</p>
<p>先证明：若 <span
class="math inline">\(\frac{a}{b},\frac{c}{d}\)</span> 是第 <span
class="math inline">\(i\)</span> 层中序遍历序列中相邻两项，那么 <span
class="math inline">\(\frac{c}{d}-\frac{a}{b}=\frac{1}{bd}\)</span>，最开始的几行是满足要求的。</p>
<p>假设前 <span class="math inline">\(i-1\)</span> 层满足条件，对于
<span class="math inline">\(i-1\)</span> 层的相邻两项，有 <span
class="math inline">\(\frac{c}{d}-\frac{a}{b}=\frac{1}{bd}=\frac{bc-ad}{bd}\)</span>，得到
<span class="math inline">\(bc-ad=1\)</span>。</p>
<p>到第 <span class="math inline">\(i\)</span> 层之后，相邻三个分别为
<span
class="math inline">\(\frac{a}{b},\frac{a+c}{b+d},\frac{c}{d}\)</span>，列出两个式子：
<span class="math display">\[
\begin{aligned}
&amp;\frac{a+c}{b+d}-\frac{a}{b}=\frac{ab+bc-ab-ad}{b(b+d)}=\frac{bc-bd}{b(b+d)}=\frac{1}{b(b+d)}\\
&amp;\frac{c}{d}-\frac{a+c}{b+d}=\frac{bc+dc-ad-cd}{(b+d)d}=\frac{bc-ad}{(b+d)d}=\frac{1}{(b+d)d}
\end{aligned}
\]</span> 式子形式满足要求。也就是说，<span
class="math inline">\(bc-ad=1\)</span> 恒成立。</p>
<p>根据裴蜀定理的逆定理：</p>
<blockquote>
<p>设 <span class="math inline">\(a,b\)</span> 是不全为 <span
class="math inline">\(0\)</span> 的整数，若 <span
class="math inline">\(d&gt;0\)</span> 是 <span
class="math inline">\(a,b\)</span> 的公因数，且存在 <span
class="math inline">\(x,\,y\)</span> 使得 <span
class="math inline">\(ax+by=d\)</span>，则 <span
class="math inline">\(d=\gcd(a,b)\)</span>。</p>
</blockquote>
<p>容易发现，<span class="math inline">\(bc-ad=1\)</span> 有解，当且仅当
<span class="math inline">\(a\perp b,\,c\perp
d\)</span>。互质显然都是最简真分数，得证。</p>
<p>现在有一个naive的想法，在 <span
class="math inline">\(x=1,\,y=2\)</span> 处开始树上二分，如果 <span
class="math inline">\(f(\frac{x}{y})=k\)</span> 就是答案，<span
class="math inline">\(f(\frac{x}{y})&lt;k\)</span>
就走到右儿子，否则就走到左儿子。</p>
<p>但是 <span class="math inline">\(k=1\)</span> 的时候会一直走 <span
class="math inline">\(n\)</span> 次左儿子，考虑如何加速树上移动。</p>
<p>显然每次可以移动多步，重点在于方向的拐点。</p>
<p>设 <span class="math inline">\(F(n)\)</span> 为拐 <span
class="math inline">\(n\)</span>
次能走到的分数中最小的分母，构造显然是不停拐 <span
class="math inline">\(n\)</span> 次，容易发现，拐 <span
class="math inline">\(n-1\)</span> 次和 <span
class="math inline">\(n-2\)</span> 次到达的位置，正好是中序遍历中拐
<span class="math inline">\(n\)</span>
次到达位置的左右两个相邻的位置，那么拐 <span
class="math inline">\(n\)</span> 次的分母就是之前写的 <span
class="math inline">\(b+d\)</span>，所以有 <span
class="math inline">\(F(n)=F(n-1)+F(n-2)\)</span>，拐的次数就是 <span
class="math inline">\(F^{-1}(n)=O(\log n)\)</span>。</p>
<p>我们可以在每次跳儿子的时候，倍增方向上需要跳多远，快速走到下一个拐点。</p>
<p>时间复杂度大概是 <span
class="math inline">\(O(n^{\frac{2}{3}}+\sqrt{n}\log^3
n)\)</span>，不想分析了，跑不满。</p>
<h2 id="写法二">写法二</h2>
<p>一样是二分。</p>
<p>设 <span class="math inline">\(H(x)\)</span> 为 Farey 数列中小于
<span class="math inline">\(x\)</span> 的个数，<span
class="math inline">\(F(i)\)</span> 表示小于 <span
class="math inline">\(x\)</span> 且分母为 <span
class="math inline">\(i\)</span> 的个数。</p>
<p>显然有： <span class="math display">\[
\begin{aligned}
&amp;H(x)=\sum_{i=1}^nF(i)\\
&amp;F(i)=\lfloor ix\rfloor-\sum_{d|i}F(d)
\end{aligned}
\]</span> 做一点预处理。</p>
<p>设 <span class="math inline">\(G(i)\)</span> 为 <span
class="math inline">\(\lfloor ix\rfloor\)</span> 的系数，观察 <span
class="math inline">\(F\)</span>
的递推式，容易发现，存在一个像是容斥系数不断取反一样的关系，可以得到：
<span class="math display">\[
G(i)=1-\sum_{i|t}G(t)
\]</span> 二分答案的部分就直接二分一个实数，比较暴力。</p>
<p>总复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>写法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5000000</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mem;</span><br><span class="line"><span class="type">int</span> n, prm[N + <span class="number">5</span>], np[N + <span class="number">5</span>], pcnt, smu[N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    smu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!np[i]) prm[++pcnt] = i, smu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            np[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                smu[i * prm[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            smu[i * prm[j]] = <span class="number">-1</span> * smu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, N) smu[i] += smu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcsmu</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= N) <span class="keyword">return</span> smu[n];</span><br><span class="line">    <span class="keyword">if</span> (mem.<span class="built_in">find</span>(n) != mem.<span class="built_in">end</span>()) <span class="keyword">return</span> mem[n];</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        rt -= (r - l + <span class="number">1</span>) * <span class="built_in">calcsmu</span>(n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[n] = rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">frac</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, q;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> frac&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span> * p * b.q &lt; <span class="number">1ll</span> * q * b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">G</span><span class="params">(ll a, ll b, ll c, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1ll</span> * n * (b / c);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; c || b &gt; c) <span class="keyword">return</span> <span class="number">1ll</span> * n * (n + <span class="number">1</span>) / <span class="number">2</span> * (a / c) + (<span class="number">1ll</span> * (n + <span class="number">1</span>) * (b / c)) + <span class="built_in">G</span>(a % c, b % c, c, n);</span><br><span class="line">    ll m = (<span class="number">1ll</span> * a * n + b) / c;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1ll</span> * n * m) - <span class="built_in">G</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(frac a)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        res += <span class="number">1ll</span> * (<span class="built_in">calcsmu</span>(r) - <span class="built_in">calcsmu</span>(l - <span class="number">1</span>)) * <span class="built_in">G</span>(a.p, <span class="number">0</span>, a.q, n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    ll k = <span class="number">0</span>, lim = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">read</span>(n, k);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * lim &lt;= n) lim *= <span class="number">2</span>;</span><br><span class="line">    frac l, r, a, b;</span><br><span class="line">    l.p = <span class="number">0</span>, l.q = <span class="number">1</span>, r.p = <span class="number">1</span>, r.q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        a.p = l.p + r.p, a.q = l.q + r.q;</span><br><span class="line">        ll t = <span class="built_in">F</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (t == k) &#123;</span><br><span class="line">            <span class="built_in">write</span>(a.p, <span class="string">&#x27; &#x27;</span>, a.q, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lim; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n - l.q) / r.q &lt; i) <span class="keyword">continue</span>;</span><br><span class="line">                b.p = l.p + <span class="number">1ll</span> * i * r.p;</span><br><span class="line">                b.q = l.q + <span class="number">1ll</span> * i * r.q;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">F</span>(b) &lt; k) l = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lim; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n - r.q) / l.q &lt; i) <span class="keyword">continue</span>;</span><br><span class="line">                b.p = r.p + <span class="number">1ll</span> * i * l.p;</span><br><span class="line">                b.q = r.q + <span class="number">1ll</span> * i * l.q;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">F</span>(b) &gt; k) r = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k,c[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">S</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)	c[i]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=i*<span class="number">2</span>;t&lt;=n;t+=i)</span><br><span class="line">      c[i]-=c[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)	ans+=c[i]*<span class="built_in">int</span>(x*i);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">double</span> x,<span class="type">int</span> &amp;p,<span class="type">int</span> &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="number">0</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="type">int</span> tmp=x*i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">double</span>(p)/<span class="built_in">double</span>(q)-x)&gt;<span class="built_in">abs</span>(<span class="built_in">double</span>(tmp)/<span class="built_in">double</span>(i)-x))</span><br><span class="line">            p=tmp,q=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=-f;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">S</span>(n);</span><br><span class="line">    <span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">C</span>(mid)&lt;k)  l=mid;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p,q;</span><br><span class="line">    <span class="built_in">find</span>(r,p,q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,p,q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>整除分块</tag>
        <tag>反演</tag>
        <tag>数论</tag>
        <tag>倍增</tag>
        <tag>莫比乌斯反演</tag>
        <tag>Stern-Brocot树</tag>
        <tag>筛法</tag>
        <tag>类欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title>P8179</title>
    <url>/2023/12/02/P8179/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8179">P8179 「EZEC-11」
Tyres</a></p>
<span id="more"></span>
<p>其实不太好想，是分两部分做的题。</p>
<p>不会做就看看特殊性质。</p>
<p>发现 <span class="math inline">\(t\)</span> 比较烦人，<span
class="math inline">\(t=0\)</span> 的部分是可以直接贪心的。</p>
<p>具体的，记录每套轮胎跑了多少圈，优先队列的<code>cmp</code>里计算秒数，每次贪心取顶，加圈数改<code>key</code>值即可，复杂度
<span class="math inline">\(O(m\log n)\)</span>。</p>
<p>加上 <span class="math inline">\(t\)</span> 怎么写呢。</p>
<p>首先十分显然的一点，一个轮胎被换下去后不可能再次被换上，可以将每个轮胎的秒数和圈数描述为
<span
class="math inline">\(f(x)=b(x-1)^2+a\)</span>，而这是二次函数，某个二次函数中的一段成为全部二次函数的最小值之后，如果不再是最小值，那当然就再也不可能是最小值。</p>
<p>不妨把 每一套轮胎的换胎时间 加到
当前这套轮胎跑第一圈的时间上，这样就没有换胎操作了。</p>
<p>但是这样不能贪心了，因为给第一圈加上 <span
class="math inline">\(t\)</span> 之后，每套轮胎的秒数不一定关于圈数在
<span class="math inline">\([1,m]\)</span> 上递增。</p>
<p>题目中 <span class="math inline">\(a_i+b_i(j-1)^2\)</span>
的贡献式子是有用的，这个平方比较显眼。</p>
<p>记 <span class="math inline">\(B=\lceil\sqrt{t}\rceil\)</span>。
注：以下的 <span class="math inline">\(B\)</span>
圈都是指每个轮胎各自跑了 <span class="math inline">\(B\)</span>
圈，并不是总共跑了 <span class="math inline">\(m\)</span> 圈中的前 <span
class="math inline">\(B\)</span> 圈。</p>
<p>不难发现，<span class="math inline">\(B\)</span>
圈之后，任意一套轮胎的花费都会大于等于这套轮胎在第一圈花费的时间加上累加的
这套轮胎的换胎时间。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;a_i+b_i\times 0+t\le a_i+b_i\times B^2\\
&amp;a_i+t\le a_i+b_it
\end{aligned}
\]</span></p>
<p>显然成立。</p>
<p>而且在 <span class="math inline">\(B\)</span>
圈之后每个轮胎跑一圈的秒数显然是递增的，也就是在 <span
class="math inline">\(\{1\}\cup[B+1,m]\)</span> 上一定递增。</p>
<p>所以在这种存在单调性的情况下，可以直接用前面的写法贪心，初始需要先假设所有轮胎都跑了
<span class="math inline">\(B\)</span> 圈。</p>
<p>但是 <span class="math inline">\(B\)</span> 圈之前的还需要处理。</p>
<p>预处理第 <span class="math inline">\(i\)</span> 个轮胎连跑 <span
class="math inline">\(j\)</span> 圈需要的秒数
（加上了前面说的换胎时间）。</p>
<p>将每个轮胎当成一组，组内放 <span class="math inline">\(B\)</span>
个，第 <span class="math inline">\(i\)</span> 组内第 <span
class="math inline">\(j\)</span> 个价值为 <span
class="math inline">\(f[i][j]\)</span>，跑 <span
class="math inline">\(01\)</span> 分组背包即可，不要忘了背包容量为 <span
class="math inline">\(n\times B\)</span> ，这是总圈数。</p>
<p>背包部分复杂度 <span
class="math inline">\(O(n^2t)\)</span>，贪心部分复杂度 <span
class="math inline">\(O(m\log n)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(n^2t+m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">505</span>)</span>,<span class="title">sqN</span><span class="params">(<span class="number">30</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> f[N][sqN],g[N*sqN],h[M];</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N],n,m,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;x,<span class="type">const</span> <span class="type">int</span>&amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a[x]+b[x]*c[x]*c[x]&gt;a[y]+b[y]*c[y]*c[y])||</span><br><span class="line">        (a[x]+b[x]*c[x]*c[x]==a[y]+b[y]*c[y]*c[y]&amp;&amp;x&gt;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,t);</span><br><span class="line">    <span class="type">int</span> B=<span class="built_in">sqrt</span>(t)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i],b[i]);</span><br><span class="line">        c[i]=B;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        f[i][<span class="number">1</span>]=a[i]+t;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">2</span>,B)&#123;</span><br><span class="line">            f[i][j]=f[i][j<span class="number">-1</span>]+a[i]+b[i]*(j<span class="number">-1</span>)*(j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        s=<span class="built_in">min</span>(m,s+B);</span><br><span class="line">        <span class="built_in">per</span>(j,s,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="built_in">min</span>(B,j))&#123;</span><br><span class="line">                g[j]=<span class="built_in">min</span>(g[j],g[j-k]+f[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        x=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]+a[x]+b[x]*c[x]*c[x];</span><br><span class="line">        c[x]++;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(s,m))&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,g[i]+h[m-i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans-t,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>背包</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8229</title>
    <url>/2023/12/02/P8229/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8229">[AGM 2022 资格赛]
抛硬币</a></p>
<span id="more"></span>
<p>设 <span class="math inline">\(g_i\)</span> 为抛 <span
class="math inline">\(i\)</span> 次硬币之后期望剩下的个数，<span
class="math inline">\(f_i\)</span> 为 <span
class="math inline">\(i\)</span> 次之后期望吃掉的个数。</p>
<p>容易写出式子： <span class="math display">\[
\begin{aligned}
&amp;g_i=kP\times g_{i-1}+1-P\\
&amp;f_i=f_{i-1}+(1-P)\times g_{i-1}
\end{aligned}
\]</span> 如果抛出正面，可以剩下 <span class="math inline">\(k\times
g_{i-1}\)</span>个，反面就剩 <span class="math inline">\(1\)</span>
个。</p>
<p>如果抛出正面，不会吃任何草莓，反面会吃 <span
class="math inline">\(g_{i-1}\)</span>个。</p>
<p><span class="math inline">\(n\)</span> 很大，考虑矩阵加速递推。</p>
<p>时间复杂度 <span class="math inline">\(O(T\times 27\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll n,K,P;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123;</span><br><span class="line">    ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=(i==j);</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        mat c;c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            c.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">            c.a[i][j]%=Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    mat ans,a,x;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(n,K,P);</span><br><span class="line">        ans.<span class="built_in">init</span>();</span><br><span class="line">        a.<span class="built_in">init</span>();</span><br><span class="line">        a.a[<span class="number">0</span>][<span class="number">0</span>]=P*K%Mod;</span><br><span class="line">        a.a[<span class="number">0</span>][<span class="number">1</span>]=a.a[<span class="number">2</span>][<span class="number">0</span>]=(<span class="number">1</span>-P+Mod)%Mod;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a;</span><br><span class="line">            a=a*a;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x.<span class="built_in">reset</span>();</span><br><span class="line">        x.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        ans=x*ans;</span><br><span class="line">        <span class="built_in">write</span>((ans.a[<span class="number">0</span>][<span class="number">0</span>]+ans.a[<span class="number">0</span>][<span class="number">1</span>])%Mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P8321</title>
    <url>/2023/12/02/P8321/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8321">P8321
『JROI-4』沈阳大街 2</a></p>
<span id="more"></span>
<p>发现期望和这题几乎无关，从序列的性质入手。</p>
<p>看到数据范围，大概是一个 <span class="math inline">\(O(n^2)\)</span>
的DP。</p>
<p>对题目做一个比较精妙的转化：</p>
<p>将 <span class="math inline">\(A,B\)</span> 数组全部放进另一个数组
<span class="math inline">\(C\)</span> 内，对 <span
class="math inline">\(C\)</span> 从大到小排序。规定来自于 <span
class="math inline">\(A\)</span> 的数是红色，来自于 <span
class="math inline">\(B\)</span> 的数是蓝色；</p>
<p>因为是算全部排列的和，<span class="math inline">\(C\)</span>
可以排序。</p>
<p>那么算 <span class="math inline">\(f\)</span>
的过程事实上就是红蓝两种颜色相互匹配（只有不同颜色才能匹配），每一个红蓝对的权值是后面那个数（因为是从大到小排序），所有红蓝对的权值乘积。</p>
<p><span class="math inline">\(\sum f(\pi)\)</span>
也就变成所有完美匹配方式内部红蓝对乘积的和。</p>
<p>DP的时候要处理：当前位置是否作为后面的那个数，向前匹配红蓝对。</p>
<p>“权值是后面的数”是一个非常好的性质，这意味着我们DP的时候只需要知道当前值的大小。</p>
<p>可以设 <span class="math inline">\(f[i][j]\)</span> 为 <span
class="math inline">\(C\)</span> 中前 <span
class="math inline">\(i\)</span> 个数，匹配了 <span
class="math inline">\(j\)</span> 对的所有匹配方式贡献之和</p>
<p>可以写出如下转移式子： <span class="math display">\[
\begin{aligned}
f[i][j]=f[i-1][j]+f[i-1][j-1]\times c[i]\times (cnt-j+1)
\end{aligned}
\]</span> 这里 <span class="math inline">\(cnt\)</span>
设为中在前面和颜色不同的数字个数。</p>
<p>这非常好理解，我们可以不匹配，贡献为 <span
class="math inline">\(f[i-1][j]\)</span>；也可以匹配：在 <span
class="math inline">\(f[i-1][j-1]\)</span> 的状态下，<span
class="math inline">\(i\)</span> 的答案还没有算，一共还有 <span
class="math inline">\(cnt-(j-1)\)</span>
个没被匹配的，任选哪个匹配都可以，每一个匹配的对都要用 <span
class="math inline">\(c[i]\)</span> 做权值。</p>
<p>全部方案贡献之和为 <span class="math inline">\(f[2n][n]\)</span>
，不要忘了求的是期望，最终答案为 <span
class="math inline">\(\dfrac{f[2n][n]}{n!}\)</span></p>
<p>这样就做完了，时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5005</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,col;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N],sum[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%Mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        c[i]=(Node)&#123;a[i],<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        c[i+n]=(Node)&#123;b[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+n*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)&#123;</span><br><span class="line">        sum[<span class="number">0</span>][i]=sum[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        sum[<span class="number">1</span>][i]=sum[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">        sum[c[i].col][i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n*<span class="number">2</span>)f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)&#123;</span><br><span class="line">        cnt=sum[c[i].col^<span class="number">1</span>][i];</span><br><span class="line">        <span class="built_in">re</span>(j,<span class="built_in">min</span>(n,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=j)&#123;</span><br><span class="line">                f[i][j]=<span class="number">1ll</span>*f[i<span class="number">-1</span>][j<span class="number">-1</span>]*c[i].val%Mod*(cnt-j+<span class="number">1</span>)%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j]=(f[i<span class="number">-1</span>][j]+f[i][j])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ifac=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)ifac=<span class="number">1ll</span>*ifac*i%Mod;</span><br><span class="line">    ifac=<span class="built_in">qpow</span>(ifac,Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1ll</span>*f[n*<span class="number">2</span>][n]*ifac%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>P8558</title>
    <url>/2023/12/29/P8558/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8558">P8558
黑暗（Darkness）</a></p>
<span id="more"></span>
<p>注意：是 <span class="math inline">\(k\)</span>
次方的期望值，不是期望值的 <span class="math inline">\(k\)</span>
次方，不要看错了。</p>
<p>发现撞墙只是最后一次操作的事情，所以考虑从 <span
class="math inline">\((A,B,C)\)</span> 走到 <span
class="math inline">\((x,y,z)\)</span>
且<strong>不撞墙</strong>的概率，只要会算这个，最后再撞一步就好了。</p>
<p>一共有 <span class="math inline">\(3^{A-x+B-y+C-z}\)</span>
种方案，而到达 <span class="math inline">\((x,y,z)\)</span> 的方案数为
<span
class="math inline">\(\dbinom{A-x+B-y+C-z}{A-x,B-y,C-z}\)</span>.</p>
<p>所以概率为 <span
class="math inline">\(\dfrac{\binom{A-x+B-y+C-z}{A-x,B-y,C-z}}{3^{A-x+B-y+C-z}}\)</span>。</p>
<p>根据期望的线性性，分别计算撞到每面墙的期望（哪个坐标为 <span
class="math inline">\(0\)</span>）。</p>
<p>设 <span class="math inline">\(F(A,B,C)\)</span>：起点是 <span
class="math inline">\((A,B,C)\)</span>，走到某个位置，<strong>撞到墙</strong>的答案。以墙
<span class="math inline">\(z=0\)</span> 为例： <span
class="math display">\[
\begin{aligned}
F(A,B,C)&amp;=\frac{1}{3}\sum_{x=0}^A\sum_{y=0}^B\dfrac{\dbinom{A-x+B-y+C}{A-x,B-y,C}(x+y)^k}{3^{A-x+B-y+C}}\\
&amp;=\sum_{t=0}^{A+B}\frac{(A+B-t)^k}{3^{t+C+1}}\sum_{x=t-B}^{A}\dbinom{t+C}{t-x,x,C}\\
&amp;=\sum_{t=0}^{A+B}\frac{(A+B-t)^k}{3^{t+C+1}}\dbinom{t+C}{C}\sum_{x=t-B}^{A}\dbinom{t}{x}\\
\end{aligned}
\]</span> 这里乘 <span class="math inline">\(\frac{1}{3}\)</span> 就是从
<span class="math inline">\((x,y,0)\)</span> 走到了 <span
class="math inline">\((x,y,-1)\)</span>，撞墙了。</p>
<p><span class="math inline">\(t\)</span> 是在枚举 <span
class="math inline">\(A-x+B-y\)</span>，拆多重组合数的过程就不再赘述。</p>
<p>考虑如何计算第二个和式，做递推。 <span class="math display">\[
\begin{aligned}
G(t)&amp;=\sum_{x=t-B}^A\binom{t}{x}\\
&amp;=\sum_{x=t-B}^A\binom{t-1}{x}+\binom{t-1}{x-1}\\
G(t-1)&amp;=\sum_{x=t-1-B}^A\binom{t-1}{x}\\
G(t)&amp;=G(t-1)-\binom{t-1}{t-1-B}+\sum_{x=t-B}^A\binom{t-1}{x-1}\\
&amp;=G(t-1)-\binom{t-1}{B}+\sum_{x=t-1-B}^{A-1}\binom{t-1}{x}\\
&amp;=2G(t-1)-\binom{t-1}{B}-\binom{t-1}{A}
\end{aligned}
\]</span> 最终形式为： <span class="math display">\[
\begin{aligned}
&amp;F(A,B,C)=\sum_{t=0}^{A+B}\frac{(A+B-t)^k}{3^{t+C+1}}\binom{t+C}{C}G(t)\\
&amp;G(t)=2G(t-1)-\binom{t-1}{B}-\binom{t-1}{A}
\end{aligned}
\]</span> <span class="math inline">\((A+B-t)^k\)</span>
直接用快速幂算比较卡常。发现这是积性函数，线性预处理可以写欧拉筛，处理出
<span class="math inline">\(h(x)=x^k\)</span>。</p>
<p>答案是 <span
class="math inline">\(F(B,C,A)+F(A,C,B)+F(A,B,C)\)</span>，要算每一维作为
<span class="math inline">\(z\)</span> 轴，接触 <span
class="math inline">\(z=0\)</span> 的答案。</p>
<p>时间复杂度 <span class="math inline">\(O(A+B+C)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e7</span>+<span class="number">5</span>,mod=<span class="number">998244353</span>,i3=<span class="number">332748118</span>;</span><br><span class="line"><span class="type">int</span> A,B,C,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pw[N],np[N],fac[N],ifac[N],G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prm;</span><br><span class="line">    pw[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,lim)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i])&#123;</span><br><span class="line">            pw[i]=<span class="built_in">qpow</span>(i,k);</span><br><span class="line">            prm.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:prm)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*j&gt;lim)<span class="keyword">break</span>;</span><br><span class="line">            np[i*j]=<span class="number">1</span>,pw[i*j]=<span class="number">1ll</span>*pw[i]*pw[j]%mod;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,lim)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[lim]=<span class="built_in">qpow</span>(fac[lim],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">per</span>(i,lim<span class="number">-1</span>,<span class="number">0</span>)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binom</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,i3p=<span class="built_in">qpow</span>(i3,c);</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(t,<span class="number">0</span>,a+b)&#123;</span><br><span class="line">        i3p=<span class="number">1ll</span>*i3p*i3%mod;</span><br><span class="line">        <span class="type">int</span> mul=<span class="number">1ll</span>*i3p*pw[a+b-t]%mod*<span class="built_in">binom</span>(c+t,c)%mod;</span><br><span class="line">        <span class="keyword">if</span>(t)G[t]=((<span class="number">2</span>*G[t<span class="number">-1</span>]-<span class="built_in">binom</span>(t<span class="number">-1</span>,a)-<span class="built_in">binom</span>(t<span class="number">-1</span>,b))%mod+mod)%mod;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*mul*G[t]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(A,B,C,k);</span><br><span class="line">    <span class="built_in">init</span>(N<span class="number">-5</span>);</span><br><span class="line">    <span class="built_in">write</span>((<span class="number">1ll</span>*<span class="built_in">F</span>(B,C,A)+<span class="built_in">F</span>(A,C,B)+<span class="built_in">F</span>(A,B,C))%mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>概率与期望</tag>
        <tag>数论</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>P8576</title>
    <url>/2023/12/04/P8576/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8576">P8576
「DTOI-2」星之界</a></p>
<span id="more"></span>
<p>操作二有组合数，先对式子转化。</p>
<p>无论是组合意义上理解，还是把式子列出来，都可以得到：</p>
<p><span class="math display">\[
\prod_{i=l}^r\binom{\sum_{j=l}^ia_j}{a_i}=\frac{(\sum_{i=l}^ra_i)!}{\prod_{i=1}^na_i!}
\]</span></p>
<p>这是多重集的排列数。</p>
<p>操作一比较难做。需要分块维护。</p>
<p>注意题目中 <span class="math inline">\(\sum
a\le10^7\)</span>，可以预处理阶乘和阶乘的逆元。</p>
<p>所以我们只需要维护 <span class="math inline">\(\sum a\)</span> 和
<span class="math inline">\(\prod (a!)^{-1}\)</span> 即可。</p>
<p>考虑一次修改 <span class="math inline">\(x,y\)</span>，假设有 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(x\)</span> 要改成 <span
class="math inline">\(y\)</span>，那么块内和要 <span
class="math inline">\(+k(y-x)\)</span>，块内阶乘逆元要乘上 <span
class="math inline">\((x!)^k\times
(y!)^{-k}\)</span>，同时用并查集维护各个值的集合，因为 <span
class="math inline">\(k\le
\sqrt{n}\)</span>，所以这个幂可以不写快速幂，直接预处理。</p>
<p>具体的，对于修改操作，散块直接更新块内值，然后统计修改重构。整块我们考虑合并（若块内有
<span class="math inline">\(x\)</span>）：若块内无 <span
class="math inline">\(y\)</span>，则直接将块内第一个元素的值改为 <span
class="math inline">\(y\)</span>，并把“块内第一个值为 <span
class="math inline">\(y\)</span> 的下标”更新成 <span
class="math inline">\(x\)</span>，（因为此时块内值为 <span
class="math inline">\(x\)</span> 的全员变成了 <span
class="math inline">\(y\)</span>）；若块内有 <span
class="math inline">\(y\)</span>，我们需要把代表 <span
class="math inline">\(x\)</span> 的点的父亲设为第一个 <span
class="math inline">\(y\)</span>，此外，还需要开个桶维护块内元素个数。</p>
<p>分块题一定要<strong>注意细节</strong>，注意清空被覆盖的颜色信息，代码应该比较好懂。</p>
<p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">V</span><span class="params">(<span class="number">1e7</span>+<span class="number">5</span>)</span>,<span class="title">sqN</span><span class="params">(<span class="number">320</span>)</span>,<span class="title">mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,B,q,a[N],bel[N],R[N];</span><br><span class="line"><span class="type">int</span> prod[N],sum[N],cnt[sqN][N],hd[sqN][N],fa[N];</span><br><span class="line"><span class="type">int</span> ifac[N],fac[V];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span>&amp; x,<span class="type">int</span> y)</span></span>&#123;x=<span class="number">1ll</span>*x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="built_in">mul</span>(res,a);</span><br><span class="line">        <span class="built_in">mul</span>(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ipow[N][sqN],fpow[N][sqN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,V<span class="number">-5</span>)&#123;</span><br><span class="line">        fac[i]=i;</span><br><span class="line">        <span class="built_in">mul</span>(fac[i],fac[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[N<span class="number">-5</span>]=<span class="built_in">qpow</span>(fac[N<span class="number">-5</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">pe</span>(i,N<span class="number">-6</span>)&#123;</span><br><span class="line">        ifac[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mul</span>(ifac[i],ifac[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-5</span>)&#123;</span><br><span class="line">        ipow[i][<span class="number">0</span>]=fpow[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">re</span>(j,sqN<span class="number">-1</span>)&#123;</span><br><span class="line">            ipow[i][j]=<span class="number">1ll</span>*ipow[i][j<span class="number">-1</span>]*ifac[i]%mod;</span><br><span class="line">            fpow[i][j]=<span class="number">1ll</span>*fpow[i][j<span class="number">-1</span>]*fac[i]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    prod[k]=<span class="number">1</span>,sum[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=R[k<span class="number">-1</span>]+<span class="number">1</span>;i&lt;=R[k];i++)&#123;</span><br><span class="line">        cnt[k][a[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[k][a[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">            hd[k][a[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[i]=hd[k][a[i]];</span><br><span class="line">        sum[k]+=a[i];</span><br><span class="line">        <span class="built_in">mul</span>(prod[k],ifac[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=R[k<span class="number">-1</span>]+<span class="number">1</span>;i&lt;=R[k];i++)&#123;</span><br><span class="line">        a[i]=a[<span class="built_in">find</span>(i)];</span><br><span class="line">        hd[k][a[i]]=cnt[k][a[i]]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])&#123;</span><br><span class="line">        <span class="built_in">update</span>(bel[l]);</span><br><span class="line">        <span class="built_in">rep</span>(i,l,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==x)a[i]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(bel[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l!=R[bel[l]<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">update</span>(bel[l]);</span><br><span class="line">        <span class="built_in">rep</span>(i,l,R[bel[l]])&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==x)a[i]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(bel[l]);</span><br><span class="line">        l=R[bel[l]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r!=R[bel[r]])&#123;</span><br><span class="line">        <span class="built_in">update</span>(bel[r]);</span><br><span class="line">        <span class="built_in">rep</span>(i,R[bel[r]<span class="number">-1</span>]+<span class="number">1</span>,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==x)a[i]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(bel[r]);</span><br><span class="line">        r=R[bel[r]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,bel[l],bel[r])&#123;</span><br><span class="line">        <span class="keyword">if</span>(hd[i][x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(hd[i][y])&#123;</span><br><span class="line">                fa[hd[i][x]]=hd[i][y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hd[i][y]=hd[i][x];</span><br><span class="line">                a[hd[i][x]]=y;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[i]+=(y-x)*cnt[i][x];</span><br><span class="line">            <span class="built_in">mul</span>(prod[i],fpow[x][cnt[i][x]]);</span><br><span class="line">            <span class="built_in">mul</span>(prod[i],ipow[y][cnt[i][x]]);</span><br><span class="line">            cnt[i][y]+=cnt[i][x];</span><br><span class="line">            cnt[i][x]=hd[i][x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> S=<span class="number">0</span>,imul=<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,r)&#123;</span><br><span class="line">            a[i]=a[<span class="built_in">find</span>(i)];</span><br><span class="line">            S+=a[i];</span><br><span class="line">            <span class="built_in">mul</span>(imul,ifac[a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span>*fac[S]*imul%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l!=R[bel[l]<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,R[bel[l]])&#123;</span><br><span class="line">            a[i]=a[<span class="built_in">find</span>(i)];</span><br><span class="line">            S+=a[i];</span><br><span class="line">            <span class="built_in">mul</span>(imul,ifac[a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        l=R[bel[l]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r!=R[bel[r]])&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,R[bel[r]<span class="number">-1</span>]+<span class="number">1</span>,r)&#123;</span><br><span class="line">            a[i]=a[<span class="built_in">find</span>(i)];</span><br><span class="line">            S+=a[i];</span><br><span class="line">            <span class="built_in">mul</span>(imul,ifac[a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        r=R[bel[r]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,bel[l],bel[r])&#123;</span><br><span class="line">        S+=sum[i];</span><br><span class="line">        <span class="built_in">mul</span>(imul,prod[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[S]*imul%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    B=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        bel[i]=(i+B<span class="number">-1</span>)/B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n/B)&#123;</span><br><span class="line">        R[i]=i*B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%B)R[bel[n]]=n;</span><br><span class="line">    <span class="built_in">re</span>(i,bel[n])&#123;</span><br><span class="line">        <span class="built_in">build</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op,l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">modify</span>(l,r,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="built_in">query</span>(l,r),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>并查集</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P8600</title>
    <url>/2023/12/02/P8600/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8600">P8600 [蓝桥杯 2013
省 B] 连号区间数</a></p>
<span id="more"></span>
<p>比较经典的问题，比较经典的做法。</p>
<p>同类题：CF1175F</p>
<p>可以将问题转化为：</p>
<p>求区间 <span class="math inline">\([l,r]\)</span> 满足 <span
class="math inline">\(\max_{i=l}^rp_i-\min_{i=l}^rp_i=r-l\)</span>。</p>
<p>移项：<span
class="math inline">\(r=\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span>。</p>
<p>枚举 <span class="math inline">\(r\)</span>
考虑每个有多少个满足等式。</p>
<p>第一眼看上去不太好数 但可以注意到：</p>
<p><span
class="math inline">\(r\ge\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span>
一定成立。</p>
<p>也就是说 一个 <span class="math inline">\(r\)</span> 对应的 <span
class="math inline">\(l\)</span> 个数 是 <span
class="math inline">\(l\le r\)</span> 的所有 <span
class="math inline">\(\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span> 中的
最小值个数。</p>
<p>可以线段树维护。</p>
<p><span class="math inline">\(l\)</span> 这一项可以在建树时直接加上</p>
<p>问题在于 加入一个新的数的过程中 应该如何修改线段树中的 <span
class="math inline">\(\max\)</span> 和 <span
class="math inline">\(\min\)</span> 。</p>
<p>需要使用单调栈。</p>
<p>对于 <span class="math inline">\(\max\)</span> 来说，加入一个新的数
<span class="math inline">\(p_r\)</span> 时 如果单调栈需要弹出 <span
class="math inline">\(p_x\)</span> 弹出后栈顶为<span
class="math inline">\(p_y\)</span>。</p>
<p>也就是说 <span class="math inline">\(p_x\)</span>
不再是后缀最大值时，需要对 <span class="math inline">\([y+1,x]\)</span>
做修改： 加上 <span class="math inline">\(p_r\)</span> 再减掉之前加上的
<span class="math inline">\(p_x\)</span>。</p>
<p>对于 <span class="math inline">\(\min\)</span> 来说同理
都只是在做撤销/更新 而已。</p>
<p>枚举 <span class="math inline">\(r\)</span> 时，<span
class="math inline">\(Ans\)</span> 不断加上最小值个数。</p>
<p>显然复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mn,lz,cnt;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">    t[rt].cnt=t[<span class="built_in">ls</span>(rt)].cnt*(t[<span class="built_in">ls</span>(rt)].mn==t[rt].mn)+t[<span class="built_in">rs</span>(rt)].cnt*(t[<span class="built_in">rs</span>(rt)].mn==t[rt].mn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    t[rt].mn+=x;t[rt].lz+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">    t[rt].lz=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">      t[rt].mn=l,t[rt].cnt=<span class="number">1</span>,t[rt].lz=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">      <span class="built_in">update</span>(rt,x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,x);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,x);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> st1[N],st2[N],tp1,tp2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    x=i;</span><br><span class="line">    <span class="keyword">while</span>(tp1&amp;&amp;a[i]&gt;a[st1[tp1]])&#123;</span><br><span class="line">      t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,st1[tp1<span class="number">-1</span>]+<span class="number">1</span>,x<span class="number">-1</span>,a[i]-a[st1[tp1]]);</span><br><span class="line">      x=st1[tp1--];</span><br><span class="line">    &#125;</span><br><span class="line">    x=i;</span><br><span class="line">    <span class="keyword">while</span>(tp2&amp;&amp;a[i]&lt;a[st2[tp2]])&#123;</span><br><span class="line">      t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,st2[tp2<span class="number">-1</span>]+<span class="number">1</span>,x<span class="number">-1</span>,a[st2[tp2]]-a[i]);</span><br><span class="line">      x=st2[tp2--];</span><br><span class="line">    &#125;</span><br><span class="line">    st1[++tp1]=i;</span><br><span class="line">    st2[++tp2]=i;</span><br><span class="line">    ans+=t.t[<span class="number">1</span>].cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P8868</title>
    <url>/2023/12/20/P8868/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8868">P8868 [NOIP2022]
比赛</a></p>
<span id="more"></span>
<p>有一个很好的题解，较为模板化，形式化的通过双半群模型来做此类多标记的合并：<a
href="https://www.luogu.com.cn/blog/eulogized/solution-p8868">既已身披英雄之名，就应具备不容撼动的觉悟
- 致逝者的摇篮 - 洛谷博客 (luogu.com.cn)</a>。</p>
<p>题意：给定数列 <span class="math inline">\(A,B\)</span>，<span
class="math inline">\(q\)</span> 次询问 <span
class="math inline">\([l,r]\)</span>，求 <span
class="math inline">\(\sum_{i=l}^r\sum_{j=i}^r(max_{p=i}^jA_p)(max_{p=i}^jB_p)\)</span>。</p>
<p>不带修，区间的子区间问题不好直接做，考虑离线下来扫。</p>
<p>扫描线，维护一个不断向右的前缀，设当前扫到 <span
class="math inline">\(R\)</span>。</p>
<p>设 <span
class="math inline">\(X_p=max_{i=p}^RA_p,Y_p=max_{i=p}^RB_p\)</span>，也就是当前前缀的后缀最值，这里先不管
<span class="math inline">\(X,Y\)</span> 具体怎么求。</p>
<p>发现有一个好想的暴力：找到所有包含当前点 <span
class="math inline">\(R\)</span> 的询问区间，设某个询问区间为 <span
class="math inline">\([l,r],l\le R\le r\)</span>，那么 <span
class="math inline">\(p\in[l,R]\)</span> 的 <span
class="math inline">\(X_p\times Y_p\)</span> 会对区间 <span
class="math inline">\([l,r]\)</span> 贡献，实质是 <span
class="math inline">\([l,r]\)</span> 中前缀 <span
class="math inline">\([l,R]\)</span>
的后缀（也就是子区间）做了贡献。</p>
<p>复杂度爆炸。</p>
<p>观察对某个区间 <span class="math inline">\([l,r]\)</span>
有贡献的所有 <span class="math inline">\([l,R]\)</span>，是 <span
class="math inline">\([l,r]\)</span> 的所有前缀，而且都是 <span
class="math inline">\([1,R]\)</span> 的后缀。</p>
<p>可以发现，在 <span class="math inline">\(R=r\)</span> 时，查 <span
class="math inline">\([l,r]\)</span>
这个区间中，每个“版本”的和——也就是区间的<strong>历史和</strong>，和上面的暴力查询是完全等价的，原因显然：每次
<span class="math inline">\(R\)</span>
都是向右拓展的“新位置”，不包含其他值，所以历史上所有的值都可以贡献。</p>
<p>这里定义<strong>历史和</strong>为：设原序列为 <span
class="math inline">\(T\)</span>，在每次 <span
class="math inline">\(R\)</span> 向右拓展之前，做 <span
class="math inline">\(S_i\leftarrow S_i+T_i,i\in[1,R]\)</span>，<span
class="math inline">\(S\)</span> 就是 <span
class="math inline">\(T\)</span> 的历史和。</p>
<p>后文中 <span class="math inline">\(S_i\)</span> 均代表位置 <span
class="math inline">\(i\)</span> 上的 <span
class="math inline">\(X_i\times Y_i\)</span> 的历史和。</p>
<p>现在问题变为：查 <span
class="math inline">\(\sum_{i=l}^rS_i\)</span>，同时支持对 <span
class="math inline">\([1,R]\)</span> 某个后缀上 <span
class="math inline">\(X\times Y\)</span> 的修改（修改是区间覆盖）。</p>
<p><span class="math inline">\(X,Y\)</span>
作为前缀上的后缀最大值，用单调栈维护每次的修改范围。</p>
<p>处理历史和其实是在处理上面的定义，每次对 <span
class="math inline">\(p\in [1,R]\)</span> 的位置加上 <span
class="math inline">\(X_p\times Y_p\)</span>，在线段树上做。</p>
<p>比较难写，需要具体一点，两种思维模式。</p>
<h2 id="线段树标记的逻辑合并">线段树标记的逻辑合并</h2>
<p>先看维护的区间和怎么做。</p>
<p>设数列 <span class="math inline">\(XY_i=X_i\times
Y_i\)</span>，下文中 <span class="math inline">\(XY\)</span>
代表这个数列，而不是乘法。</p>
<p>维护 <span class="math inline">\(\sum S,\sum XY,\sum X,\sum
Y\)</span> 分别为区间内历史和，<span class="math inline">\(XY\)</span>
的和，<span class="math inline">\(X\)</span> 的和，<span
class="math inline">\(Y\)</span> 的和，这部分的合并/修改较为容易。</p>
<p>再看
<code>lazy-tag</code>，对于修改某一项，求整个式子区间和一类的问题，要考虑修改这一项之后式子的变化量。</p>
<p>需要维护 <span
class="math inline">\(c_X,c_Y,k_X,k_Y,k_1\)</span>，分别为对 <span
class="math inline">\(X\)</span> 覆盖的标记，对 <span
class="math inline">\(Y\)</span> 覆盖的标记，<span
class="math inline">\(\sum X\)</span> 的变化量系数，<span
class="math inline">\(\sum Y\)</span> 的变化量系数，常数变化量（<span
class="math inline">\(\sum 1\)</span> 或长度的变化量系数）</p>
<p>显然我们查询的时候，对当前前缀的某个后缀的最后一次操作，一定是覆盖，所以要规定加标记先处理，覆盖标记后处理。这样在下传的时候，下传的加标记会作用在原先的信息上。</p>
<p>也就是说，将标记 <span class="math inline">\(p\)</span> 合并到标记
<span class="math inline">\(q\)</span> 上，需要先判断标记 <span
class="math inline">\(q\)</span> 有没有覆盖标记，如果有就先用 <span
class="math inline">\(q\)</span> 的覆盖标记和 <span
class="math inline">\(p\)</span> 的加标记处理 <span
class="math inline">\(q\)</span> 的加标记，再将 <span
class="math inline">\(p\)</span> 的覆盖标记覆盖到 <span
class="math inline">\(q\)</span> 上。注意，如果 <span
class="math inline">\(q\)</span> 自己有覆盖标记，那么 <span
class="math inline">\(p\)</span> 对应的加标记就无效了。</p>
<p>对于<code>tag</code>和<code>tag</code>之间的信息合并，如果没有区间覆盖，直接对应加起来，否则，先将区间覆盖的贡献加到
<span class="math inline">\(k_{*}\)</span> 中，再修改 <span
class="math inline">\(c_*\)</span> 的值。</p>
<p><span class="math inline">\(k_{*}\)</span> 的修改需要写一下。</p>
<p>设 <span class="math inline">\(X\)</span> 被自己的标记覆盖成 <span
class="math inline">\(c_X\)</span>，那么 <span
class="math inline">\(k_{XY}\times \sum XY\)</span> 就变成了 <span
class="math inline">\(k_{XY}\times c_X\sum Y\)</span>，也就是 <span
class="math inline">\(k_{XY}\)</span> 转化成了 <span
class="math inline">\(k_{XY}\times c_X\)</span> 加到了 <span
class="math inline">\(k_Y\)</span> 内（注意这里不同的系数可能来自 <span
class="math inline">\(p\)</span> 或 <span
class="math inline">\(q\)</span>，详情见代码，是前面对 <span
class="math inline">\(p,q\)</span> 分讨的实现，思路不变）</p>
<p><span class="math inline">\(Y\)</span>
同理，这样更新后，所有加标记又都是应用在覆盖标记之前的，<strong>加的都是原值的倍数</strong>。</p>
<p>对于<code>tag</code>与区间和的信息合并，设 <span
class="math inline">\(len\)</span> 为当前节点长度，有： <span
class="math display">\[
\begin{aligned}
&amp;S&#39;=S+k_XX+k_YY+k_{XY}X\times Y+k_1\\
&amp;X&#39;=\begin{cases}X&amp;c_X=0\\c_X\times
len&amp;c_X\ne0\end{cases}\\
&amp;Y&#39;=\begin{cases}Y&amp;c_Y=0\\c_Y\times
len&amp;c_Y\ne0\end{cases}\\
&amp;XY&#39;=X&#39;\times Y&#39;
\end{aligned}
\]</span> 都维护一下就好了。</p>
<h2 id="隐式矩阵乘法">隐式矩阵乘法</h2>
<p>沿用上文的记号。</p>
<p>设序列 <span class="math inline">\(C_i=S_i-t\times
XY_i\)</span>，<span class="math inline">\(t\)</span>
为时间，历史和的“时间轴”长度。</p>
<p>这个 <span class="math inline">\(C\)</span>
是一种历史和的特定思路，也是<strong>十分经典</strong>的思路，如果只是维护一个平凡带修序列的历史和，而不是
<span class="math inline">\(X_i\times Y_i\)</span> 的复合形式，对 <span
class="math inline">\(C\)</span>
操作可以直接转化成：区间加与查询区间和，详情见 2016 年集训队论文。</p>
<p>注意 <span class="math inline">\(t,S,C\)</span>
都<strong>不包含当前操作</strong>，是上一次操作留下来的。</p>
<p>用矩阵去找系数的变化方法，代码中写隐式矩阵乘。</p>
<p>设 <span class="math inline">\(D\)</span> 为常数变化量，和上文 <span
class="math inline">\(k_1\)</span> 大小相同，有状态矩阵： <span
class="math display">\[
\begin{vmatrix}
\sum XY&amp;\sum X&amp;\sum Y&amp;D&amp;\sum C
\end{vmatrix}
\]</span> 转移矩阵： <span class="math display">\[
\begin{vmatrix}
[c_X=c_Y=0]&amp;0&amp;0&amp;0&amp;v_S\\
[c_X=0]c_Y&amp;[c_X=0]&amp;0&amp;0&amp;v_X\\
[c_Y=0]c_X&amp;0&amp;[c_Y=0]&amp;0&amp;v_Y\\
c_X\times c_Y&amp;c_X&amp;c_Y&amp;1&amp;v_D\\
0&amp;0&amp;0&amp;0&amp;1
\end{vmatrix}
\]</span> <span class="math inline">\(v_{*}\)</span> 是状态矩阵前四项对
<span class="math inline">\(\sum C\)</span> 的贡献系数，现在要推一推
<span class="math inline">\(v\)</span>。</p>
<p>设当前做了一些修改， <span class="math inline">\(*&#39;\)</span> 为
<span class="math inline">\(*\)</span>
在这次修改<strong>之前</strong>的值，有： <span class="math display">\[
\begin{aligned}
\Delta C_i=&amp;\Delta S_i-\Delta(t\times XY_i)\\
=&amp;\Delta t\times XY&#39;_i-(t&#39;+\Delta t)\times (XY&#39;_i+\Delta
XY_i)+t&#39;\times XY&#39;_i\\
=&amp;-\Delta XY_i\times t&#39;-\Delta t\times \Delta XY_i\\
=&amp;-\Delta XY_i\times (t&#39;+\Delta t)\\
=&amp;-t\times \Delta XY_i
\end{aligned}
\]</span> 关于为什么 <span class="math inline">\(\Delta S_i=\Delta
t\times XY&#39;_i\)</span>：<span class="math inline">\(S_i\)</span>
不包含当前操作，现在只需要补上前面没加上的历史和；事实上，就算将 <span
class="math inline">\(S,C\)</span> 设为包括当前操作的值，照着 <span
class="math inline">\(\Delta S_i=\Delta t\times XY_i\)</span>
推，最后也只是将每个 <span class="math inline">\(t\)</span> 改成了 <span
class="math inline">\(t-1\)</span>，不影响本质。</p>
<p>也就是说，总贡献系数是 <span class="math inline">\(-t\times \Delta
XY_i\)</span>。</p>
<p>若 <span class="math inline">\(X\)</span> 替换为 <span
class="math inline">\(c_X\)</span>，有 <span
class="math inline">\(\Delta XY_i=c_X\sum Y-\sum XY\)</span>，所以 <span
class="math inline">\(v_S=t,v_X=0,v_Y=-t\times c_X,v_D=0\)</span>。</p>
<p>若 <span class="math inline">\(Y\)</span> 替换为 <span
class="math inline">\(c_Y\)</span>，有 <span
class="math inline">\(\Delta XY_i=c_Y\sum X-\sum XY\)</span>，所以 <span
class="math inline">\(v_S=t,v_X=-t\times c_Y,v_Y=0,v_D=0\)</span>。</p>
<p><del>好像 <span class="math inline">\(v_D\)</span> 没啥用。</del></p>
<p><span class="math inline">\(S_i=C_i+t\times XY_i\)</span>，别忘了
<span class="math inline">\(t,S,C\)</span> 都不包含当前操作，每次查询
<span class="math inline">\([l,r]\)</span> 的答案为 <span
class="math inline">\(\sum_{i=l}^rC_i+(t+1)\times
XY_i\)</span>，查询维护好的 <span class="math inline">\(C,XY\)</span>
区间和即可。</p>
<p>直接矩阵乘法常数过大，<span class="math inline">\(0\)</span>
比较多，需要手动模拟矩阵乘法（隐式）。</p>
<p>注意到所有修改只有转移矩阵的最后一列不同，所以修改传递的标记也只需要记录最后一列，代码很直观。</p>
<p>矩阵乘法的思维方式更通用，比较有实际意义。</p>
<h2 id="代码">代码</h2>
<p>第一种写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, qn;</span><br><span class="line">ull a[N], b[N], ans[N], la[N], lb[N];</span><br><span class="line">vector&lt;pii&gt; q[N];</span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> tN = <span class="number">2.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    ull cx, cy, adxy, adx, ady, ad1;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Tag&amp; b) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [cx, cy, adxy, adx, ady, ad1] = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (cx &amp;&amp; cy)</span><br><span class="line">            ad1 += b.adxy * cx * cy + b.adx * cx + b.ady * cy + b.ad1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cx)</span><br><span class="line">            ad1 += b.adx * cx + b.ad1, ady += b.adxy * cx + b.ady;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cy) &#123;</span><br><span class="line">            ad1 += b.ady * cy + b.ad1, adx += b.adxy * cy + b.adx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            adxy += b.adxy;</span><br><span class="line">            adx += b.adx;</span><br><span class="line">            ady += b.ady;</span><br><span class="line">            ad1 += b.ad1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b.cx) cx = b.cx;</span><br><span class="line">        <span class="keyword">if</span> (b.cy) cy = b.cy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cx = cy = adxy = adx = ady = ad1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (cx || cy || adxy || adx || ady || ad1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dat</span> &#123;</span><br><span class="line">    ull res, xy, x, y;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">Dat</span>() &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Dat <span class="keyword">operator</span>*(<span class="type">const</span> Dat&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        Dat c;</span><br><span class="line">        c.res = res + b.res;</span><br><span class="line">        c.xy = xy + b.xy;</span><br><span class="line">        c.x = x + b.x;</span><br><span class="line">        c.y = y + b.y;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Tag&amp; b) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [res, xy, x, y, len] = *<span class="keyword">this</span>;</span><br><span class="line">        res += b.adxy * xy + b.adx * x + b.ady * y + b.ad1 * len;</span><br><span class="line">        <span class="keyword">if</span> (b.cx &amp;&amp; b.cy) &#123;</span><br><span class="line">            xy = b.cx * b.cy * len, x = b.cx * len, y = b.cy * len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b.cx) &#123;</span><br><span class="line">            xy = b.cx * y;</span><br><span class="line">            x = b.cx * len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b.cy) &#123;</span><br><span class="line">            xy = x * b.cy;</span><br><span class="line">            y = b.cy * len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    Dat v;</span><br><span class="line">    Tag lz;</span><br><span class="line">&#125; t[tN * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].v = t[<span class="built_in">ls</span>(rt)].v * t[<span class="built_in">rs</span>(rt)].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, Tag k)</span> </span>&#123;</span><br><span class="line">    t[rt].v += k;</span><br><span class="line">    t[rt].lz += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[rt].lz.<span class="built_in">exist</span>()) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), t[rt].lz);</span><br><span class="line">        t[rt].lz.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ml, <span class="type">int</span> mr, Tag k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= l &amp;&amp; r &lt;= mr) &#123;</span><br><span class="line">        <span class="built_in">update</span>(rt, k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">ls</span>(rt), l, mid, ml, mr, k);</span><br><span class="line">    <span class="keyword">if</span> (mr &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ml, mr, k);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt].v.res;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    ull res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace SGT</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Tes = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(Tes, n);</span><br><span class="line">    a[<span class="number">0</span>] = b[<span class="number">0</span>] = inf;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        la[i] = i;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &gt; a[la[i] - <span class="number">1</span>]) la[i] = la[la[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        lb[i] = i;</span><br><span class="line">        <span class="keyword">while</span> (b[i] &gt; b[lb[i] - <span class="number">1</span>]) lb[i] = lb[lb[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(qn);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, qn) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l, r);</span><br><span class="line">        q[r].<span class="built_in">pb</span>(&#123; l, i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(r, n) &#123;</span><br><span class="line">        SGT::<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, la[r], r, (SGT::Tag)&#123; a[r], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        SGT::<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, lb[r], r, (SGT::Tag)&#123; <span class="number">0</span>, b[r], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        SGT::<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, r, (SGT::Tag)&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [l, id] : q[r]) &#123;</span><br><span class="line">            ans[id] = SGT::<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, qn) &#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2.5e5</span>;</span><br><span class="line"><span class="type">int</span> testId, n, q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataAB</span> &#123;</span><br><span class="line">    <span class="type">int</span> val, pre;</span><br><span class="line">&#125; arr[N + <span class="number">10</span>], brr[N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPre</span><span class="params">(DataAB data[])</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val[N + <span class="number">10</span>], id[N + <span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    foru(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &amp;&amp; val[cnt] &lt; data[i].val) --cnt;</span><br><span class="line">        data[i].pre = id[cnt];</span><br><span class="line">        ++cnt;</span><br><span class="line">        val[cnt] = data[i].val, id[cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    ull a, b;</span><br><span class="line">    ull c, ca, cb, cl;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(a || b || c || ca || cb || cl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = b = <span class="number">0</span>;</span><br><span class="line">        c = ca = cb = cl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Tag&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">empty</span>()) <span class="keyword">return</span> (<span class="type">void</span>)(*<span class="keyword">this</span> = t);</span><br><span class="line">        <span class="comment">// matrix 1</span></span><br><span class="line">        <span class="type">const</span> ull a1s = a ? <span class="number">0</span> : b, b1s = b ? <span class="number">0</span> : a;</span><br><span class="line">        <span class="type">const</span> ull a1a = a ? <span class="number">0</span> : <span class="number">1</span>, b1b = b ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> ull l1s = a * b, l1a = a, l1b = b;</span><br><span class="line">        <span class="type">const</span> ull s1c = c, a1c = ca, b1c = cb, l1c = cl;</span><br><span class="line">        <span class="comment">// matrix 2</span></span><br><span class="line">        <span class="type">const</span> ull s2c = t.c, a2c = t.ca, b2c = t.cb, l2c = t.cl;</span><br><span class="line">        <span class="comment">// matrix result</span></span><br><span class="line">        <span class="type">const</span> ull sc = s1c * <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> ull ac = a1s * s2c + a1a * a2c + a1c * <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> ull bc = b1s * s2c + b1b * b2c + b1c * <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> ull lc = l1s * s2c + l1a * a2c + l1b * b2c + <span class="number">1</span> * l2c + l1c * <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">        c = sc, ca = ac, cb = bc, cl = lc;</span><br><span class="line">        <span class="keyword">if</span> (t.a) a = t.a;</span><br><span class="line">        <span class="keyword">if</span> (t.b) b = t.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ull s, sa, sb, c;</span><br><span class="line">    Tag tag;</span><br><span class="line">&#125; tree[N * <span class="number">4</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    Node &amp;self = tree[p], &amp;ls = tree[p &lt;&lt; <span class="number">1</span>], &amp;rs = tree[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    self.s = ls.s + rs.s;</span><br><span class="line">    self.sa = ls.sa + rs.sa;</span><br><span class="line">    self.sb = ls.sb + rs.sb;</span><br><span class="line">    self.c = ls.c + rs.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag&amp; tag)</span> </span>&#123;</span><br><span class="line">    Node&amp; self = tree[p];</span><br><span class="line">    <span class="type">const</span> ull len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> ull s = self.s, sa = self.sa, sb = self.sb;</span><br><span class="line">    <span class="keyword">if</span> (tag.a &amp;&amp; tag.b) &#123;</span><br><span class="line">        self.s = tag.a * tag.b * len;</span><br><span class="line">        self.sa = tag.a * len;</span><br><span class="line">        self.sb = tag.b * len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tag.a) &#123;</span><br><span class="line">        self.s = tag.a * sb;</span><br><span class="line">        self.sa = tag.a * len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tag.b) &#123;</span><br><span class="line">        self.s = tag.b * sa;</span><br><span class="line">        self.sb = tag.b * len;</span><br><span class="line">    &#125;</span><br><span class="line">    self.c += tag.c * s + tag.ca * sa + tag.cb * sb + tag.cl * len;</span><br><span class="line">    self.tag.<span class="built_in">add</span>(tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[p].tag.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">set_val</span>(p &lt;&lt; <span class="number">1</span>, l, mid, tree[p].tag);</span><br><span class="line">    <span class="built_in">set_val</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tree[p].tag);</span><br><span class="line">    tree[p].tag.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag&amp; tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> (<span class="type">void</span>)<span class="built_in">set_val</span>(p, l, r, tag);</span><br><span class="line">    <span class="built_in">push_down</span>(p, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span>, l, mid, x, y, tag);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid) <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, tag);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> gt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> tree[p].c + (gt + <span class="number">1</span>) * tree[p].s;</span><br><span class="line">    <span class="built_in">push_down</span>(p, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, x, y, gt);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, gt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, x, y, gt) + <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, gt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cerr;</span><br><span class="line">    fio &gt;&gt; testId &gt;&gt; n;</span><br><span class="line">    foru(i, <span class="number">1</span>, n) fio &gt;&gt; arr[i].val;</span><br><span class="line">    foru(i, <span class="number">1</span>, n) fio &gt;&gt; brr[i].val;</span><br><span class="line">    fio &gt;&gt; q;</span><br><span class="line">    <span class="built_in">getPre</span>(arr), <span class="built_in">getPre</span>(brr);</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">Ques</span> &#123;</span><br><span class="line">        <span class="type">int</span> id, l, r;</span><br><span class="line">    &#125; ques[N + <span class="number">10</span>];</span><br><span class="line">    <span class="type">static</span> ull ans[N + <span class="number">10</span>];</span><br><span class="line">    foru(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        ques[i].id = i;</span><br><span class="line">        fio &gt;&gt; ques[i].l &gt;&gt; ques[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(ques + <span class="number">1</span>, ques + <span class="number">1</span> + q, [](<span class="type">const</span> Ques&amp; a, <span class="type">const</span> Ques&amp; b) &#123; <span class="keyword">return</span> a.r &lt; b.r; &#125;);</span><br><span class="line">    <span class="type">int</span> cntR = <span class="number">0</span>;</span><br><span class="line">    foru(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cntR &lt; ques[i].r) &#123;</span><br><span class="line">            ++cntR;</span><br><span class="line">            ull a = arr[cntR].val, b = brr[cntR].val, gt = cntR;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, arr[cntR].pre + <span class="number">1</span>, cntR, Tag&#123; a, <span class="number">0</span>, gt, <span class="number">0</span>, -gt * a, <span class="number">0</span> &#125;);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, brr[cntR].pre + <span class="number">1</span>, cntR, Tag&#123; <span class="number">0</span>, b, gt, -gt * b, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ques[i].id] = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, ques[i].l, ques[i].r, cntR);</span><br><span class="line">    &#125;</span><br><span class="line">    foru(i, <span class="number">1</span>, q) fio &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P8945</title>
    <url>/2023/12/02/P8945/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8945">P8945
Inferno</a></p>
<span id="more"></span>
<p>值域为 <span class="math inline">\(\{-1,0,1\}\)</span> 的数组，在为
<span class="math inline">\(0\)</span> 的位置中选 <span
class="math inline">\(k\)</span> 个位置放 <span
class="math inline">\(1\)</span>，其余放 <span
class="math inline">\(-1\)</span>，求最大子段和。</p>
<p><span class="math inline">\(n\le 10^7\)</span>，<span
class="math inline">\(777ms\)</span>，需要线性做法。</p>
<p>首先，<span class="math inline">\(1\)</span> 肯定是放在一起，放 <span
class="math inline">\(1\)</span> 的位置之间不会放 <span
class="math inline">\(-1\)</span>。</p>
<p>考虑枚举最终成为最大子段的右端点 <span
class="math inline">\(r\)</span>。</p>
<p>显然，对于左端点 <span class="math inline">\(l\)</span>
的位置来说，本质上的区别在于：在 <span class="math inline">\(l\)</span>
到 <span class="math inline">\(r\)</span> 中是否有 <span
class="math inline">\(k\)</span> 个以上的 <span
class="math inline">\(0\)</span>。</p>
<p>分讨，设 <span class="math inline">\(0\)</span> 个数的前缀和为 <span
class="math inline">\(c\)</span>，原数组前缀和为 <span
class="math inline">\(s\)</span>。</p>
<p>当 <span class="math inline">\(c_r-c_{l-1}\le k\)</span> 时，和为
<span class="math inline">\(s_r-s_{l-1}+c_r-c_{l-1}\)</span>。</p>
<p>当 <span class="math inline">\(c_r-c_{l-1}&gt; k\)</span> 时，和为
<span class="math inline">\(s_r-s_{l-1}-c_r+c_{l-1}+2k\)</span>。</p>
<p>我们设前 <span class="math inline">\(i\)</span> 个数，<span
class="math inline">\(0\)</span> 都放上 <span
class="math inline">\(1\)</span> 之后的和为 <span
class="math inline">\(p\)</span>，<span class="math inline">\(0\)</span>
都放上 <span class="math inline">\(-1\)</span> 之后的和为 <span
class="math inline">\(q\)</span>。</p>
<p>现在上面两个式子就分别为 <span
class="math inline">\(p_r-p_{l-1}\)</span> 和 <span
class="math inline">\(q_r-q_{l-1}+2k\)</span>。</p>
<p>显然对于 <span class="math inline">\(c_r-c_{l-1}&gt;k\)</span>
的情况，<span class="math inline">\(l\)</span> 放的位置一定是 <span
class="math inline">\(r\)</span> 前面 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(0\)</span> 之前的前缀最小 <span
class="math inline">\(q\)</span>，这个可以扫的时候动态维护最右边的合法位置
<span class="math inline">\(pos\)</span> 和最小值。</p>
<p><span class="math inline">\(c_r-c_{l-1}\le k\)</span>
的情况用单调队列维护 <span class="math inline">\(r\)</span>
前面的一段合法区间最小值即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e7</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, k, a[N], p[N], q[N], c[N];</span><br><span class="line"><span class="type">int</span> que[N], fr, bk;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n, k);</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, pos = <span class="number">0</span>, mnpos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] + a[i] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    q[i] = q[i - <span class="number">1</span>] + a[i] - (a[i] == <span class="number">0</span>);</span><br><span class="line">    c[i] = c[i - <span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= bk &amp;&amp; c[i] - c[que[fr]] &gt;= k)fr++;</span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= bk &amp;&amp; p[i] &lt; p[que[bk]])bk--;</span><br><span class="line">    que[++bk] = i;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, p[i] - p[que[fr]]);</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt; k) &#123;</span><br><span class="line">      <span class="keyword">while</span> (c[i] - c[pos] &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[mnpos] &gt; q[pos])mnpos = pos;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, q[i] - q[mnpos] + <span class="number">2</span> * k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8974</title>
    <url>/2024/01/01/P8974/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8974">P8974 『GROI-R1』
古朴而优雅</a></p>
<span id="more"></span>
<p>对于一棵树，设 <span class="math inline">\(\deg(u)\)</span>
为儿子个数（外向树出度），遍历方案为： <span class="math display">\[
f(V,E)=\prod_{u}\deg(u)!
\]</span> 显然正确，不存在重复计数，树上递归路径和序列构成双射。</p>
<p>现在考虑加边后的基环树怎么数。</p>
<p>首先，因为是在基环树上跑 DFS
树，一定有且仅有一条边没被访问，且一定在环上。</p>
<p>找这个环是容易的，如果当前要加入边 <span
class="math inline">\((u,v)\)</span>，那么这个环就是<span
class="math inline">\((u\to lca(u,v))\cup (v\to lca(u,v))\cup
(u,v)\)</span>。</p>
<p>更进一步的，因为 DFS 遍历一定会走到最底部才回溯，所以当进入 <span
class="math inline">\(lca(u,v)\)</span>
的子树时，环上边会（顺/逆时针）逐个被遍历，直到当前的边变成了返祖边——也就是有
<span class="math inline">\(lca(u,v)\)</span> 作为端点的边才停止。</p>
<p>所以说，这条没被访问的边不仅在环上，而且其中一个端点还是 <span
class="math inline">\(lca(u,v)\)</span>。</p>
<p>显然，这样的边至多两条，设为 <span
class="math inline">\(e_1,e_2\)</span>。</p>
<p>答案变为 <span class="math inline">\(f(V,E\setminus
\{e_1\})+f(V,E\setminus
\{e_2\})\)</span>，容易发现，两者的答案集合互斥，没有重复计数——树不一样，当然不重复。</p>
<p>断一条边，连一条边，最多更改四个点的 <span
class="math inline">\(\deg\)</span>，预处理一下阶乘和阶乘的逆元，直接算
<span class="math inline">\(f\)</span> 即可。</p>
<p>找 <span class="math inline">\(lca\)</span> 两侧在 <span
class="math inline">\(u,v\)</span> 方向上的边可以树上倍增解决。</p>
<p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fac[N], inv[N];</span><br><span class="line"><span class="type">int</span> lg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = fac[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, N - <span class="number">5</span>) &#123;</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = <span class="number">1ll</span> * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, N - <span class="number">5</span>) inv[i] = <span class="number">1ll</span> * inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, N - <span class="number">5</span>) lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Lg = <span class="number">19</span>;</span><br><span class="line"><span class="type">int</span> fa[N][Lg + <span class="number">2</span>], dep[N], deg[N];</span><br><span class="line"><span class="type">int</span> nocir = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, Lg) &#123;</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        deg[u]++;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    nocir = <span class="number">1ll</span> * nocir * fac[deg[u]] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">        u = fa[u][lg[dep[u] - dep[v]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="built_in">per</span>(i, lg[dep[u]], <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1ll</span> * nocir * inv[deg[u]] % mod * inv[deg[v]] % mod * inv[deg[x]] % mod * inv[deg[y]] % mod;</span><br><span class="line">    deg[u]--, deg[v]--, deg[x]++, deg[y]++;</span><br><span class="line">    cur = <span class="number">1ll</span> * cur * fac[deg[u]] % mod * fac[deg[v]] % mod * fac[deg[x]] % mod * fac[deg[y]] % mod;</span><br><span class="line">    deg[u]++, deg[v]++, deg[x]--, deg[y]--;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> d = dep[v] - dep[u] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, lg[d + <span class="number">1</span>], <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;&gt; i &amp; <span class="number">1</span>) v = fa[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">getSon</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &gt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u == rt) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; v, <span class="built_in">jump</span>(u, v) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">jump</span>(rt, u), <span class="built_in">jump</span>(rt, v) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n, q);</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        w = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (dep[u] + dep[v] - <span class="number">2</span> * dep[w] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">write</span>(nocir, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">tie</span>(x, y) = <span class="built_in">getSon</span>(w, u, v);</span><br><span class="line">        <span class="built_in">write</span>((<span class="number">1ll</span> * <span class="built_in">calc</span>(w, x, u, v) + <span class="built_in">calc</span>(w, y, u, v)) % mod, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>计数</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>P9135</title>
    <url>/2024/01/07/P9135/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9135">P9135 [THUPC 2023
初赛] 快速 LCM 变换</a></p>
<span id="more"></span>
<p>首先形式化 <span class="math inline">\(\textrm{lcm}\)</span>。</p>
<p>记 <span class="math inline">\(v_p(x)\)</span> 为 <span
class="math inline">\(x\)</span> 中质因子 <span
class="math inline">\(p\)</span> 的个数，<span
class="math inline">\(a_p=\max\limits_{x\in r}v_p(x)\)</span>。</p>
<p>有： <span class="math display">\[
\textrm{lcm}=\prod_{p}p^{a_p}
\]</span> 考虑删掉 <span class="math inline">\(r_i,r_j\)</span>，加入
<span class="math inline">\(r_i+r_j\)</span> 会有什么影响。</p>
<p>设 <span
class="math inline">\(b_p=\textrm{secmax}\;v_p(x)\)</span>。</p>
<ul>
<li><p>如果 <span class="math inline">\(v_p(r_i)\ne
v_p(r_j)\)</span>，显然有 <span
class="math inline">\(v_p(r_i+r_j)=\min\{v_p(r_i),v_p(r_j)\}\)</span>。</p>
<p>对于 <span class="math inline">\(a_p=b_p\)</span>
的情况，无论如何都能留下来一个最大值，不会被操作影响，不考虑。</p>
<p>对于其他情况，容易发现，只要不扔最大值，一样不会被影响，不考虑。</p>
<p>只需要单独考虑扔最大值的情况，固定了 <span
class="math inline">\(v_p(r_i)=a_p\)</span>。</p>
<p>当 <span class="math inline">\(v_p(r_j)=b_p\)</span>，有 <span
class="math inline">\(v_p(r_i+r_j)=b_p\)</span>；对于其他情况，显然
<span class="math inline">\(v_p(r_j)\le b_p\)</span>，所以 <span
class="math inline">\(v_p(r_i+r_j)\le b_p\)</span>，这里 <span
class="math inline">\(b_p\)</span> 被保留了下来，也就是说 <span
class="math inline">\(b_p\)</span> 作为了新的最大值。和 <span
class="math inline">\(v_p(r_j)=b_p\)</span> 是一样的。</p>
<p>综上，只有当 <span class="math inline">\(v_p(r_i),v_p(r_j)\)</span>
中至少有一个为 <span class="math inline">\(a_p\)</span> 时，操作 <span
class="math inline">\(i,j\)</span> 才会有影响。</p></li>
<li><p>如果 <span
class="math inline">\(v_p(r_i)=v_p(r_j)\)</span>，<span
class="math inline">\(v_p(r_i+r_j)\)</span> <strong>可能</strong>会在
<span class="math inline">\(\min\{v_p(r_i),v_p(r_j)\}\)</span>
的基础上增加。</p>
<p>当 <span
class="math inline">\(v_p(r_i)=v_p(r_j)=a_p\)</span>，答案不会更劣。不过在这种情况下，单独扔掉
<span class="math inline">\(r_i\)</span> 或 <span
class="math inline">\(r_j\)</span> 都没有任何贡献。</p>
<p>对于其他情况，答案也是不会更劣，新的 <span
class="math inline">\(v_p(r_i)+v_p(r_j)\)</span> 可能会顶替掉现有的
<span class="math inline">\(a_p\)</span>，不过，单独扔掉 <span
class="math inline">\(r_i\)</span> 或 <span
class="math inline">\(r_j\)</span> 还是没有任何贡献。</p></li>
</ul>
<p>设 <span class="math inline">\(h(x)\)</span> 为扔掉 <span
class="math inline">\(x\)</span> 后 <span
class="math inline">\(\textrm{lcm}\)</span> 的变化系数，<span
class="math inline">\(g(x)\)</span> 为增加 <span
class="math inline">\(x\)</span> 后 <span
class="math inline">\(\textrm{lcm}\)</span> 的变化系数，<span
class="math inline">\(h,g\)</span> 容易处理，质因子之间互不影响，把每个
<span class="math inline">\(p\)</span> 都乘一起就行。</p>
<p>根据上面的讨论，<span
class="math inline">\(h(r_i),h(r_j),g(r_i+r_j)\)</span> 至多有一个不为
<span
class="math inline">\(1\)</span>（这是前面强调单独减少无贡献的原因）。</p>
<p>答案为： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i&lt;j}\textrm{lcm}\times g(r_i+r_j)h(r_i)h(r_j)\\
=&amp;\frac{1}{2}\textrm{lcm}\sum_{k}g(k)\sum_{r_i+r_j=k,\,i\ne
j}h(a_i)h(a_j)
\end{aligned}
\]</span> 我们忽略了 <span class="math inline">\(i&lt;j\)</span>
的限制，所以需要对答案除二。不要忘了减去 <span
class="math inline">\(i=j\)</span> 的贡献。</p>
<p>第二个和式是卷积形式，直接做。</p>
<p>代码中 <span class="math inline">\(a_p,b_p\)</span> 是上述的 <span
class="math inline">\(p^{a_p},p^{b_p}\)</span>。复杂度 <span
class="math inline">\(O(r\log r)\)</span>，值域相关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">namespace</span> PL&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> polynomial_assert(...) assert(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> polynomial_assert(...) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> mod, <span class="type">int</span> G&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lg2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> ^ __builtin_clz(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">modadd</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + ((x &gt;&gt; <span class="number">31</span>) &amp; mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">modsub</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= mod ? x - mod : x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = (ll)ret * x % mod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(y &gt;&gt;= <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            x = (ll)x * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">get_power_G</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; vct&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SZ</span>(vct) &lt; len) &#123;</span><br><span class="line">            len = <span class="built_in">lg2</span>(len);</span><br><span class="line">            <span class="type">int</span> k = last;</span><br><span class="line">            vct.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; len);</span><br><span class="line">            vct[<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>)] = <span class="built_in">qpow</span>(G, (mod - <span class="number">1</span>) &gt;&gt; (len + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; k; i--)</span><br><span class="line">                vct[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = (ll)vct[<span class="number">1</span> &lt;&lt; i] * vct[<span class="number">1</span> &lt;&lt; i] % mod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> lim = (<span class="number">1</span> &lt;&lt; k); k &lt; len; k++, lim &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = lim + <span class="number">1</span>; i &lt; (lim &lt;&lt; <span class="number">1</span>); i++)</span><br><span class="line">                    vct[i] = (ll)vct[i - lim] * vct[lim] % mod;</span><br><span class="line"></span><br><span class="line">            last = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DIF</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;power = <span class="built_in">get_power_G</span>(arr.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">SZ</span>(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (lim &gt;&gt; <span class="number">1</span>); i &gt;= <span class="number">1</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                ll x = arr[k], y = arr[i + k];</span><br><span class="line">                arr[k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                arr[i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (i &lt;&lt; <span class="number">1</span>), t = <span class="number">1</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>), t++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    ll x = arr[j + k], y = (ll)arr[j + i + k] * power[t] % mod;</span><br><span class="line">                    arr[j + k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                    arr[j + i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DIT</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;power = <span class="built_in">get_power_G</span>(arr.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">SZ</span>(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                ll x = arr[k], y = arr[i + k];</span><br><span class="line">                arr[k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                arr[i + k] = <span class="built_in">modadd</span>(x - y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (i &lt;&lt; <span class="number">1</span>), t = <span class="number">1</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>), t++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    ll x = arr[j + k], y = arr[j + i + k];</span><br><span class="line">                    arr[j + k] = <span class="built_in">modsub</span>(x + y);</span><br><span class="line">                    arr[j + i + k] = (ll)(x - y + mod) * power[t] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll invlim = <span class="built_in">qpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">            arr[i] = (ll)arr[i] * invlim % mod;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>() + <span class="number">1</span>, arr.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Polynomial</span>() : <span class="built_in">a</span>(&#123;<span class="number">0</span>&#125;) &#123;&#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= x &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> : a(&#123;</span>x&#125;) &#123;&#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= a[i] &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;rhs)</span> : a(rhs) &#123;</span></span><br><span class="line">        <span class="built_in">polynomial_assert</span>(!a.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要保证 0 &lt;= a[i] &lt; mod</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rhs)</span> : a(rhs) &#123;</span></span><br><span class="line">        <span class="built_in">polynomial_assert</span>(!a.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="keyword">operator</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    Polynomial &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Polynomial &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">min</span>(<span class="built_in">SZ</span>(a), <span class="built_in">SZ</span>(rhs.a)) &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l_ = <span class="built_in">SZ</span>(a) + <span class="built_in">SZ</span>(rhs.a) - <span class="number">1</span>;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(SZ(a) + SZ(rhs.a) - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">SZ</span>(a); i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">SZ</span>(rhs.a); j++) &#123;</span><br><span class="line">                    ret[i + j] += (ll)a[i] * rhs.a[j] % mod;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ret[i + j] &gt;= mod)</span><br><span class="line">                        ret[i + j] -= mod;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            *<span class="keyword">this</span> = <span class="built_in">Polynomial</span>(std::<span class="built_in">move</span>(ret));</span><br><span class="line">            a.<span class="built_in">resize</span>(l_);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">SZ</span>(a) + <span class="built_in">SZ</span>(rhs.a) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l_ = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &amp; (l - <span class="number">1</span>))</span><br><span class="line">            l = <span class="number">1</span> &lt;&lt; (<span class="built_in">lg2</span>(l) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        a.<span class="built_in">resize</span>(l), <span class="built_in">DIF</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            Polynomial rhs_ = rhs;</span><br><span class="line">            rhs_.a.<span class="built_in">resize</span>(l), <span class="built_in">DIF</span>(rhs_.a);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">                a[i] = (ll)a[i] * rhs_.a[i] % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">                a[i] = (ll)a[i] * a[i] % mod;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DIT</span>(a);</span><br><span class="line">        a.<span class="built_in">resize</span>(l_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SZ</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SZ</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">resize</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> Polynomial <span class="keyword">operator</span>*(<span class="type">const</span> Polynomial &amp;x, <span class="type">const</span> Polynomial &amp;y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Polynomial</span>(x) *= y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Poly = Polynomial&lt;mod, <span class="number">3</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>,nR=<span class="number">2e6</span>+<span class="number">5</span>,R=<span class="number">2e6</span>;</span><br><span class="line"><span class="type">int</span> n,r[N],h[R],g[R];</span><br><span class="line"><span class="type">int</span> inv[nR],pfac[nR],a[nR],b[nR],Lcm;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,R)&#123;</span><br><span class="line">        inv[i]=<span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    pfac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pfac[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=R;j+=i)&#123;</span><br><span class="line">            pfac[j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getGH</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="type">int</span> x=r[i];</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> p=pfac[x],s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pfac[x]==p)x/=p,s*=p;</span><br><span class="line">            <span class="keyword">if</span>(a[p]&lt;s)<span class="built_in">swap</span>(a[p],s);</span><br><span class="line">            <span class="keyword">if</span>(b[p]&lt;s)<span class="built_in">swap</span>(b[p],s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Lcm=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])Lcm=<span class="number">1ll</span>*Lcm*a[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,R)&#123;</span><br><span class="line">        <span class="type">int</span> x=i,t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> p=pfac[x],s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pfac[x]==p)x/=p,s*=p;</span><br><span class="line">            <span class="keyword">if</span>(b[p]&lt;s)&#123;</span><br><span class="line">                t=<span class="number">1ll</span>*t*inv[s]%mod*<span class="built_in">max</span>(<span class="number">1</span>,b[p])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,R)&#123;</span><br><span class="line">        <span class="type">int</span> x=i,t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> p=pfac[x],s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pfac[x]==p)x/=p,s*=p;</span><br><span class="line">            <span class="keyword">if</span>(a[p]&lt;s)&#123;</span><br><span class="line">                t=<span class="number">1ll</span>*t*inv[a[p]]%mod*s%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getGH</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(R+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[r[i]]=(f[r[i]]+h[r[i]])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PL::Poly <span class="title">F</span><span class="params">(f)</span></span>;</span><br><span class="line">    F=F*F;</span><br><span class="line">    f=F.<span class="built_in">data</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[r[i]+r[i]]=(f[r[i]+r[i]]<span class="number">-1ll</span>*h[r[i]]*h[r[i]]%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,R)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*g[i]*f[i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">1ll</span>*ans*Lcm%mod*inv[<span class="number">2</span>]%mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>P9346</title>
    <url>/2023/12/02/P9346/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9346">P9346
无可奈何花落去</a></p>
<span id="more"></span>
<p>先翻译凋零的条件。</p>
<p>凋零的条件其实就是把这个树切成若干个链。</p>
<p>多步操作期望计算，考虑期望线性性。</p>
<p>期望持续的轮数，通过期望的线性性拆成经过每个非终止状态的期望次数之和。</p>
<p>本题中，树上所有边的每种状态只会经过一次；同时，非终止状态的任何前置状态都是非终止状态。所以有简单结论：如果一个非终止状态是删去了条边得到，那么经过该状态的期望次数为
<span class="math inline">\(\binom{n-1}{x}^{-1}\)</span>。</p>
<p>于是只需要求有多少种删去 <span class="math inline">\(x\)</span>
条边的未终止状态。未终止状态不好算，容斥转化为计数删去了 <span
class="math inline">\(x\)</span> 条边的终止状态，然后用 <span
class="math inline">\(\binom{n-1}{x}\)</span> 减去即可。</p>
<p>树形 DP，设 <span class="math inline">\(f[i][j][k]\)</span> 表示以
<span class="math inline">\(i\)</span> 为根的子树，保留 <span
class="math inline">\(j\)</span> 条边，根的度数为 <span
class="math inline">\(k\)</span> 的方案总数。容易得出 <span
class="math inline">\(k\in[0,2]\)</span>，则可以通过树上背包得到 <span
class="math inline">\(O(n^2)\)</span> 的复杂度。</p>
<p>写法都是比较经典的树上背包写法，DP式子就是乘法原理，<span
class="math inline">\(g\)</span> 数组只是一个 <span
class="math inline">\(temp\)</span> 数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e3</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">985661441</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,fa[N];</span><br><span class="line">ll f[N][N][<span class="number">3</span>],g[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N],finv[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=finv[<span class="number">0</span>]=finv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    finv[n]=<span class="built_in">qpow</span>(fac[n],Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">2</span>)finv[i]=finv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*finv[m]%Mod*finv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">iC</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> finv[n]*fac[m]%Mod*fac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="built_in">DP</span>(v);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,siz[u]<span class="number">-1</span>)<span class="built_in">rep</span>(p,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,siz[v]<span class="number">-1</span>)<span class="built_in">rep</span>(q,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                x=f[u][i][p]*f[v][j][q]%Mod;</span><br><span class="line">                g[i+j][p]+=x;</span><br><span class="line">                <span class="keyword">if</span>(p&lt;<span class="number">2</span>&amp;&amp;q&lt;<span class="number">2</span>)g[i+j+<span class="number">1</span>][p+<span class="number">1</span>]+=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,siz[u]+siz[v]<span class="number">-1</span>)<span class="built_in">rep</span>(p,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            f[u][i][p]=g[i][p]%Mod;</span><br><span class="line">            g[i][p]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">        <span class="built_in">ae</span>(fa[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">DP</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        x=(<span class="built_in">C</span>(n<span class="number">-1</span>,i)-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">0</span>]-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">1</span>]-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">2</span>])%Mod;</span><br><span class="line">        ans=(ans+<span class="built_in">iC</span>(n<span class="number">-1</span>,i)*x%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans+Mod)%Mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>概率与期望</tag>
        <tag>背包</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P9379</title>
    <url>/2023/12/02/P9379/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9379">P9379 [THUPC 2023
决赛] 老虎机</a></p>
<span id="more"></span>
<p>比较难写的分步期望DP。</p>
<p>一个想法是对于每个字符串，求出我们必须要知道哪些位置才能确定是当前的字符串。</p>
<p>对于每一位，我们在操作过后有三种情况：已知是 <span
class="math inline">\(0\)</span>，已知是 <span
class="math inline">\(1\)</span>，未知（用 <span
class="math inline">\(2\)</span>
表示）。可以用一个三进制数表示当前状态。</p>
<p>对于某一个状态，如果其中有 <span class="math inline">\(2\)</span> 且
<span class="math inline">\(2\)</span> 换成 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span>
都不会出现两种不同字符串，那这个状态就是合法的。</p>
<p>因为先换哪个 <span class="math inline">\(2\)</span>
不影响对合法的判断，可以使用 lowbit 递推，每次找到最低位的 ，对将 <span
class="math inline">\(2\)</span> 换成 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 分类讨论，计算贡献。</p>
<p>对于一个字符串来说，只要到达了属于它的某个状态，就能够确定他。</p>
<p>每一位 知道或不知道 的状态可以用二进制数表示（以下所有 状态
都指这个状态）。</p>
<p>问题转化成到达这个状态的期望时间，发现操作之后再操作肯定还是合法的，于是容斥一步，考虑计算维持不合法的期望时间。</p>
<p>分别在每个不合法状态停留的期望时间 乘上 到达这个状态的概率
的和，就是在这个不合法状态停留的期望时间。</p>
<p>具体的，设 <span class="math inline">\(t\)</span> 为停留在状态 <span
class="math inline">\(S\)</span> 的期望时间，如果有 <span
class="math inline">\(P=\prod_{i\not\in S}(1-p_i)\)</span>，那么显然有
<span
class="math inline">\(t=\sum_{x=0}^{\infty}P^x=\frac{1}{1-P}\)</span>，而到达这个状态的概率和可以通过
DP 得出：设 <span class="math inline">\(F[s][i]\)</span> 为考虑前 <span
class="math inline">\(i\)</span> 位，到达状态 <span
class="math inline">\(s\)</span> 的概率，DP出来之后对 val 乘上 <span
class="math inline">\(t\)</span> 做贡献即可。</p>
<p>时间复杂度 <span class="math inline">\(O(3^l)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>,<span class="built_in">pwN</span>(<span class="number">14348912</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y,x&gt;=mod&amp;&amp;(x-=mod);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>,b=mod<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="built_in">mul</span>(a,a))&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="built_in">mul</span>(res,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pw3[<span class="number">20</span>],p[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> lowb[pwN],id[pwN],rev[pwN];</span><br><span class="line"><span class="type">int</span> val[N],F[N][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> L,n;cin&gt;&gt;L&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">        p[i]=<span class="built_in">mul</span>(<span class="built_in">inv</span>(<span class="number">10000</span>),p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line">    val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> update=[&amp;]()&#123;</span><br><span class="line">            <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)<span class="built_in">add</span>(F[s][i+<span class="number">1</span>],F[s][i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">add</span>(F[s|(<span class="number">1</span>&lt;&lt;i)][i+<span class="number">1</span>],<span class="built_in">mul</span>(F[s][i],p[i]));</span><br><span class="line">                    <span class="built_in">add</span>(F[s][i+<span class="number">1</span>],<span class="built_in">mul</span>(F[s][i],<span class="number">1</span>+mod-p[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">        <span class="keyword">if</span>(s)val[s]=F[s][L];</span><br><span class="line">        <span class="keyword">else</span> val[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> P=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((~s)&gt;&gt;i&amp;<span class="number">1</span>)P=<span class="built_in">mul</span>(P,<span class="number">1</span>+mod-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">inv</span>(mod+<span class="number">1</span>-P);</span><br><span class="line">        <span class="built_in">memset</span>(F[s],<span class="number">0</span>,<span class="built_in">sizeof</span>(F[s]));</span><br><span class="line">        F[s][<span class="number">0</span>]=<span class="built_in">mul</span>(val[s],t);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">        val[s]=<span class="built_in">mul</span>(val[s],t);</span><br><span class="line">        <span class="built_in">add</span>(sum,val[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="built_in">sizeof</span>(id));</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        string s;cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">range</span>(s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:s)x=x*<span class="number">3</span>+p-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        id[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> U=(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,pw3[L]<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~lowb[s])&#123;</span><br><span class="line">            <span class="type">int</span> u=id[s-pw3[lowb[s]]],v=id[s-pw3[lowb[s]]*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">-1</span>||v==<span class="number">-1</span>||(u!=<span class="number">0</span>)&amp;&amp;(v!=<span class="number">0</span>))id[s]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> id[s]=u|v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id[s]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ans[id[s]],val[rev[s]^U]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cout&lt;&lt;(sum+mod-ans[i])%mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pw3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,<span class="number">15</span>)pw3[i]=pw3[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,pw3[<span class="number">15</span>])&#123;</span><br><span class="line">        lowb[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,x=i;j&lt;<span class="number">15</span>;j++,x/=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>)&#123;lowb[i]=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(~lowb[i])&#123;</span><br><span class="line">            rev[i]=rev[i-pw3[lowb[i]]*<span class="number">2</span>]|<span class="number">1</span>&lt;&lt;lowb[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;cin&gt;&gt;T;<span class="keyword">while</span>(T--)<span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P9487</title>
    <url>/2023/12/07/P9487/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9487">P9487 「LAOI-1」
小熊游景点</a></p>
<span id="more"></span>
<p>先形式化表示贡献。</p>
<p>对于花费，<span class="math inline">\(u\to v\)</span>
路径上的边一定经过，<span class="math inline">\(p\)</span> 到 <span
class="math inline">\(q\)</span> 路径上的边一定经过两次，所以是 <span
class="math inline">\(disE(u,v)+2\times disE(p,q)\)</span>。</p>
<p>对于分数，<span class="math inline">\(u\to v\)</span>
路径上的点一定经过，<span class="math inline">\(p\)</span> 到 <span
class="math inline">\(q\)</span> 路径上的点一定经过两次，所以是 <span
class="math inline">\(disV(u,v)+2\times disV(p,q)-w[p]\)</span>。</p>
<p>每次询问一条路径，如果可以处理出 <span
class="math inline">\(F(p)\)</span>：对 <span
class="math inline">\(p\)</span> 来说最优的 <span
class="math inline">\(q\)</span>
对应的花费和分数的话，就可以直接查询路径最值解决。</p>
<p>需要用换根 <code>DP</code>。</p>
<p>显然对于 <span class="math inline">\(q\)</span> 在 <span
class="math inline">\(p\)</span> 子树内还是子树外，需要分讨。</p>
<p>设 <span class="math inline">\(f[u][0/1]\)</span> 为：对于 <span
class="math inline">\(u\)</span> 来说，选点的最优值/次优值，<span
class="math inline">\(v\)</span> 为 <span
class="math inline">\(u\)</span> 的儿子。</p>
<p>下面所有 <span class="math inline">\(\min\)</span> 都被重载过，<span
class="math inline">\(f\)</span> 数组是
<code>pair</code>，记录两个关键字。</p>
<p>先做 <span class="math inline">\(q\)</span> 在 <span
class="math inline">\(p\)</span> 子树内的部分。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[u][0]=\min(\{f[v][0]+disE(u,v)\}\cup \{0\})\\
&amp;f[u][1]=\mathrm{secmin}(\{f[v][0]+disE(u,v)\}\cup \{0\})
\end{aligned}
\]</span></p>
<p>当然，还要再跑一次 <span class="math inline">\(q\)</span> 在子树外的
<code>DP</code>。</p>
<p>这里记录次小值的作用就出来了：如果在子树外 <span
class="math inline">\(u\)</span> 自己就是自己的最优点，那么 <span
class="math inline">\(u\)</span>
向上走，是找不到子树外的最小值在哪里的（因为已经走过去了），所以记个次小值做转移，同时要记录转移点
<span class="math inline">\(k[u]\)</span> 判断是否需要次小值。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[u][0]=\min(\{f[u][0],f[fa][k[fa]=u]+disE(u,fa)\})\\
&amp;f[u][1]=\mathrm{secmin}(\{f[u][0],f[u][1],f[fa][k[fa]=u]+disE(u,fa)\})
\end{aligned}
\]</span></p>
<p>问题转化为：静态求树上链最值，树上倍增即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>这题应该是可以用线段树写的：线段树维护当前点到每个点的距离，<code>dfs</code>的过程中对线段树做转移即可，但是莫名其妙的没调出来，难过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y, p;</span><br><span class="line">    S <span class="keyword">operator</span>+(S b) &#123; <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(S b) <span class="type">const</span> &#123; <span class="keyword">return</span> x == b.x ? y &gt; b.y : x &lt; b.x; &#125;</span><br><span class="line">&#125; Q, F[<span class="number">300050</span>][<span class="number">2</span>], C[<span class="number">300050</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, w, t;</span><br><span class="line">&#125; e[<span class="number">1000050</span>];</span><br><span class="line"><span class="type">int</span> n, m, c, a[<span class="number">300050</span>], d[<span class="number">300050</span>], h[<span class="number">300050</span>], f[<span class="number">300050</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s[<span class="number">300050</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++c] = &#123;v, w, h[u]&#125;;</span><br><span class="line">    h[u] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u], v; i; i = e[i].t)</span><br><span class="line">        <span class="keyword">if</span> (!d[v = e[i].v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">            f[v][<span class="number">0</span>] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; f[v][i - <span class="number">1</span>]; ++i)</span><br><span class="line">                f[v][i] = f[f[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            s[v] = s[u] + a[v];</span><br><span class="line">            <span class="built_in">D1</span>(v);</span><br><span class="line"></span><br><span class="line">            S X = F[v][<span class="number">0</span>] + S&#123;e[i].w, a[v] &lt;&lt; <span class="number">1</span>&#125;;</span><br><span class="line">            X.p = v;</span><br><span class="line">            <span class="keyword">if</span> (X &lt; F[u][<span class="number">0</span>])</span><br><span class="line">                F[u][<span class="number">1</span>] = F[u][<span class="number">0</span>], F[u][<span class="number">0</span>] = X;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; F[u][<span class="number">1</span>])</span><br><span class="line">                F[u][<span class="number">1</span>] = X;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u], v; i; i = e[i].t)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].v) != k)</span><br><span class="line">        &#123;</span><br><span class="line">            S X = F[u][F[u][<span class="number">0</span>].p == v] + S&#123;e[i].w, a[u] &lt;&lt; <span class="number">1</span>&#125;;</span><br><span class="line">            X.p = u;</span><br><span class="line">            <span class="keyword">if</span> (X &lt; F[v][<span class="number">0</span>])</span><br><span class="line">                F[v][<span class="number">1</span>] = F[v][<span class="number">0</span>], F[v][<span class="number">0</span>] = X;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; F[v][<span class="number">1</span>])</span><br><span class="line">                F[v][<span class="number">1</span>] = X;</span><br><span class="line">            <span class="built_in">D2</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D3</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u], v; i; i = e[i].t)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].v) != k)</span><br><span class="line">        &#123;</span><br><span class="line">            C[v][<span class="number">0</span>] = F[v][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; f[v][i - <span class="number">1</span>]; ++i)</span><br><span class="line">                C[v][i] = <span class="built_in">min</span>(C[v][i - <span class="number">1</span>], C[f[v][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">D3</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(a[F[i][<span class="number">0</span>].p = F[i][<span class="number">1</span>].p = i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u, v, w), <span class="built_in">A</span>(u, v, w), <span class="built_in">A</span>(v, u, w);</span><br><span class="line">    s[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">D1</span>(d[<span class="number">1</span>] = <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">D2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        F[i][<span class="number">0</span>].y += a[i], F[i][<span class="number">1</span>].y += a[i];</span><br><span class="line">    C[<span class="number">1</span>][<span class="number">0</span>] = F[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">D3</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y, u, v, l, k; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Q = &#123;INF, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        x = u, y = v;</span><br><span class="line">        <span class="keyword">if</span> (d[x] &lt; d[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">while</span> (d[x] &gt; d[y])</span><br><span class="line">            Q = <span class="built_in">min</span>(Q, C[x][k = __lg(d[x] - d[y])]), x = f[x][k];</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            Q = <span class="built_in">min</span>(Q, C[l = x][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = __lg(d[x]); k &gt;= <span class="number">0</span>; --k)</span><br><span class="line">                <span class="keyword">if</span> (f[x][k] != f[y][k])</span><br><span class="line">                    Q = <span class="built_in">min</span>(&#123;Q, C[x][k], C[y][k]&#125;), x = f[x][k], y = f[y][k];</span><br><span class="line">            Q = <span class="built_in">min</span>(&#123;Q, C[x][<span class="number">0</span>], C[y][<span class="number">0</span>], C[l = f[x][<span class="number">0</span>]][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(Q.y + s[u] + s[v] - s[l] - s[f[l][<span class="number">0</span>]], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P9655</title>
    <url>/2023/12/09/P9655/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9655">P9655 『GROI-R2』
Beside You</a></p>
<span id="more"></span>
<p>好题。做法很多。复杂度递增。</p>
<h2 id="长剖优化dp">长剖优化DP</h2>
<p>考虑<code>DP</code>。</p>
<p><span class="math inline">\(5\times 10^5\)</span>
的数据范围可能不敢写二维DP，<code>DP</code>需要大胆。</p>
<p>定义 <code>)</code> 权值为 <span
class="math inline">\(-1\)</span>，<code>(</code> 权值 <span
class="math inline">\(1\)</span>。</p>
<p>广为人知的是，一个括号序列合法的条件为：全体权值和为 <span
class="math inline">\(0\)</span>，且任何一个前缀权值和 <span
class="math inline">\(\ge 0\)</span>。</p>
<p>设 <span class="math inline">\(f[u][i]\)</span> 为 <span
class="math inline">\(u\)</span> 为点集的根，所有叶子 <span
class="math inline">\(v\)</span> 满足 <span
class="math inline">\((u,v)\)</span> 路径上权值之和等于 <span
class="math inline">\(i\)</span> 的最大点集大小。注意这里 <span
class="math inline">\(i\ge
0\)</span>，叶子，根，点集是题面的特殊定义。</p>
<p>只要我们一直在 <span class="math inline">\(i\ge 0\)</span>
的状态之间转移，就可以不考虑 任何一个前缀权值和 <span
class="math inline">\(\ge 0\)</span> 的限制。</p>
<p>转移较为直接。</p>
<p>若 <span class="math inline">\(a_u=1\)</span>，<span
class="math inline">\(f[u][i+1]\leftarrow
f[u][i+1]+f[v][i]\)</span>，否则 <span
class="math inline">\(f[u][i-1]\leftarrow
f[u][i-1]+f[v][i]\)</span>，最后将满足 <span
class="math inline">\(f[u][i]\ge 1\)</span> 的 <span
class="math inline">\(f[u][i]\leftarrow
f[u][i]+1\)</span>，因为只要有这个方案，就会包括 <span
class="math inline">\(u\)</span>。</p>
<p>可以写出朴素<code>DP</code>的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function">T <span class="title">cmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x=x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    len[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:eg[x])<span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,x);</span><br><span class="line">        <span class="built_in">cmax</span>(len[x],len[v]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[x]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len[v];i++)</span><br><span class="line">                f[x][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len[v];i++)</span><br><span class="line">                f[x][i<span class="number">-1</span>]+=f[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len[x];i++)<span class="keyword">if</span>(f[x][i])f[x][i]++;</span><br><span class="line">    <span class="keyword">if</span>(a[x]==<span class="number">1</span>&amp;&amp;!f[x][<span class="number">1</span>])f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cmax</span>(ans,f[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常好懂，现在要考虑优化。</p>
<p>第一维是父亲-儿子做转移，第二维是整体位移，可以尝试长剖优化。</p>
<p>首先是后缀非零位置加 <span class="math inline">\(1\)</span>，可以再记
<span class="math inline">\(g[u][i]\)</span> 表示要将 <span
class="math inline">\(f[u][\ge i]\)</span> 的非零位置加上 <span
class="math inline">\(g[u][i]\)</span>，需要用到 <span
class="math inline">\(f\)</span>
真实值的时候去更新，是用多少更新多少的“懒标记”思想。也就是在短儿子向父亲合并的时候把短儿子更新，再把自己的
<span class="math inline">\(f\)</span> 也更新了，最后将短儿子合并。</p>
<p><span class="math inline">\(a_u=1\)</span> 的时候让长儿子的 <span
class="math inline">\(f\)</span> 整体右移，<span
class="math inline">\(a_u=-1\)</span> 的时候整体左移，为了防止向 <span
class="math inline">\(0\)</span> 越界要开二倍空间。</p>
<p>关于长剖优化<code>DP</code>的原理和时间复杂度：<a
href="https://h01yshhmy.github.io/2023/12/09/CF1009F/">CF1009F |
h01yshhmy</a></p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>，很牛。</p>
<h2 id="找连通块跑dp">找连通块跑DP</h2>
<p>这是std。</p>
<p>考虑点 <span class="math inline">\(u,v\)</span>，<span
class="math inline">\(u\)</span> 是 <span
class="math inline">\(v\)</span> 的祖先。</p>
<p>设 <span class="math inline">\(s_u\)</span> 为 <span
class="math inline">\(u\)</span> 到树根的权值和，那么路径 <span
class="math inline">\(u,v\)</span> 为合法括号串 和 <span
class="math inline">\({fa_u}=s_v\)</span> 且 <span
class="math inline">\(\not\exists x\in(u,v)\)</span> 使得 <span
class="math inline">\(s_x&lt;s_{fa_u}\)</span> 是充要的，<span
class="math inline">\((u,v)\)</span> 为路径。</p>
<p>考虑对于 <span class="math inline">\(v\)</span>，找到最近的 <span
class="math inline">\(u\)</span> 满足上述条件且 <span
class="math inline">\(u\)</span> 是左括号，然后将 <span
class="math inline">\(u,v\)</span> 之间在新图上连边。</p>
<p>为什么这样做？</p>
<p>首先，“连接”这一操作具有传递性，<span
class="math inline">\(u,v\)</span> 和 <span
class="math inline">\(v,w\)</span> 在一个连通块，那么 <span
class="math inline">\(u,w\)</span> 也在。</p>
<p>其次，如果在 <span class="math inline">\(u\)</span>
上有更远的满足条件的 <span class="math inline">\(w\)</span>，有 <span
class="math inline">\(s_{fa_w}=s_{fa_u},s_{fa_u}=s_v\)</span>，那么
<span class="math inline">\(s_{fa_w}=s_{fa_u}\)</span>（条件一），又因为
<span class="math inline">\((w,v)\)</span> 合法，<span
class="math inline">\((w,u)\subseteq (w,v)\)</span>，所以 <span
class="math inline">\(\not\exists x\in(w,u)\)</span> 使得 <span
class="math inline">\(s_x&lt;s_{fa_w}\)</span>（条件二），<span
class="math inline">\((w,u)\)</span> 合法的两个条件均被满足，<span
class="math inline">\((w,u)\)</span>
之间一定在一个连通块内，因为连接的传递性，不需要特地在 <span
class="math inline">\((w,v)\)</span> 上连边了。</p>
<p>我们只关心集合内的点，所以连边可以用并查集<code>merge</code>代替。</p>
<p>现在的问题转化为：对每个点集求在原树上能覆盖这个点集的最小连通块，答案是这些连通块大小的最大值。</p>
<p>有经典结论（见 <a
href="https://h01yshhmy.github.io/2023/12/06/P4606/">P4606 |
h01yshhmy</a>），连通块大小在此题中就是 <span
class="math inline">\(\frac{\sum_{cyc}dis(a_i,a_{i+1})}{2}+1\)</span>，也可以看作建虚树。</p>
<p>但是并没有结束，注意到最开始找 <span class="math inline">\(u\)</span>
的时候需要 <span class="math inline">\(u\)</span>
满足是左括号，如果括号串形如<code>(...)(...)</code>，就会出现串被断开的情况。</p>
<p>再做一次树形<code>DP</code>即可，设 <span
class="math inline">\(ans_v\)</span> 为 <span
class="math inline">\(v\)</span> 节点为根时当前的答案，那么对于父亲节点
<span class="math inline">\(u\)</span>，如果 <span
class="math inline">\(u\)</span> 为右括号，<span
class="math inline">\(v\)</span> 为左括号，且 <span
class="math inline">\(u,v\)</span>
分别为合法点集的叶子和根时（就是在判断上述情况），设 <span
class="math inline">\(r\)</span> 为 含 <span
class="math inline">\(u\)</span> 的合法点集内的根，则做 <span
class="math inline">\(ans_r\leftarrow ans_r+ans_v\)</span> 的转移。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>，瓶颈是求<code>LCA</code>。</p>
<h2 id="树上启发式合并">树上启发式合并</h2>
<p>这玩意主打一个无脑。</p>
<p>事实上<code>dsu on tree</code>
在此题就是长剖的劣化版本，都是优化了第一种写法内的朴素 <span
class="math inline">\(O(n^2)\)</span> DP。</p>
<p><span class="math inline">\(f\)</span> 与第一种写法定义相同。</p>
<p><span class="math display">\[
f[u][i]=1+\sum_{v\in son(u)}f[v][j-a_u]
\]</span></p>
<p>转移式子只和儿子有关，考虑启发式合并。</p>
<p>维护 <span class="math inline">\(n\)</span> 个 <code>map</code>
记录非零位置，记两个懒标记 <span
class="math inline">\(add,sum\)</span>，<span
class="math inline">\(add\)</span> 表示存在 <span
class="math inline">\(f[u][i]\)</span> 实质上是 <span
class="math inline">\(f[u][i-add]\)</span>，<span
class="math inline">\(sum\)</span> 表示取出来的结果还要加上 <span
class="math inline">\(sum\)</span>。</p>
<p>具体内容见代码，时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>。</p>
<p>代码部分。</p>
<p>后两种都是题解区的。</p>
<p>做法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],len[N],lson[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> buff[N],*f[N],*fp=buff;</span><br><span class="line"><span class="type">int</span> bufg[N],*g[N],*gp=bufg;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">predfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    len[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">predfs</span>(v,u);</span><br><span class="line">        len[u]=<span class="built_in">max</span>(len[u],len[v]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len[v]&gt;len[lson[u]])&#123;</span><br><span class="line">            lson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    p=<span class="built_in">min</span>(p,len[x]);</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,top[x],p)&#123;</span><br><span class="line">        s+=g[x][i];</span><br><span class="line">        <span class="keyword">if</span>(f[x][i])f[x][i]+=s;</span><br><span class="line">        g[x][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p+<span class="number">1</span>&lt;=len[x])g[x][p+<span class="number">1</span>]+=s;</span><br><span class="line">    top[x]=p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lson[u])&#123;</span><br><span class="line">        f[lson[u]]=f[u]+a[u];</span><br><span class="line">        g[lson[u]]=g[u]+a[u];</span><br><span class="line">        <span class="built_in">dfs</span>(lson[u],u);</span><br><span class="line">        <span class="keyword">if</span>(a[u]==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">work</span>(lson[u],<span class="number">1</span>);</span><br><span class="line">            f[lson[u]][<span class="number">0</span>]=g[lson[u]][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||v==lson[u])<span class="keyword">continue</span>;</span><br><span class="line">        f[v]=fp+len[v]+<span class="number">1</span>,fp+=<span class="number">2</span>*len[v]+<span class="number">2</span>;</span><br><span class="line">        g[v]=gp+len[v]+<span class="number">1</span>,gp+=<span class="number">2</span>*len[v]+<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(a[u]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">work</span>(v,len[v]);</span><br><span class="line">            <span class="built_in">work</span>(u,len[v]+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">rep</span>(i,<span class="number">0</span>,len[v])&#123;</span><br><span class="line">                f[u][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">work</span>(v,len[v]);</span><br><span class="line">            <span class="built_in">work</span>(u,len[v]);</span><br><span class="line">            <span class="built_in">re</span>(i,len[v])&#123;</span><br><span class="line">                f[u][i<span class="number">-1</span>]+=f[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[u]==<span class="number">1</span>&amp;&amp;!f[u][<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">work</span>(u,<span class="number">1</span>);</span><br><span class="line">        f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[u][<span class="number">0</span>])f[u][<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(len[u]&gt;<span class="number">1</span>)g[u][<span class="number">2</span>]++,top[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> g[u][<span class="number">0</span>]++,top[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[u][<span class="number">0</span>])ans=<span class="built_in">max</span>(ans,f[u][<span class="number">0</span>]+g[u][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;(str+<span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        a[i]=(str[i]==<span class="string">&#x27;(&#x27;</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">predfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>]=fp+len[<span class="number">1</span>]+<span class="number">1</span>,fp+=<span class="number">2</span>*len[<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">    g[<span class="number">1</span>]=gp+len[<span class="number">1</span>]+<span class="number">1</span>,gp+=<span class="number">2</span>*len[<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFLL 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(k,l,r) for(int k=l;k&lt;=r;++k)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(k,r,l) for(int k=r;k&gt;=l;--k)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cl(f,x) memset(f,x,sizeof(f))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> head[N],len;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;; node edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++len]=&#123;v,head[u]&#125;; head[u]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[N],d[N],last[N*<span class="number">2</span>],fa[N],f[N][<span class="number">20</span>],g[N][<span class="number">20</span>],n;</span><br><span class="line"><span class="type">int</span> dfn[N],p;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[c[u]+n])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> res=INF,v=last[c[u]+n]; u=f[u][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">19</span>,<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[u][i]]&gt;=d[v])</span><br><span class="line">            res=<span class="built_in">min</span>(res,g[u][i]),u=f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res&gt;=c[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span> </span>&#123;</span><br><span class="line">    c[u]=c[from]+(s[u]==<span class="string">&#x27;(&#x27;</span>? <span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">    f[u][<span class="number">0</span>]=from; g[u][<span class="number">0</span>]=c[u];</span><br><span class="line">    d[u]=d[from]+<span class="number">1</span>;</span><br><span class="line">    dfn[u]=++p;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">19</span>) &#123;</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        g[u][i]=<span class="built_in">min</span>(g[u][i<span class="number">-1</span>],g[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(u))</span><br><span class="line">        fa[u]=last[c[u]+n],used[fa[u]]=used[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(s[u]==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        tmp=last[c[from]+n];</span><br><span class="line">        last[c[from]+n]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=from)</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[u]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        last[c[from]+n]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=from) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(used[u]&amp;&amp;used[v]&amp;&amp;s[u]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s[v]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ans[fa[u]]+=ans[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u]&gt;d[v])</span><br><span class="line">        <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">19</span>,<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[v][i]]&gt;=d[u])</span><br><span class="line">            v=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==v)</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">19</span>,<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[u][i]!=f[v][i])</span><br><span class="line">            u=f[u][i],v=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u,<span class="type">const</span> <span class="type">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[u]&lt;dfn[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[N],tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>; tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:vec) &#123;</span><br><span class="line">        t[++tot]=x;</span><br><span class="line">        <span class="keyword">if</span>(last)</span><br><span class="line">            t[++tot]=<span class="built_in">lca</span>(last,x);</span><br><span class="line">        last=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(t+<span class="number">1</span>,t+tot+<span class="number">1</span>,cmp);</span><br><span class="line">    tot=<span class="built_in">unique</span>(t+<span class="number">1</span>,t+tot+<span class="number">1</span>)-t<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,tot) &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">lca</span>(t[i<span class="number">-1</span>],t[i]);</span><br><span class="line">        ans+=d[t[i]]-d[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v);</span><br><span class="line">        <span class="built_in">add_edge</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        vec[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>()!=<span class="number">1</span>)</span><br><span class="line">            ans[i]=<span class="built_in">solve</span>(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        res=<span class="built_in">max</span>(res,ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做法三：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> ch[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[MAXN];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ds</span>&#123;</span><br><span class="line">    <span class="type">int</span> add,sum;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(-add))<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 代码中不存在的位置为0</span></span><br><span class="line">        <span class="keyword">return</span> mp[-add]+sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_ne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!mp.<span class="built_in">empty</span>()&amp;&amp;mp.<span class="built_in">begin</span>()-&gt;first+add&lt;<span class="number">0</span>)mp.<span class="built_in">erase</span>(mp.<span class="built_in">begin</span>());<span class="comment">//清除负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ds&amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&lt;x.mp.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">swap</span>(add,x.add);</span><br><span class="line">            <span class="built_in">swap</span>(sum,x.sum);</span><br><span class="line">            <span class="built_in">swap</span>(mp,x.mp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:x.mp)&#123;</span><br><span class="line">            <span class="type">int</span> t=it.first+x.add-add;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(t))mp[t]=-sum;<span class="comment">//注意在这个map里不存在这个下标时，要减去sum(因为最后拿结果的时候要加上)</span></span><br><span class="line">            mp[t]+=it.second+x.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        x.mp.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(-add))mp[-add]=-sum;<span class="comment">//把0处设为0，因为转移时用懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="comment">//调试用的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp)&#123;</span><br><span class="line">            cout&lt;&lt;it.first+add&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;it.second+sum&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ds f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            f[u].<span class="built_in">merge</span>(f[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u].<span class="built_in">create</span>();</span><br><span class="line">    f[u].add+=(ch[u]==<span class="string">&#x27;)&#x27;</span>)?<span class="number">1</span>:<span class="number">-1</span>;<span class="comment">//要先改add再清负数</span></span><br><span class="line">    f[u].<span class="built_in">clear_ne</span>();</span><br><span class="line">    ++f[u].sum;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,f[u].<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>树形DP</tag>
        <tag>树上启发式合并</tag>
        <tag>启发式合并</tag>
        <tag>长链剖分</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P9726</title>
    <url>/2023/12/12/P9726/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9726">P9726 [EC Final
2022] Magic</a></p>
<span id="more"></span>
<h2 id="转化">转化</h2>
<p>对于区间赋值，每个位置只有最后一次覆盖对答案有影响。</p>
<p>设 <span class="math inline">\(w_i=[a_{i-1}\ne
a_i]\)</span>，注意到每次覆盖的值不一样，也就是边界上一定不等于，操作
<span class="math inline">\([l,r)\)</span> 相当于 <span
class="math inline">\(w_l\leftarrow 1,w_r\leftarrow 1\)</span> 和 <span
class="math inline">\(w_i\leftarrow 0,i\in[l+1,r-1]\)</span>。</p>
<p>关系到区间之间的覆盖问题，对两个区间 <span
class="math inline">\([l_1,r_1),[l_2,r_2)\)</span> 做分讨。</p>
<ul>
<li><span class="math inline">\([l_1,r_1)\subseteq
[l_2,r_2)\)</span>，显然先覆盖 <span class="math inline">\(2\)</span>
再覆盖 <span class="math inline">\(1\)</span> 更优。</li>
<li><span class="math inline">\([l_1,r_1)\cap
[l_2,r_2)=\varnothing\)</span>，没有需要讨论的。</li>
<li><span class="math inline">\([l_1,r_1)\cap
[l_2,r_2)\ne\varnothing\)</span>，不失一般性的，设 <span
class="math inline">\(l_1&lt;l_2,r_1&lt;r_2\)</span>，显然最后只会剩下
<span class="math inline">\(l_1,r_1,r_2\)</span> 或者 <span
class="math inline">\(l_1,l_2,r_2\)</span>——<span
class="math inline">\(r_1,l_2\)</span>
总有一个要被挡住，也就是他们之间只能选一个。</li>
</ul>
<p>保证 <span class="math inline">\(l_i,r_i\)</span>
互不相等，将第三种情况中，所有 <span
class="math inline">\(r_1,l_2\)</span>
之间连边，问题转化成二分图最大独立集，众所周知，二分图最大独立集等于点数减去二分图最大匹配。</p>
<h2 id="暴力空间优化">暴力空间优化</h2>
<blockquote>
<p>相信 dinic 与奇迹。</p>
</blockquote>
<p>空间 <code>16MB</code>，直接建图会爆。</p>
<p>发现容量只会有 <span class="math inline">\(0/1\)</span>
两种取值，写<code>bitset</code>邻接矩阵即可。</p>
<p>然后直接暴力<code>dinic</code>，二分图容量均为 <span
class="math inline">\(1\)</span>，理论复杂度约为 <span
class="math inline">\(O(n^{\frac{5}{2}})\)</span>，<span
class="math inline">\(3s\)</span> 时限最大点 <span
class="math inline">\(2s\)</span> 左右。</p>
<p>匈牙利其实也能过，<code>ISAP</code>会稍快。</p>
<h2 id="主席树优化建图">主席树优化建图</h2>
<p>主体思想上和线段树优化建图差不多。</p>
<p>继续延续前文对问题的转化，考虑将 <span
class="math inline">\(l,r\)</span> 分别作为横纵坐标，前文限制为 <span
class="math inline">\(l_1&lt;l_y&lt;r_1&lt;r_2\)</span>，也就是说，当点
<span class="math inline">\(1\)</span> 纵坐标 <span
class="math inline">\(r_1\in (l_2,r_2)\)</span>，横坐标 <span
class="math inline">\(l_1&lt;l_2\)</span> 时，<span
class="math inline">\(r_1,l_2\)</span> 才会连一条边，也就是说点 <span
class="math inline">\(1\)</span> 连边的“目标区域”是一个矩形。</p>
<p>为什么要这样转化呢？因为通过线段树优化建图的经验，我们发现向一段连续的区间连边是可维护的，而如果转化为类似“一个点要向包含它的所有矩形连边”就不好维护了。</p>
<p>考虑一个扫描线，维护从左到右的一条线，每次对线上区间加边，然后将点
<span class="math inline">\(i:(l_i,r_i)\)</span> 挂到区间上的 <span
class="math inline">\(r_i\)</span>
位置，但是线段树优化建图要求所有点已经被挂在序列上，即必须离线下来，考虑用其它数据结构转化成在线加点。</p>
<p>升了一维，想到主席树。</p>
<p>加入一个新点 <span class="math inline">\((l_i,r_i)\)</span>
的时候，在 <span class="math inline">\(i-1\)</span> 的版本基础上新建版本
<span class="math inline">\(i\)</span>，除了新增的 <span
class="math inline">\(r_i\)</span> 部分之外，其余均继承 <span
class="math inline">\(i-1\)</span> 版本，这样就能实现加点。</p>
<p>注意新增的这条树链要记得和从前一个版本中继承的儿子连边。</p>
<p>考虑边权，将树内的边容量均赋为流量上界（<span
class="math inline">\(n\)</span> 或者正无穷）即可。</p>
<p>时间复杂度较为吓人：<span class="math inline">\(O(n^3\log
n)\)</span>。</p>
<p>bitset暴力：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,st,ed,a[N],l[N],r[N],pos[N];</span><br><span class="line">bitset&lt;N&gt; G[N];</span><br><span class="line"><span class="type">int</span> lev[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,ed)lev[i]=<span class="number">0</span>;</span><br><span class="line">    lev[st]=<span class="number">1</span>;q.<span class="built_in">push</span>(st);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=G[u]._Find_first();v&lt;=ed;v=<span class="built_in">max</span>(v+<span class="number">1</span>,(<span class="type">int</span>)G[u]._Find_next(v)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(G[u][v]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!lev[v])&#123;</span><br><span class="line">                lev[v]=lev[u]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lev[ed];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==ed)<span class="keyword">return</span> fl;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=G[u]._Find_first();v&lt;=ed&amp;&amp;fl;v=<span class="built_in">max</span>(v+<span class="number">1</span>,(<span class="type">int</span>)G[u]._Find_next(v)))&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][v]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(lev[v]!=lev[u]+<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(fl,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(!k)lev[v]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> G[u][v]=<span class="number">0</span>,G[v][u]=<span class="number">1</span>;</span><br><span class="line">        res+=k,fl-=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    st=n*<span class="number">2</span>+<span class="number">1</span>,ed=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i],r[i]);</span><br><span class="line">        pos[l[i]]=<span class="number">0</span>,pos[r[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i]&lt;l[j]&amp;&amp;l[j]&lt;r[i]&amp;&amp;r[i]&lt;r[j])&#123;</span><br><span class="line">                G[l[j]][r[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)<span class="keyword">if</span>(pos[i]==<span class="number">0</span>)G[st][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)<span class="keyword">if</span>(pos[i]==<span class="number">1</span>)G[i][ed]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=n*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans-=<span class="built_in">dfs</span>(st,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化建图：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> forup(i,s,e) for(int i=(s);i&lt;=(e);i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fordown(i,s,e) for(int i=(s);i&gt;=(e);i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c=gc)) <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=gc;&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> gc</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> n,cntn;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flow</span>&#123;<span class="comment">//dinic 板子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> v,rst,nxt;</span><br><span class="line">    &#125;e[N*<span class="number">80</span>];<span class="comment">//注意边数开大一点</span></span><br><span class="line">    <span class="type">int</span> head[N*<span class="number">20</span>],cur[N*<span class="number">20</span>],cnte=<span class="number">1</span>,dpt[N*<span class="number">20</span>],s,t;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adde</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        e[++cnte]=edge&#123;v,w,head[u]&#125;;head[u]=cnte;</span><br><span class="line">        e[++cnte]=edge&#123;u,<span class="number">0</span>,head[v]&#125;;head[v]=cnte;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        forup(i,<span class="number">1</span>,cntn)&#123;</span><br><span class="line">            cur[i]=head[i];</span><br><span class="line">            dpt[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);dpt[s]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">                <span class="type">int</span> v=e[i].v;</span><br><span class="line">                <span class="keyword">if</span>(dpt[v]!=<span class="number">-1</span>||!e[i].rst) <span class="keyword">continue</span>;</span><br><span class="line">                dpt[v]=dpt[u]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpt[t]!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur[x];i;i=e[i].nxt)&#123;</span><br><span class="line">            cur[x]=i;<span class="type">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dpt[v]!=dpt[x]+<span class="number">1</span>||!e[i].rst) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> gt=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>((<span class="type">int</span>)e[i].rst,flow-res));</span><br><span class="line">            <span class="keyword">if</span>(gt)&#123;</span><br><span class="line">                res+=gt;</span><br><span class="line">                e[i].rst-=gt;</span><br><span class="line">                e[i^<span class="number">1</span>].rst+=gt;</span><br><span class="line">                <span class="keyword">if</span>(res==flow) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">            ans+=<span class="built_in">dfs</span>(s,n);<span class="comment">//这里正无穷取的 n，因为流量不会超过 n。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lson l,mid,ls[id]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rson mid+1,r,rs[id]</span></span><br><span class="line">    <span class="type">int</span> num[N*<span class="number">15</span>],cntt,ls[N*<span class="number">15</span>],rs[N*<span class="number">15</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> P,<span class="type">int</span> X,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id,<span class="type">int</span> o)</span></span>&#123;<span class="comment">//新加入一个点</span></span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            num[id]=X;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[id]=++cntn;</span><br><span class="line">        <span class="keyword">if</span>(P&lt;=mid)&#123;</span><br><span class="line">            ls[id]=++cntt;rs[id]=rs[o];</span><br><span class="line">            <span class="built_in">Update</span>(P,X,lson,ls[o]);</span><br><span class="line">            mf.<span class="built_in">adde</span>(num[id],num[ls[id]],n);</span><br><span class="line">            <span class="keyword">if</span>(rs[id]) mf.<span class="built_in">adde</span>(num[id],num[rs[id]],n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rs[id]=++cntt;ls[id]=ls[o];</span><br><span class="line">            <span class="built_in">Update</span>(P,X,rson,rs[o]);</span><br><span class="line">            mf.<span class="built_in">adde</span>(num[id],num[rs[id]],n);</span><br><span class="line">            <span class="keyword">if</span>(ls[id]) mf.<span class="built_in">adde</span>(num[id],num[ls[id]],n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> X,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;<span class="comment">//向区间连边</span></span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">            mf.<span class="built_in">adde</span>(X,num[id],n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid&amp;&amp;ls[id]) <span class="built_in">Link</span>(L,R,X,lson);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt; R&amp;&amp;rs[id]) <span class="built_in">Link</span>(L,R,X,rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mt;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    forup(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i].l=<span class="built_in">read</span>();s[i].r=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>,[&amp;](Node a,Node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    mf.s=n*<span class="number">2</span>+<span class="number">1</span>;mf.t=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    mt.cntt=n;cntn=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    forup(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        mf.<span class="built_in">adde</span>(mf.s,i,<span class="number">1</span>);mf.<span class="built_in">adde</span>(i+n,mf.t,<span class="number">1</span>);</span><br><span class="line">        mt.<span class="built_in">Link</span>(s[i].l,s[i].r,i,<span class="number">1</span>,n*<span class="number">2</span>,i<span class="number">-1</span>);</span><br><span class="line">        mt.<span class="built_in">Update</span>(s[i].r,i+n,<span class="number">1</span>,n*<span class="number">2</span>,i,i<span class="number">-1</span>);</span><br><span class="line">             <span class="comment">//这里点的序号是随便取的，左部点是 [1,n]，右部点是 [n+1,2n]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*<span class="number">2</span>-mf.<span class="built_in">dinic</span>());<span class="comment">//注意最大独立集是最小点覆盖的补集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>主席树</tag>
        <tag>网络流</tag>
        <tag>二分图</tag>
        <tag>bitset</tag>
        <tag>优化建图</tag>
        <tag>图的匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>P9984</title>
    <url>/2023/12/24/P9984/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9984">P9984 [USACO23DEC] A
Graph Problem P</a></p>
<span id="more"></span>
<p>对于图上有边权优先级的合并结构做询问，考虑重构树。</p>
<p>重构树上有很好的性质：合并的时候，初始从某个叶子向上跳一步，访问兄弟子树，贡献答案；然后回到父节点，再向上跳，访问父亲的兄弟子树，贡献答案；然后跳到祖父……</p>
<p>但是先不要急，发现进入兄弟子树的时候不一定从子树的根开始——这和原图结构有关，对于重构树来说，在两个连通块中任意两点之间连边都是等效的，但合并顺序会按照原图中边的端点做。</p>
<p>所以重构树假了？并没有。需要数据结构维护。（是谁赛时以为假了呢/oh/oh/oh）</p>
<p>考虑合并两个连通块的过程，对于当前要做合并的边，从这两个连通块中伸出来边权最小的边就是当前这条边，也就是说，以这两个连通块内部的任何一个点为起点，块内合并完之后下一条合并的边就是这条边，再接下来合并的边就是另一个连通块内以这条边的另一个端点为起点需要合并的边。</p>
<p>注意到连通块在重构树上是子树，我们可以用线段树维护答案序列（叶子序列）。</p>
<p>每次取出从这条边两个节点出发这个子树内部的答案，然后把这些操作和当前这条边的贡献挂到另一棵子树上，怎么合并呢？</p>
<p>记录一个 <span class="math inline">\((mul,add)\)</span>
表示目前答案为 <span
class="math inline">\(x\)</span>，经过这条边之后变成 <span
class="math inline">\(mul\times x+add\)</span>。容易发现 <span
class="math inline">\(x\)</span> 顺次经过 <span
class="math inline">\((mul_1,add_1),(mul_2,add_2)\)</span> 后变为 <span
class="math inline">\(mul_2(mul_1\times
x+add_1)+add_2\)</span>，所以可以将这两个标记合并为 <span
class="math inline">\((mul_1\times mul_2,add_1\times
mul_2+add_2)\)</span>，线段树直接维护这个标记就好了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, id;</span><br><span class="line">&#125; oe[N], e[N];</span><br><span class="line"><span class="type">int</span> n, m, fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tL[N], tR[N], dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        tL[u]=tR[u]=++dfncnt;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tL[u]=inf,tR[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        tL[u]=<span class="built_in">min</span>(tL[u],tL[v]);</span><br><span class="line">        tR[u]=<span class="built_in">max</span>(tR[u],tR[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    <span class="type">int</span> mul, add;</span><br><span class="line">    Seg <span class="keyword">operator</span>*(Seg y) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="number">1ll</span> * mul * y.mul % mod, (<span class="number">1ll</span> * add * y.mul % mod + y.add) % mod &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[rt] = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, Seg v)</span> </span>&#123;</span><br><span class="line">    t[rt] = t[rt] * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), t[rt]);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), t[rt]);</span><br><span class="line">    t[rt] = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ml, <span class="type">int</span> mr, Seg v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= l &amp;&amp; r &lt;= mr) &#123;</span><br><span class="line">        <span class="built_in">update</span>(rt, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">ls</span>(rt), l, mid, ml, mr, v);</span><br><span class="line">    <span class="keyword">if</span> (mr &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, ml, mr, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Seg <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, mid, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="built_in">re</span>(i, m) &#123;</span><br><span class="line">        <span class="built_in">read</span>(oe[i].u, oe[i].v);</span><br><span class="line">        oe[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n * <span class="number">2</span>) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, m) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">findfa</span>(oe[i].u), v = <span class="built_in">findfa</span>(oe[i].v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        e[++tid] = oe[i];</span><br><span class="line">        fa[u] = fa[v] = tid + n;</span><br><span class="line">        G[tid + n].<span class="built_in">pb</span>(u), G[tid + n].<span class="built_in">pb</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">re</span>(i, n * <span class="number">2</span>) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">findfa</span>(e[i].u), v = <span class="built_in">findfa</span>(e[i].v);</span><br><span class="line">        Seg wu = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, tL[e[i].u]), wv = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, tL[e[i].v]);</span><br><span class="line">        fa[u] = fa[v] = i + n;</span><br><span class="line">        wu = (Seg)&#123; <span class="number">10</span>, e[i].id &#125; * wu, wv = (Seg)&#123; <span class="number">10</span>, e[i].id &#125; * wv;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, tL[u], tR[u], wv);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, tL[v], tR[v], wu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        Seg ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, tL[i]);</span><br><span class="line">        <span class="built_in">write</span>(ans.add, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>SP2939</title>
    <url>/2023/12/06/SP2939/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/SP2939">QTREE5 - Query on a
tree V</a></p>
<span id="more"></span>
<p>先想一些暴力。</p>
<ol type="1">
<li>操作一直接改，操作二枚举白点。</li>
<li>每个点用 <code>set</code> 维护子树内白点集合，修改时改 <span
class="math inline">\(u\)</span>
到根的链上的<code>set</code>，查询也是枚举 <span
class="math inline">\(u\)</span> 到根的链上的点，取最小值算答案取
<code>min</code>。</li>
</ol>
<p>第一种暴力看起来没啥前途，着重考虑第二种。</p>
<p>显然，复杂度的问题在于：和深度相关。</p>
<p>发现此题的修改查询都和树结构没啥关系，在点分树上做即可，反正从 <span
class="math inline">\(u\)</span> 到根上的 <code>set</code>
一定可以覆盖整棵树，注意，白点 <span class="math inline">\(x\)</span>
在点分树上祖先 <span class="math inline">\(u\)</span> 上的
<code>set</code> 关键字是 <span
class="math inline">\(dis(u,x)\)</span>，而且要记录 <span
class="math inline">\(x\)</span>，询问 <span
class="math inline">\(v\)</span> 的时候，答案是通过 <span
class="math inline">\(dis(x,v)\)</span> 更新的。</p>
<p>为了优化常数，<code>set</code>换了<code>priority_queue</code>写法的可删堆。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123; priority_queue&lt;pii&gt; q1,q2;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;q1.<span class="built_in">push</span>(&#123;-x,y&#125;);&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;q2.<span class="built_in">push</span>(&#123;-x,y&#125;);&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q1.<span class="built_in">size</span>()-q2.<span class="built_in">size</span>();&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(;q2.<span class="built_in">size</span>()&amp;&amp;q1.<span class="built_in">top</span>()==q2.<span class="built_in">top</span>();q1.<span class="built_in">pop</span>(),q2.<span class="built_in">pop</span>());q1.<span class="built_in">pop</span>();&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(;q2.<span class="built_in">size</span>()&amp;&amp;q1.<span class="built_in">top</span>()==q2.<span class="built_in">top</span>();q1.<span class="built_in">pop</span>(),q2.<span class="built_in">pop</span>());<span class="keyword">return</span> q1.<span class="built_in">top</span>().second;&#125;</span><br><span class="line">&#125;h[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arr[N];</span><br><span class="line">arr siz,vis,dep,fa,hson,top,mxp,F,a;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>,dep[u]=dep[f]+<span class="number">1</span>,fa[u]=f;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp;</span><br><span class="line">    <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[u]+dep[v]-dep[<span class="built_in">lca</span>(u,v)]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot,rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>,mxp[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v]&amp;&amp;v!=f)&#123;</span><br><span class="line">            <span class="built_in">getRot</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            mxp[u]=<span class="built_in">max</span>(mxp[u],siz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[u]=<span class="built_in">max</span>(mxp[u],tot-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mxp[u]&lt;mxp[rt])rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    F[u]=f,vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        rt=<span class="number">0</span>,tot=siz[v];</span><br><span class="line">        <span class="built_in">getRot</span>(v,u);</span><br><span class="line">        <span class="built_in">solve</span>(rt,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=x;u;u=F[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[u].<span class="built_in">size</span>())&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,<span class="built_in">dis</span>(x,h[u].<span class="built_in">top</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    tot=mxp[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="built_in">getRot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>,x=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op,x);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">            a[x]^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[x])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">for</span>(u=x;u;u=F[u])&#123;</span><br><span class="line">                    h[u].<span class="built_in">push</span>(<span class="built_in">dis</span>(u,x),x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">for</span>(u=x;u;u=F[u])&#123;</span><br><span class="line">                    h[u].<span class="built_in">erase</span>(<span class="built_in">dis</span>(u,x),x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">write</span>(<span class="built_in">query</span>(x),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的一些用途</title>
    <url>/2023/12/15/String%20Algo/</url>
    <content><![CDATA[<p>瞎写，未完待续。</p>
<span id="more"></span>
<h2 id="hash">Hash</h2>
<ol type="1">
<li>快速判断已经做完预处理的两串中子串是否相等。</li>
<li>使用 和哈希或者异或哈希 + 随机化
的技巧，快速判断两个结构之间是否相等。</li>
<li>对一些判定性的DS题，用数据结构维护哈希。</li>
</ol>
<h2 id="kmp">KMP</h2>
<ol type="1">
<li>匹配模式串在文本串中位置。</li>
<li>利用<code>next</code>指针的 <span
class="math inline">\(\textrm{border}\)</span> 各种性质解题。</li>
<li>找最小循环节，找周期（ <span
class="math inline">\(\textrm{period}\)</span> ），<a
href="https://h01yshhmy.github.io/2023/12/02/CF825F/">CF825F</a>。</li>
</ol>
<h2 id="z函数">Z函数</h2>
<ol type="1">
<li><span class="math inline">\(O(n)-O(1)\)</span> 求出 <span
class="math inline">\(S\)</span> 中每个后缀与 <span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(\textrm{LCP}\)</span>。</li>
</ol>
<h2 id="manacher">Manacher</h2>
<ol type="1">
<li>线性求最长回文子串。</li>
</ol>
<h2 id="acam">ACAM</h2>
<p>处理子串问题，找fail。</p>
<ol type="1">
<li>多模式串匹配，查询 <span class="math inline">\(s\)</span>
是否能被字典中的串拼出，或者最多能拼到哪个前缀，<a
href="https://h01yshhmy.github.io/2023/12/14/P2292/">P2292</a>。</li>
<li>询问多个串中，<span class="math inline">\(s_i\)</span> 在 <span
class="math inline">\(s_j\)</span> 中的出现次数，<a
href="https://h01yshhmy.github.io/2023/12/14/P2414/">P2414</a>。</li>
<li>在一些字符串的DP中，和 匹配 相关的状态难以转移，需要AC自动机，形如
<span class="math inline">\(F(*,i)\to
F(*&#39;,\delta(i,c))\)</span>。</li>
</ol>
<h2 id="sa">SA</h2>
<ol type="1">
<li>求任意后缀 <span class="math inline">\(\textrm{LCP}\)</span>。</li>
<li>把所有串拼起来，求任意两串 <span
class="math inline">\(\textrm{LCP}\)</span>。</li>
<li>字典序第 <span class="math inline">\(k\)</span> 大子串。</li>
</ol>
<ul>
<li>求 <span class="math inline">\(\textrm{LCP}\)</span>
经常结合笛卡尔树或并查集。</li>
<li>以 <span class="math inline">\(sa\)</span> 为轴，<span
class="math inline">\(f_p(x)=\textrm{LCP}(p,x)\)</span> 是单峰函数，且
<span class="math inline">\(x=p\)</span> 取到峰值。</li>
</ul>
<h2 id="sam">SAM</h2>
<ol type="1">
<li>在单个 <span class="math inline">\(T\)</span> 中搜索多个 <span
class="math inline">\(P\)</span> 是否出现过，单次复杂度 <span
class="math inline">\(O(|P|)\)</span>，其实还顺便可以找到 <span
class="math inline">\(P\)</span> 在 <span
class="math inline">\(T\)</span> 中出现的最长前缀长度。</li>
<li>计算单个 <span class="math inline">\(T\)</span>
中有多少个不同的子串，或计算不同的子串的总长度。</li>
<li>字典序第 <span class="math inline">\(k\)</span>
大子串，单次查询复杂度 <span class="math inline">\(O(|ans|\times
|\Sigma|)\)</span>。</li>
<li>找 <span class="math inline">\(T\)</span> 最长循环移位。</li>
<li>在单个 <span class="math inline">\(T\)</span> 中多次询问，<span
class="math inline">\(P\)</span> 的出现次数，复杂度 <span
class="math inline">\(O(|T|)-O(|P|)\)</span>。</li>
<li>在单个 <span class="math inline">\(T\)</span> 中多次询问，<span
class="math inline">\(P\)</span>
的<strong>第一次</strong>出现位置，复杂度 <span
class="math inline">\(O(|T|)-O(|P|)\)</span>。</li>
<li>在单个 <span class="math inline">\(T\)</span> 中多次询问，<span
class="math inline">\(P\)</span> 的<strong>所有</strong>出现位置，复杂度
<span class="math inline">\(O(|T|)-O(|P|+|ans|)\)</span>。</li>
<li>给定一个字符串 <span class="math inline">\(S\)</span>
和一个特定的字符集，找一个长度最短的没有在 <span
class="math inline">\(S\)</span> 中出现过的字符串。</li>
<li>给定两个字符串 <span class="math inline">\(S\)</span> 和 <span
class="math inline">\(T\)</span>，求出最长公共子串，公共子串定义为在
<span class="math inline">\(S\)</span> 和 <span
class="math inline">\(T\)</span> 中都作为子串出现过的字符串 <span
class="math inline">\(X\)</span>，时间复杂度 <span
class="math inline">\(O(|T|+|S|)\)</span>。</li>
<li>给定 <span class="math inline">\(k\)</span> 个字符串 <span
class="math inline">\(S_i\)</span>。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串
<span class="math inline">\(X\)</span>，时间复杂度 <span
class="math inline">\(O(\sum_{i=1}^k{|S_i|})\)</span>。</li>
</ol>
<ul>
<li><span class="math inline">\(parent\)</span>
树上子树内叶子节点个数等于 <span class="math inline">\(endpos\)</span>
集合大小。</li>
<li><span class="math inline">\(endpos\)</span>
集合大小显然就是出现次数。</li>
<li><span class="math inline">\(parent\)</span>
树上一条深度单增的链上的全部 <span
class="math inline">\([len(i),len(link(i))+1]\)</span>
首尾相接，连成连续段 <span
class="math inline">\([len(top),len(bottom)]\)</span>。</li>
</ul>
<h2 id="后缀树">后缀树</h2>
<ol type="1">
<li>用更容易理解的方式求 <span
class="math inline">\(\textrm{LCP}\)</span> 或 <span
class="math inline">\(\textrm{LCS}\)</span>。</li>
<li>很多时候可以代替 SAM，SA。</li>
<li>在一些问题中更容易建立虚树等结构。</li>
</ol>
<ul>
<li>树上 <span class="math inline">\(\textrm{LCA}\)</span> 就是 <span
class="math inline">\(\textrm{LCP}\)</span> 对应状态。</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>U169078</title>
    <url>/2023/12/02/U169078/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/U169078">U169078
[NOI2021SDPT3Test4]图论题</a></p>
<span id="more"></span>
<p>不是主题库的题，感觉题挺好就写了题解。</p>
<p>题面：有向带权图，可以花费 <span
class="math inline">\((x-y)^2\)</span> 的代价从 <span
class="math inline">\(x\)</span> 走到 <span
class="math inline">\(y\)</span>，这个技能只能用一次，求 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的最短路，<span
class="math inline">\(|V|\le 2\times 10^5,|E|\le 4\times
10^5\)</span>。</p>
<p>看到题面，当然是最短路。</p>
<p>首先可以对题目做转化：我们走的是形如 <span class="math inline">\(s\to
u\to v\to t\)</span> 的一条路径，<span class="math inline">\(u\to
v\)</span> 是只使用技能的。</p>
<p>发现只需要求两个点之间的最短路，有一种对称性。</p>
<p>可以在正图和反图上跑两遍最短路，获得每个点到 <span
class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 的最短路 <span
class="math inline">\(d_1[u],d_2[u]\)</span>。</p>
<p>现在上面那条路径的长度也可以表示了：<span
class="math inline">\(d_1[u]+d_2[v]+(u-v)^2\)</span>，我们现在有了一个
<span class="math inline">\(O(n^2)\)</span> 枚举 <span
class="math inline">\(u,v\)</span> 的做法。</p>
<p>肯定需要一个更好的复杂度。</p>
<p>考虑枚举 <span
class="math inline">\(u\)</span>，思考<strong>当什么情况下，我们应该去选
<span class="math inline">\(v_1\)</span> 而不是 <span
class="math inline">\(v_2\)</span></strong>，这其实是斜率优化的一个常用想法。</p>
<p>当然，肯定是走 <span class="math inline">\(v_1\)</span> 更短。</p>
<p>也就是：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;d_1[u]+d_2[v_1]+(u-v_1)^2&lt;d_1[u]+d_2[v_2]+(u-v_2)^2\\
&amp;d_2[v_1]+u^2-2uv_1+v_1^2&lt;d_2[v_2]+u^2-2uv_2+v_2^2\\
&amp;d_2[v_1]+v_1^2-2uv_1&lt;d_2[v_2]+v_2^2-2uv_2\\
&amp;(d_2[v_1]+v_1^2)-(d_2[v_2]+v_2^2)&lt;2uv_1-2uv_2
\end{aligned}
\]</span></p>
<p>发现这个式子的形式很好。</p>
<p>可以设 <span class="math inline">\(y[u]=d_2[u]+u^2\)</span></p>
<p>那么进一步就有：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;y[v_1]-y[v_2]&lt;2uv_1-2uv_2\\
&amp;y[v_1]-y[v_2]&lt;2u(v_1-v_2)\\
&amp;\frac{y[v_1]-y[v_2]}{v_1-v_2}&lt;2u
\end{aligned}
\]</span></p>
<p>如果把 <span class="math inline">\((v,y[v])\)</span>
看成点，就会获得一个更好的形式：斜率。</p>
<p>我们一直在对式子做等价的变换，显然 <span
class="math inline">\(\frac{y[v_1]-y[v_2]}{v_1-v_2}&lt;2u\)</span> 和
<span class="math inline">\(v_1\)</span> 比 <span
class="math inline">\(v_2\)</span> 更优 是互为充要条件的。</p>
<p>题目被简化，只需要用单调队列先求一遍下凸壳，在这个斜率单调递增的凸壳上用指针维护当前最后一个斜率
<span class="math inline">\(&lt;2u\)</span> 的位置即可，这个位置对于
<span class="math inline">\(u\)</span> 来说就是最优的。</p>
<p>为什么只需要下凸壳上的点？我们可以将所有的斜率看做一种偏序关系，简单分讨可得，不在下凸壳上的点，一定不如在他两边凸壳上的点优。</p>
<p>为什么找最后一个斜率的位置是对的？因为在满足斜率的时候向后走，是在做一个“递推”（<span
class="math inline">\(v_2\)</span> 比 <span
class="math inline">\(v_1\)</span> 优，<span
class="math inline">\(v_3\)</span> 比 <span
class="math inline">\(v_2\)</span> 优，<span
class="math inline">\(v_4\)</span> 比 <span
class="math inline">\(v_3\)</span>
优……），每一个都比上一个更优，直到不满足的时候，这条递推关系就断了，答案会变得更劣。</p>
<p>现在来考虑：如果从到枚举，会发现是递增的，那么匹配到的最优位置也显然是单调不降的，所以在处理好的下凸壳上扫一遍就做完了。</p>
<p>注：如果枚举的“目标斜率” <span class="math inline">\(2u\)</span> 没有
与凸壳单调性相同 的性质，就需要写 wqs 二分。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">4e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line">vector&lt;pii&gt; G[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; pli;</span><br><span class="line">priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt; pq;</span><br><span class="line">ll dis[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)dis[o][i]=INF;</span><br><span class="line">    dis[o][u]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">mkp</span>(<span class="number">0</span>,u));</span><br><span class="line">    pli tp;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        tp=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tp.fi!=dis[o][tp.se])<span class="keyword">continue</span>;</span><br><span class="line">        u=tp.se;</span><br><span class="line">        <span class="built_in">each</span>(v,G[o][u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[o][v.fi]&gt;dis[o][u]+v.se)&#123;</span><br><span class="line">                dis[o][v.fi]=dis[o][u]+v.se;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">mkp</span>(dis[o][v.fi],v.fi));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">ll y[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s,t);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        G[<span class="number">0</span>][u].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(v,w));</span><br><span class="line">        G[<span class="number">1</span>][v].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(u,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">0</span>,s);</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">1</span>,t);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        y[i]=dis[<span class="number">1</span>][i]+<span class="number">1ll</span>*i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)q.<span class="built_in">pb</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> siz=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">3</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;(__int128)(y[q.<span class="built_in">back</span>()]-y[q[q.<span class="built_in">size</span>()<span class="number">-2</span>]])*(i-q.<span class="built_in">back</span>())&gt;=(__int128)(y[i]-y[q.<span class="built_in">back</span>()])*(q.<span class="built_in">back</span>()-q[q.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;q.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;(y[q[now+<span class="number">1</span>]]-y[q[now]])&lt;<span class="number">2ll</span>*i*(q[now+<span class="number">1</span>]-q[now]))&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][q[now]]+<span class="number">1ll</span>*(i-q[now])*(i-q[now]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P4081</title>
    <url>/2024/01/17/P4081/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4081">P4081 [USACO17DEC]
Standing Out from the Herd P</a></p>
<span id="more"></span>
<p>两种做法。</p>
<h2 id="sa">SA</h2>
<p>将 <span class="math inline">\(n\)</span>
个串用互不相同的分隔符拼起来，求出 <span
class="math inline">\(sa,height\)</span>。</p>
<p>但是先别急，有弱化版 <a
href="https://www.luogu.com.cn/problem/P2408">P2408
不同子串个数</a>，回忆一下弱化版。</p>
<p>答案是： <span class="math display">\[
\frac{(|S|+1)|S|}{2}-\sum_{i=2}^{|S|}height_i
\]</span> <span class="math inline">\(sa\)</span> 数组有性质：对于某个
<span class="math inline">\(sa_p\)</span>，<span
class="math inline">\(\textrm{LCP}(sa_p,sa_i)\)</span> 和 <span
class="math inline">\(|p-i|\)</span> 相关，<span
class="math inline">\(p\)</span> 到 <span
class="math inline">\(i\)</span> 的距离越长，<span
class="math inline">\(\textrm{LCP}\)</span> 越短。<span
class="math inline">\(f_p(i)=\textrm{LCP}(sa_i,sa_p)\)</span>
是一个“单峰”的函数（所谓离散单峰）。</p>
<p>考虑 <span class="math inline">\(sa_p\)</span> 的贡献。容易发现，如果
<span class="math inline">\(\textrm{LCP}(sa_p,sa_i)=T\)</span>，那么
<span class="math inline">\(T\)</span>
的任何一个前缀（包括自身）都出现在了 <span
class="math inline">\(sa_p,sa_i\)</span> 内，共有 <span
class="math inline">\(|T|\)</span> 个。这些需要减去，对于 <span
class="math inline">\(p\)</span> 来说，显然要减去最大 <span
class="math inline">\(|T|\)</span>。又因为 <span
class="math inline">\(f_p(i)\)</span> 是单峰的，所以减去相邻的 <span
class="math inline">\(\textrm{LCP}\)</span>（也就是 <span
class="math inline">\(height\)</span>）即可。</p>
<p>注意这里只需要考虑 <span
class="math inline">\(\textrm{LCP}(sa_{i-1},sa_i)\)</span> 而不需要
<span
class="math inline">\(\textrm{LCP}(sa_i,sa_{i+1})\)</span>。是一种“出现一个删一个”的思想，只关注当前
<span class="math inline">\(sa_i\)</span> 和 <span
class="math inline">\(sa_{i-1}\)</span>
产生了多少新非法串，后面的交给后人的智慧。</p>
<p>回到此题，增加了“只属于当前串”的限制。</p>
<p>其实和“本质不同”的限制本质相同。为什么这么说呢？</p>
<p>考虑将 <span class="math inline">\(sa\)</span>
数组按照属于哪个字符串划分成若干个段。设当前段是 <span
class="math inline">\([L,R]\)</span>。</p>
<p>容易发现，对子串的约束仍然是：设 <span
class="math inline">\(T=\max\limits_{j\not\in[L,R]}f_i(sa_j)\)</span>，<span
class="math inline">\(T\)</span> 的任意一个前缀都不能做贡献，共有 $|T| $
个。</p>
<p>所以只需要分别求出 <span
class="math inline">\(g(i)=\max\limits_{j&gt; R_i}f_i(sa_j)\)</span> 和
<span
class="math inline">\(q(i)=\max\limits_{j&lt;L_i}f_i(sa_j)\)</span>，又是根据单峰性质，最大值一定是
<span class="math inline">\(j=L-1\)</span> 或 <span
class="math inline">\(j=R+1\)</span> 取到的，所以 <span
class="math inline">\(g(i)=f_i(sa_{R+1}),q(i)=f_i(sa_{L-1})\)</span>，这样直接扫一遍就可以预处理了，<span
class="math inline">\(f_i\)</span> 可以通过 <span
class="math inline">\(height\)</span> 性质，用 ST 表求区间 <span
class="math inline">\(\min\)</span>。</p>
<p>将 <span class="math inline">\(g,q\)</span> 拼成 <span
class="math inline">\(|T|\)</span> 后再和原有的 <span
class="math inline">\(height_i\)</span> 约束取 <span
class="math inline">\(\max\)</span> 即可。</p>
<p>初始答案为 <span
class="math inline">\(\frac{(|s_i|+1)|s_i|}{2}\)</span>，每次给对应字符串的答案减去
<span
class="math inline">\(\max\{g(i),q(i),height_i\}\)</span>。有个小优化，还是根据单峰的性质，发现
<span class="math inline">\(q(i)\le height_i\)</span>，所以就不用求
<span class="math inline">\(q(i)\)</span> 了。</p>
<p>设 <span class="math inline">\(L=\sum |s_i|\)</span>，时间复杂度
<span class="math inline">\(O(L\log L)\)</span>。</p>
<h2 id="广义sam">广义SAM</h2>
<p>思路更加无脑暴力，复杂度反而更优？唉，SAM。</p>
<p>多模式串，本质不同串个数，且只在一个模式串中出现过。</p>
<p>对 <span class="math inline">\(n\)</span>
个串建立广义后缀自动机。</p>
<p>对于一个串 <span class="math inline">\(s_i\)</span>，从对应点 <span
class="math inline">\(u\)</span> 开始在 <span
class="math inline">\(parent\)</span> 树上跳，然后打标记 <span
class="math inline">\(i\)</span>。</p>
<p>因为如果 <span class="math inline">\(u\)</span> 有标记，<span
class="math inline">\(link(u)\)</span> 也要有标记，只要是 <span
class="math inline">\(s_i\)</span> 子串就行。</p>
<p>打标记的时候记录是否有多个标记，如果有多个标记，贡献答案的时候就跳过。</p>
<p>最后给对应字符串贡献上 <span
class="math inline">\(len(i)-len(link(i))\)</span>，这是弱化版中的式子，不再解释，基础内容。</p>
<p>设 <span class="math inline">\(L=\sum |s_i|\)</span>，时间复杂度
<span class="math inline">\(O(L)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>SA：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> cnt,n,len[N],id[N];</span><br><span class="line"><span class="type">char</span> in[N];</span><br><span class="line"><span class="type">int</span> s[N],sa[N],sa2[N],bin[N],rk[N],rk2[N],h[N],m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,m)bin[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)bin[rk[i]]++;</span><br><span class="line">    <span class="built_in">re</span>(i,m)bin[i]+=bin[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">pe</span>(i,n)sa[bin[rk[sa2[i]]]--]=sa2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m=<span class="number">100100</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)rk[i]=s[i],sa2[i]=i;</span><br><span class="line">    <span class="built_in">Bsort</span>();</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        cur=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,n-k+<span class="number">1</span>,n)sa2[++cur]=i;</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="keyword">if</span>(sa[i]&gt;k)sa2[++cur]=sa[i]-k;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        rk2[sa[<span class="number">1</span>]]=cur=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rk[sa[i]]!=rk[sa[i<span class="number">-1</span>]]||rk[sa[i]+k]!=rk[sa[i<span class="number">-1</span>]+k])&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rk2[sa[i]]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(rk,rk2);</span><br><span class="line">        <span class="keyword">if</span>(cur==n)<span class="keyword">break</span>;</span><br><span class="line">        m=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            k=h[<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])k++;</span><br><span class="line">        h[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">21</span>],lg[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r||r&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[l][p],f[r-(<span class="number">1</span>&lt;&lt;p)+<span class="number">1</span>][p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g[N],q[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;cnt;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        cin&gt;&gt;(in+<span class="number">1</span>);</span><br><span class="line">        len[i]=<span class="built_in">strlen</span>(in+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">re</span>(j,len[i])&#123;</span><br><span class="line">            s[++n]=in[j]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">            id[n]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++n]=<span class="number">26</span>+i;</span><br><span class="line">    &#125;</span><br><span class="line">    s[n--]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getSA</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(j,<span class="number">20</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n-(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(id[sa[i]]!=id[sa[i+<span class="number">1</span>]])&#123;</span><br><span class="line">            pos=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">ask</span>(i+<span class="number">1</span>,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        ans[i]=<span class="number">1ll</span>*len[i]*(len[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        ans[id[sa[i]]]-=<span class="built_in">max</span>(g[i],h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广义 SAM：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">string s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tot, last, fa[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], t[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> num[N &lt;&lt; <span class="number">1</span>], ans[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">SAM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tot = last = <span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> cur = ++tot;</span><br><span class="line">        len[cur] = len[last] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = last;</span><br><span class="line">        last = cur;</span><br><span class="line">        <span class="keyword">while</span> (~p &amp;&amp; !t[p][c])</span><br><span class="line">            t[p][c] = cur, p = fa[p];</span><br><span class="line">        <span class="keyword">if</span> (!~p)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[cur] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = t[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[p] + <span class="number">1</span> == len[x])</span><br><span class="line">            fa[cur] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            len[++tot] = len[p] + <span class="number">1</span>;</span><br><span class="line">            fa[tot] = fa[x];</span><br><span class="line">            <span class="built_in">memcpy</span>(t[tot], t[x], <span class="built_in">sizeof</span>(t[x]));</span><br><span class="line">            <span class="keyword">while</span> (~p &amp;&amp; t[p][c] == x)</span><br><span class="line">                t[p][c] = tot, p = fa[p];</span><br><span class="line">            fa[x] = fa[cur] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (~x &amp;&amp; ~num[x] &amp;&amp; num[x] != id)</span><br><span class="line">        &#123;</span><br><span class="line">            num[x] = num[x] ? <span class="number">-1</span> : id;</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++, p = <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : s[i])</span><br><span class="line">                <span class="built_in">update</span>(p = t[p][c - <span class="string">&#x27;a&#x27;</span>], i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; i++)</span><br><span class="line">            <span class="keyword">if</span> (~num[i] &amp;&amp; ~fa[i])</span><br><span class="line">                ans[num[i]] += len[i] - len[fa[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        sam.last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s[i])</span><br><span class="line">            sam.<span class="built_in">insert</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>SA</tag>
        <tag>SAM</tag>
        <tag>ST表</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ6198</title>
    <url>/2024/01/17/LOJ6198/</url>
    <content><![CDATA[<p><a href="https://loj.ac/p/6198">#6198. 谢特</a></p>
<span id="more"></span>
<p>幽默三合一。</p>
<p>题目求： <span class="math display">\[
\max_{i,j}\,\textrm{LCP}(i,j)+(w_i\oplus w_j)
\]</span> 求出后缀数组，在 <span class="math inline">\(sa\)</span>
这个轴上做。</p>
<p>形式变为： <span class="math display">\[
\max_{i,j}\,\min_{k=i+1}^{j}height_k+(w_i\oplus w_j)
\]</span> 交换一下，枚举 <span class="math inline">\(k\)</span>。 <span
class="math display">\[
\begin{aligned}
&amp;\max_{k}height_k+(w_i\oplus w_j)\\
&amp;\textsf{满足 }i&lt;k,j\ge k,\min_{p=i+1}^jheight_p=height_k
\end{aligned}
\]</span> 文字描述一下就是：<span class="math inline">\(i,j\)</span>
要在 <span class="math inline">\(k\)</span>
的支配区间内，且必须一边一个。</p>
<p>显然可以笛卡尔树启发式合并，过程中枚举短边，<span
class="math inline">\(height_k\)</span>
已经确定，在长边中查询最大异或和。</p>
<p>也就是说，给定 <span
class="math inline">\(w_i\)</span>，要支持在区间内查询最大的 <span
class="math inline">\(w_i\oplus w_j,j\in[L,R]\)</span>。</p>
<p>动态开点 <span class="math inline">\(\textrm{01-Trie}\)</span>
解决，其实应该用可持久化 <span
class="math inline">\(\textrm{01-Trie}\)</span> 来做，但是没调出来。</p>
<p>做启发式合并的时候顺便暴力 <code>insert</code>
一下父亲，相当于做信息的合并。</p>
<p>不需要显式建树，按照 <span class="math inline">\(height\)</span>
从大到小排序就相当于从底向上了。</p>
<p>当然分治写也可以。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> l[N], r[N], w[N];</span><br><span class="line"><span class="type">int</span> ch[N * <span class="number">120</span>][<span class="number">2</span>], rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">height</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ht, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> height &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ht &gt; p.ht;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="type">int</span> n, tot, ans;</span><br><span class="line"><span class="type">int</span> sa[N], sa2[N], bin[N], rk[N], rk2[N], ht[N], m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) bin[rk[i]]++;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] += bin[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">pe</span>(i, n) sa[bin[rk[sa2[i]]]--] = sa2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">122</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, sa2[i] = i;</span><br><span class="line">    <span class="built_in">Bsort</span>();</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, n - k + <span class="number">1</span>, n) sa2[++cur] = i;</span><br><span class="line">        <span class="built_in">re</span>(i, n) <span class="keyword">if</span> (sa[i] &gt; k) sa2[++cur] = sa[i] - k;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        rk2[sa[<span class="number">1</span>]] = cur = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[sa[i]] != rk[sa[i - <span class="number">1</span>]] || rk[sa[i] + k] != rk[sa[i - <span class="number">1</span>] + k])</span><br><span class="line">            &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rk2[sa[i]] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">        <span class="keyword">if</span> (cur == n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = ht[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            k--;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k])</span><br><span class="line">            k++;</span><br><span class="line">        ht[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> x = (<span class="number">1</span> &lt;&lt; i) &amp; val;</span><br><span class="line">        <span class="keyword">if</span> (!ch[u][x])</span><br><span class="line">            ch[u][x] = ++tot;</span><br><span class="line">        u = ch[u][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> x = (<span class="number">1</span> &lt;&lt; i) &amp; val;</span><br><span class="line">        <span class="keyword">if</span> (ch[u][x ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            u = ch[u][x ^ <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = ch[u][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">getSA</span>();</span><br><span class="line">    <span class="built_in">re</span>(i, n) cin &gt;&gt; w[i];</span><br><span class="line">    tot = n;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = r[i] = rt[i] = i;</span><br><span class="line">        <span class="built_in">insert</span>(rt[i], w[sa[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].ht = ht[i];</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i].id, h = a[i].ht;</span><br><span class="line">        <span class="keyword">if</span> (!x)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> z = x - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> szx = r[x] - x + <span class="number">1</span>, szz = z - l[z] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (szx &lt; szz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, x, r[x]) ans = <span class="built_in">max</span>(<span class="built_in">query</span>(rt[l[z]],w[sa[j]]) + h, ans);</span><br><span class="line">            <span class="built_in">rep</span>(j, x, r[x]) <span class="built_in">insert</span>(rt[z], w[sa[j]]);</span><br><span class="line">            rt[r[x]] = rt[z];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, l[z], z) ans = <span class="built_in">max</span>(<span class="built_in">query</span>(rt[l[x]],w[sa[j]]) + h, ans);</span><br><span class="line">            <span class="built_in">rep</span>(j, l[z], z) <span class="built_in">insert</span>(rt[x], w[sa[j]]);</span><br><span class="line">            rt[l[z]] = rt[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l0 = l[z], r0 = r[x];</span><br><span class="line">        l[r[x]] = l0;</span><br><span class="line">        r[l[z]] = r0;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>笛卡尔树</tag>
        <tag>启发式合并</tag>
        <tag>字符串</tag>
        <tag>SA</tag>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>P4094</title>
    <url>/2024/01/18/P4094/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4094">P4094
[HEOI2016/TJOI2016] 字符串</a></p>
<span id="more"></span>
<p>求： <span class="math display">\[
\max_{[l,r]\subseteq [a,b]}\textrm{LCP}(s[l,r],s[c,d])
\]</span></p>
<h2 id="sa">SA</h2>
<p>首先有一个显然的贪心：<span class="math inline">\(s[l,r]\)</span>
肯定要让 <span class="math inline">\(r=n\)</span>，尽可能多匹配，有：
<span class="math display">\[
\max_{l\in[a,b]}\min\{\textrm{LCP}(s[l:],s[c:]),b-l+1,d-c+1\}
\]</span> 没啥用，取 <span class="math inline">\(\min\)</span>
的部分依然有多项和 <span class="math inline">\(l\)</span>
相关，不好求，抛弃这个式子。</p>
<p>回到最初，利用 <span class="math inline">\(\textrm{LCP}\)</span>
本身就有的性质：单调，或者说可二分性。</p>
<p>二分答案为 <span
class="math inline">\(len\)</span>，现在考虑如何判定是否存在 <span
class="math inline">\((l,r)\)</span>，使得 <span
class="math inline">\(\textrm{LCP}(s[l,r],s[c,d])=len\)</span>。</p>
<p>需要满足如下约束：</p>
<ul>
<li>作为串的开头，显然需要 <span class="math inline">\(a\le l\le
b-len+1\)</span></li>
<li><span class="math inline">\(\textrm{LCP}(s[l:],s[c:])\ge
len\)</span>。</li>
</ul>
<p><span class="math inline">\(r\)</span> 没有造成本质影响。</p>
<p>看到后缀 <span
class="math inline">\(\textrm{LCP}\)</span>，考虑后缀数组。</p>
<p>众所周知，<span
class="math inline">\(f_c(l)=\textrm{LCP}(sa_l,sa_c)\)</span>
是单峰的，且 <span class="math inline">\(l=c\)</span> 取到峰值。</p>
<p>也就是说，满足 <span
class="math inline">\(\textrm{LCP}(s[l:],s[c:])\ge len\)</span> 的 <span
class="math inline">\(l\)</span> 一定在 <span
class="math inline">\(sa\)</span>
这个轴上构成一段连续区间，且因为函数两侧分别单调，可以二分得到这个区间
<span class="math inline">\([L,R]\)</span>。</p>
<p>现在问题变为：判断是否存在 <span
class="math inline">\(i\in[L,R]\)</span> 满足 <span
class="math inline">\(a\le sa_i\le
b-len+1\)</span>，主席树直接做即可。</p>
<p><span class="math inline">\(\textrm{LCP}\)</span> 用 ST
表求，每次询问二分套二分，主席树每次 <code>check</code>
查一次，时间复杂度 <span class="math inline">\(O(q\log^2
n)\)</span>。</p>
<h2 id="sam">SAM</h2>
<p>建立后缀自动机。</p>
<p><span class="math inline">\(\textrm{LCP}\)</span>
满足可二分性，二分答案 <span class="math inline">\(mid\)</span>。</p>
<p>容易得到 <code>check</code>，判断 <span
class="math inline">\(s[c,c+mid-1]\)</span> 是否在 <span
class="math inline">\(s[a,b]\)</span> 中出现过。</p>
<p>假设我们找到了 <span class="math inline">\(s[c,c+mid-1]\)</span>
的状态 <span
class="math inline">\(p\)</span>，显然，只需要查询是否存在一个 <span
class="math inline">\(i\in endpos(p)\)</span>，满足 <span
class="math inline">\(i\in[a+mid-1,b]\)</span>。</p>
<p>在 <span class="math inline">\(parent\)</span> 树上考虑，众所周知：
<span class="math display">\[
endpos(u)=\bigcup_{v\in son(u)}endpos(v)
\]</span> 直接值域线段树合并，相当于桶，查询 <span
class="math inline">\([a+mid-1,b]\)</span> 区间和是否 <span
class="math inline">\(&gt; 0\)</span>。</p>
<p>怎么求 <span class="math inline">\(s[c,c+mid-1]\)</span>
的状态具体是哪个点？</p>
<p>首先，容易找到 <span class="math inline">\(s[:c+mid-1]\)</span>
的状态 <span class="math inline">\(u\)</span>，前缀的状态在建 SAM
过程中可以顺便存下来。</p>
<p>在 <span class="math inline">\(parent\)</span> 树上对 <span
class="math inline">\(u\)</span> 不断上跳。</p>
<p>稍加分析，<span class="math inline">\(p\)</span> 是 <span
class="math inline">\(u\)</span> 的祖先 <span
class="math inline">\(v\)</span> 中，<span
class="math inline">\(len(v)\ge mid\)</span> 且深度最浅的 <span
class="math inline">\(v\)</span>。</p>
<p>容易证明。考虑 <span class="math inline">\(parent\)</span> 树上的一条
<span class="math inline">\(u\)</span> 到根的链，所有链上 <span
class="math inline">\([len(link(i)),len(i)]\)</span>
头尾相接，连成一个连续段（初始是 <span
class="math inline">\([1,len(u)]\)</span>），从根向下，将 <span
class="math inline">\(v\)</span>
向下移动，相当于不断的让连续段的左端点向右移动（去掉了一些前缀），而右端点固定为
<span class="math inline">\(c+mid-1\)</span>，<span
class="math inline">\(len(p)\ge mid\)</span> 就保证了左端点 <span
class="math inline">\(\le c\)</span>，深度最浅就不用说了。</p>
<p>显然这个跳祖先的过程可以倍增。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>SA：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, qn;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> sa[N], sa2[N], bin[N], rk[N], rk2[N], ht[N], m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) bin[rk[i]]++;</span><br><span class="line">    <span class="built_in">re</span>(i, m) bin[i] += bin[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">pe</span>(i, n) sa[bin[rk[sa2[i]]]--] = sa2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">122</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, sa2[i] = i;</span><br><span class="line">    <span class="built_in">Bsort</span>();</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, n - k + <span class="number">1</span>, n) sa2[++cur] = i;</span><br><span class="line">        <span class="built_in">re</span>(i, n) <span class="keyword">if</span> (sa[i] &gt; k) sa2[++cur] = sa[i] - k;</span><br><span class="line">        <span class="built_in">Bsort</span>();</span><br><span class="line">        rk2[sa[<span class="number">1</span>]] = cur = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[sa[i]] != rk[sa[i - <span class="number">1</span>]] || rk[sa[i] + k] != rk[sa[i - <span class="number">1</span>] + k])</span><br><span class="line">            &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rk2[sa[i]] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">        <span class="keyword">if</span> (cur == n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = ht[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            k--;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k])</span><br><span class="line">            k++;</span><br><span class="line">        ht[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">21</span>], lg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initST</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, n) f[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j, <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">re</span>(i, n - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="type">int</span> z = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[l][z], f[r - (<span class="number">1</span> &lt;&lt; z) + <span class="number">1</span>][z]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>], val;</span><br><span class="line">&#125; t[N * <span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> rot[N], ncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> pre, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt = ++ncnt;</span><br><span class="line">    t[rt] = t[pre], t[rt].val++;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid)</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">ls</span>(rt), <span class="built_in">ls</span>(pre), l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt), <span class="built_in">rs</span>(pre), mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> t[v].val - t[u].val;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="built_in">ls</span>(u), <span class="built_in">ls</span>(v), l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="built_in">rs</span>(u), <span class="built_in">rs</span>(v), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = rk[c], L = <span class="number">0</span>, R = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rmq</span>(mid, rk[c]) &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = r;</span><br><span class="line">    l = rk[c], r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rmq</span>(rk[c], mid) &gt;= x)</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R = l;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rot[L - <span class="number">1</span>], rot[R], <span class="number">1</span>, n, a, b - x + <span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; qn;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">initSA</span>();</span><br><span class="line">    <span class="built_in">initST</span>();</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(rot[i], rot[i - <span class="number">1</span>], <span class="number">1</span>, n, sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (qn--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        l = <span class="number">0</span>, r = <span class="built_in">min</span>(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, a, b, c))</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SAM：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">islower</span> <span class="params">(<span class="type">char</span> &amp;ch)</span> </span>&#123; <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdigit</span> <span class="params">(<span class="type">char</span> &amp;ch)</span> </span>&#123; <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">idx</span> <span class="params">(<span class="type">char</span> &amp;ch)</span> </span>&#123; <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span>; &#125; <span class="comment">// idx是每个字符在SAM中对应的编号(如&#x27;a&#x27;对应0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">1048576</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1048576</span>, stdin), p1 == p2) ? EOF : *p1 ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readi</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) ch = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) ans = ans * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reads</span> <span class="params">(<span class="type">char</span> *S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>; <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">islower</span>(ch)) ch = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">islower</span>(ch)) S[++ p] = ch, ch = <span class="built_in">gc</span>();</span><br><span class="line">  S[p + <span class="number">1</span>] = <span class="number">0</span>; <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上全是快读</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> rt[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// SAM中每个节点在线段树上的root</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123; <span class="comment">// 线段树合并</span></span><br><span class="line">  <span class="type">int</span> sum[N * <span class="number">80</span>];</span><br><span class="line">  <span class="type">int</span> lch[N * <span class="number">80</span>], rch[N * <span class="number">80</span>];</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span> <span class="params">(<span class="type">int</span> u)</span> </span>&#123; sum[u] = sum[lch[u]] + sum[rch[u]]; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) u = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; sum[u] += v; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= x) <span class="built_in">update</span>(lch[u], x, l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rch[u], x, mid + <span class="number">1</span>, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u || !v) <span class="keyword">return</span> u | v;</span><br><span class="line">    <span class="type">int</span> w = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; sum[w] = sum[u] + sum[v]; <span class="keyword">return</span> w; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lch[w] = <span class="built_in">merge</span>(lch[u], lch[v], l, mid);</span><br><span class="line">    rch[w] = <span class="built_in">merge</span>(rch[u], rch[v], mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(w); <span class="keyword">return</span> w;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[u];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= ql) ret += <span class="built_in">query</span>(lch[u], ql, qr, l, mid);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; qr) ret += <span class="built_in">query</span>(rch[u], ql, qr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> ed[N]; <span class="comment">// ed[i]代表前缀s[1...i]在SAM中的对应哪个点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line">  <span class="type">int</span> ch[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">  <span class="type">int</span> fa[N &lt;&lt; <span class="number">1</span>][<span class="number">19</span>] <span class="comment">/*倍增*/</span>, len[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; g[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// Parent Tree</span></span><br><span class="line">  <span class="type">int</span> cnt, lst;</span><br><span class="line">  <span class="built_in">SAM</span> () &#123; cnt = lst = <span class="number">1</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(<span class="type">int</span> c)</span> </span>&#123; <span class="comment">// 标准SAM构建</span></span><br><span class="line">    <span class="type">int</span> p = lst, np = ++ cnt; lst = np;</span><br><span class="line">    len[np] = len[p] + <span class="number">1</span>; seg.<span class="built_in">update</span>(rt[np], len[np], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; p &amp;&amp; !ch[p][c]; p = fa[p][<span class="number">0</span>])</span><br><span class="line">      ch[p][c] = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p) fa[np][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> q = ch[p][c];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(len[q] == len[p] + <span class="number">1</span>) fa[np][<span class="number">0</span>] = q;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> nq = ++ cnt;</span><br><span class="line">        <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">        fa[nq][<span class="number">0</span>] = fa[q][<span class="number">0</span>];</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">        fa[np][<span class="number">0</span>] = fa[q][<span class="number">0</span>] = nq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(; p &amp;&amp; ch[p][c] == q; p = fa[p][<span class="number">0</span>])</span><br><span class="line">          ch[p][c] = nq;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">buildSAM</span> <span class="params">(<span class="type">char</span> *S)</span> </span>&#123; <span class="comment">// 建SAM</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; S[i]; ++ i)</span><br><span class="line">      <span class="built_in">insert</span>(<span class="built_in">idx</span>(S[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updEndPos</span> <span class="params">(<span class="type">char</span> *S)</span> </span>&#123; <span class="comment">// ed的含义在上面(这个EndPos不是SAM中的endpos)</span></span><br><span class="line">    <span class="comment">//个人习惯在建完SAM之后再更新ed[i]，因为SAM的结构可能随着字符的增多而改变之前的形态(endpos出现歧义时候的分裂)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>; S[i]; ++ i) &#123;</span><br><span class="line">      p = ch[p][<span class="built_in">idx</span>(S[i])];</span><br><span class="line">      ed[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">buildParentTree</span> <span class="params">()</span> </span>&#123; <span class="comment">// 建Parent Tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++ i)</span><br><span class="line">      g[fa[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfsParentTree</span> <span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">// dfs，预处理倍增和endpos集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">19</span>; ++ i)</span><br><span class="line">      fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> v = g[u][i];</span><br><span class="line">      <span class="built_in">dfsParentTree</span>(v);</span><br><span class="line">      rt[u] = seg.<span class="built_in">merge</span>(rt[u], rt[v], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findNode</span> <span class="params">(<span class="type">int</span> c, <span class="type">int</span> mid)</span> </span>&#123; <span class="comment">// 找符合条件的点p(代表s[c...c+mid-1]的点)</span></span><br><span class="line">    <span class="type">int</span> p = ed[c + mid - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">18</span>; ~i; -- i) </span><br><span class="line">      <span class="keyword">if</span>(fa[p][i] &amp;&amp; len[fa[p][i]] &gt;= mid) <span class="comment">// 只要len[fa[p][i]]大于等于mid就往上跳</span></span><br><span class="line">              p = fa[p][i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> mid)</span> </span>&#123; <span class="comment">// 查询mid是否合法</span></span><br><span class="line">  <span class="type">int</span> p = sam.<span class="built_in">findNode</span>(c, mid);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">bool</span>)(seg.<span class="built_in">query</span>(rt[p], a + mid - <span class="number">1</span>, b, <span class="number">1</span>, n)); <span class="comment">// s[c...c+mid-1]是否在s[a...b]出现过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, d; a = <span class="built_in">readi</span>(); b = <span class="built_in">readi</span>(); c = <span class="built_in">readi</span>(); d = <span class="built_in">readi</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// 向上取整</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(a, b, c, mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">readi</span>(); q = <span class="built_in">readi</span>();</span><br><span class="line">  <span class="built_in">reads</span>(S);</span><br><span class="line">  sam.<span class="built_in">buildSAM</span>(S);</span><br><span class="line">  sam.<span class="built_in">buildParentTree</span>();</span><br><span class="line">  sam.<span class="built_in">dfsParentTree</span>(<span class="number">1</span>);</span><br><span class="line">  sam.<span class="built_in">updEndPos</span>(S);</span><br><span class="line">  <span class="keyword">while</span>(q -- ) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树合并</tag>
        <tag>字符串</tag>
        <tag>二分</tag>
        <tag>SA</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>P4770</title>
    <url>/2024/01/18/P4770/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4770">P4770 [NOI2018]
你的名字</a></p>
<span id="more"></span>
<p>又是带限制的子串计数问题。</p>
<p>不妨先考虑前 <span class="math inline">\(17\)</span>
个点的特殊性质：<span class="math inline">\(l=1,r=|S|\)</span>。</p>
<p>首先对 <span class="math inline">\(S\)</span>
建立后缀自动机，对于每次询问的 <span class="math inline">\(T\)</span>
我们也建立后缀自动机。</p>
<p>根据 SAM 性质，所有节点代表的字符串的集合之并代表 <span
class="math inline">\(T\)</span> 的全部子串，因此我们可以考虑 <span
class="math inline">\(T\)</span>
后缀自动机上的每个状态代表的字符串中有多少是 <span
class="math inline">\(S\)</span> 的子串。</p>
<p>对于 <span class="math inline">\(T\)</span> 的每个前缀 <span
class="math inline">\(T[:i]\)</span>，求出满足是 <span
class="math inline">\(S\)</span> 子串的最长后缀，设为 <span
class="math inline">\(match(i)\)</span>，感觉这是这篇题解最关键的部分。</p>
<p><span class="math inline">\(match\)</span> 可以通过在 <span
class="math inline">\(S\)</span> 的 SAM 上匹配 <span
class="math inline">\(T\)</span> 得到。</p>
<ul>
<li>具体的，我们在 <span class="math inline">\(S\)</span> 的 SAM 建出的
DAG 上匹配 <span class="math inline">\(T\)</span>，设当前在 SAM 上状态为
<span class="math inline">\(p\)</span>，匹配到 <span
class="math inline">\(T\)</span> 的第 <span
class="math inline">\(i\)</span> 个字符，<span
class="math inline">\(i\)</span> 从 <span
class="math inline">\(1\)</span> 枚举到 <span
class="math inline">\(|T|\)</span>。如果存在 <span
class="math inline">\(\delta(p,T[i])\)</span>，就走转移边，<span
class="math inline">\(p=\delta(p,T[i])\)</span>；否则不断 <span
class="math inline">\(p=link(p)\)</span>，直到存在 <span
class="math inline">\(\delta(p,T[i])\)</span>。过程很像 AC
自动机的匹配，容易发现这是对的。过程中动态维护长度 <span
class="math inline">\(L\)</span>，向下走 <span
class="math inline">\(L\to L+1\)</span>，向上走 <span
class="math inline">\(L\to len(link(p))\)</span>，每次完成当前 <span
class="math inline">\(T[i]\)</span> 的转移，就记录 <span
class="math inline">\(match(i)=L\)</span>。</li>
</ul>
<p>对于一个节点 <span class="math inline">\(p\)</span>，设 <span
class="math inline">\(endpos(p)\)</span> 中第一个元素（位置）为 <span
class="math inline">\(pos_p\)</span>（其实不是第一个也行，等价）。</p>
<p>容易发现，在 <span class="math inline">\(endpos(p)\)</span>
等价类内的串中，长度 <span
class="math inline">\(&gt;match(pos_p)\)</span> 的都不可能和 <span
class="math inline">\(S\)</span> 匹配，需要扣掉 <span
class="math inline">\(\le match(pos_p)\)</span> 的部分。</p>
<p>本来本质不同串统计的是 <span
class="math inline">\(len(p)-len(link(p))\)</span>，代表：为保证一种串只被统计一次，长度
<span class="math inline">\(\le len(link(p))\)</span> 的串不能在 <span
class="math inline">\(p\)</span>
内被统计，会在到根的链上的某个地方被统计。</p>
<p>限制和 <span class="math inline">\(\le match(pos_p)\)</span>
本质相同，都是扣掉一个前缀。</p>
<p>所以说，答案统计改为 <span
class="math inline">\(len(p)-\max(len(link(p)),match(pos_p))\)</span>
即可，扣掉最长的前缀。</p>
<p>现在已经可以过前 <span class="math inline">\(17\)</span> 个点了。加入
<span class="math inline">\([l,r]\)</span> 限制怎么做？</p>
<p><span class="math inline">\(match\)</span> 定义变为：对于 <span
class="math inline">\(T\)</span> 的每个前缀 <span
class="math inline">\(T[:i]\)</span>，满足是 <span
class="math inline">\(S[l,r]\)</span> 子串的最长后缀。</p>
<p>在走 <span class="math inline">\(\delta(p,T[i])\)</span>
的过程中，我们忽略了 <span class="math inline">\(\delta(p,T[i])\)</span>
代表的这些串是否有在 <span class="math inline">\([l,r]\)</span>
内出现过。</p>
<p>换句话说，是否存在 <span class="math inline">\(d\in
endpos(\delta(p,T[i]))\)</span> 满足 <span
class="math inline">\(d\in[l+L,r]\)</span>，只有存在 <span
class="math inline">\(\delta(p,T[i])\)</span> 且存在这样的 <span
class="math inline">\(d\)</span>，才能让 <span
class="math inline">\(L\to L+1\)</span>，并向下走转移边。</p>
<p>现在 <span class="math inline">\(L\)</span> 和判断合法性相关，只有当
<span class="math inline">\(L=len(link(p))\)</span> 的时候才能跳 <span
class="math inline">\(link\)</span>，不然就一直 <span
class="math inline">\(L\to
L-1\)</span>，相当于在当前点的等价类串长区间内遍历，容易发现不影响复杂度。</p>
<p>那么怎么判断是否存在这样的 <span class="math inline">\(d\)</span>
呢？<span class="math inline">\(S\)</span> 的 SAM <span
class="math inline">\(parent\)</span> 树上线段树合并即可，相当于是在求
<span class="math inline">\(endpos\)</span> 集合的桶线段树，有链接：<a
href="https://h01yshhmy.github.io/2024/01/18/P4094/">P4094 |
h01yshhmy</a>。</p>
<p>值得一提，普通的线段树合并会销毁子树，而我们需要查询任意一个子树，所以需要用类似于“可持久化”的写法，保留每一个版本，具体见代码。</p>
<p>统计答案部分依然不变： <span class="math display">\[
\sum_{i\in \textrm{SAM}(T)}
\max(0,len(i)-\max(len(link(i)),match(pos_i)))
\]</span> 对 <span class="math inline">\(0\)</span> 取个 <span
class="math inline">\(\max\)</span>，因为我们没有约束 <span
class="math inline">\(match(pos_i)\)</span> 和 <span
class="math inline">\(len(i)\)</span> 之间的大小关系，可能出现负数。</p>
<p>时间复杂度 <span class="math inline">\(O(|S|\log
|S|+\sum|T|)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,qn;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>&#123;</span><br><span class="line">    <span class="type">int</span> tot,las,lnk[N*<span class="number">2</span>],len[N*<span class="number">2</span>],pos[N*<span class="number">2</span>],go[N*<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,tot)&#123;</span><br><span class="line">            lnk[i]=len[i]=pos[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(go[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(go[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        las=tot=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> u=++tot,p=las;</span><br><span class="line">        len[u]=len[las]+<span class="number">1</span>,pos[u]=id;</span><br><span class="line">        las=u;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!go[p][c])&#123;</span><br><span class="line">            go[p][c]=u,p=lnk[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">            lnk[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> q=go[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)lnk[u]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nowq=++tot;</span><br><span class="line">            len[nowq]=len[p]+<span class="number">1</span>,pos[nowq]=pos[q];</span><br><span class="line">            <span class="built_in">memcpy</span>(go[nowq],go[q],<span class="built_in">sizeof</span>(go[q]));</span><br><span class="line">            lnk[nowq]=lnk[q],lnk[q]=lnk[u]=nowq;</span><br><span class="line">            <span class="keyword">while</span>(p&amp;&amp;go[p][c]==q)&#123;</span><br><span class="line">                go[p][c]=nowq,p=lnk[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mS,mT;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>],sum;</span><br><span class="line">&#125;t[N*<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> rot[N],ncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)rt=++ncnt;</span><br><span class="line">    t[rt].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)<span class="keyword">return</span> p+q;</span><br><span class="line">    <span class="type">int</span> x=++ncnt;</span><br><span class="line">    t[x].sum=t[p].sum+t[q].sum;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">ls</span>(x)=<span class="built_in">merge</span>(<span class="built_in">ls</span>(p),<span class="built_in">ls</span>(q),l,mid);</span><br><span class="line">    <span class="built_in">rs</span>(x)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(p),<span class="built_in">rs</span>(q),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].sum;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res+=<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res+=<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getEndpos</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="built_in">getEndpos</span>(v);</span><br><span class="line">        rot[u]=<span class="built_in">merge</span>(rot[u],rot[v],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMatch</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>),p=<span class="number">1</span>,L=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,len)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mS.go[p][c]&amp;&amp;<span class="built_in">query</span>(rot[mS.go[p][c]],<span class="number">1</span>,n,l+L,r))&#123;</span><br><span class="line">                p=mS.go[p][c];</span><br><span class="line">                L++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!L)<span class="keyword">break</span>;</span><br><span class="line">            L--;</span><br><span class="line">            <span class="keyword">if</span>(L==mS.len[mS.lnk[p]])&#123;</span><br><span class="line">                p=mS.lnk[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        match[i]=L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    mS.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        mS.<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">        <span class="built_in">insert</span>(rot[mS.las],<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,mS.tot)&#123;</span><br><span class="line">        G[mS.lnk[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getEndpos</span>(<span class="number">1</span>);</span><br><span class="line">    cin&gt;&gt;qn;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qn--)&#123;</span><br><span class="line">        cin&gt;&gt;(s+<span class="number">1</span>)&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        m=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        mT.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            mT.<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getMatch</span>(s,l,r);</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,mT.tot)&#123;</span><br><span class="line">            ans+=<span class="built_in">max</span>(<span class="number">0</span>,mT.len[i]-<span class="built_in">max</span>(mT.len[mT.lnk[i]],match[mT.pos[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
        <tag>线段树</tag>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>P7409</title>
    <url>/2024/01/19/P7409/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7409">P7409 SvT</a></p>
<span id="more"></span>
<p>有双倍经验：<a href="https://www.luogu.com.cn/problem/CF1073G">Yet
Another LCP
Problem</a>，多了一步容斥，有一说一这个容斥比后面字符串部分还难想，可以看看。</p>
<p>属于是后缀树板子。</p>
<p>当然这题有很多做法，本来第一想法是 SA 之后区间 <span
class="math inline">\(\min\)</span> 转笛卡尔树 <span
class="math inline">\(\textrm{LCA}\)</span>，建关键点虚树后算贡献。看起来就挺难调。</p>
<p>所以皈依后缀树了。</p>
<p>众所周知，在后缀树上，<span
class="math inline">\(\textrm{LCP}(s[i:],s[j:])=s[\textrm{LCA}(i,j):]\)</span>。</p>
<p>显然 <span class="math inline">\(i,j\)</span>
都要在询问的关键点集合内。对关键点建虚树，算每个点作为 <span
class="math inline">\(\textrm{LCA}\)</span> 的贡献，就做完了。</p>
<p>不过要注意一个点，因为后缀树是一个压缩 <span
class="math inline">\(Trie\)</span>，边上被压缩的点会对 <span
class="math inline">\(\textrm{LCP}\)</span>
长度做贡献，算每个点到根距离（也就是每个点代表的后缀长度）的时候要加上权值。</p>
<p>写 <span class="math inline">\(O(n\log n)-O(1)\)</span> 的 <span
class="math inline">\(\textrm{LCA}\)</span>，时间复杂度 <span
class="math inline">\(O(|S|\log |S|+\sum t)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, id[N], last = <span class="number">1</span>, tot = <span class="number">1</span>, mx[N], fa[N], ch[N][<span class="number">27</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to, next, w;</span><br><span class="line">    &#125; k[N * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N], tot, dep[N], dis[N], cnt, dfn[N], siz[N], num, id[N], fa[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            head[i] = dep[i] = dis[i] = dfn[i] = siz[i] = <span class="number">0</span>;</span><br><span class="line">            fa[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = cnt = num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, u[N * <span class="number">2</span>], kl[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Ele</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, w;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>][<span class="number">21</span>];</span><br><span class="line">    <span class="function">Ele <span class="title">mn</span><span class="params">(Ele a, Ele b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.w &lt; b.w)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i, sum)</span><br><span class="line">            st[i][<span class="number">0</span>] = Ele&#123;u[i], dep[u[i]]&#125;;</span><br><span class="line">        <span class="built_in">re</span>(i, <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">re</span>(j, sum)</span><br><span class="line">            &#123;</span><br><span class="line">                st[j][i] = <span class="built_in">mn</span>(st[j][i - <span class="number">1</span>], st[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        k[++tot].to = to;</span><br><span class="line">        k[tot].w = val;</span><br><span class="line">        k[tot].next = head[from];</span><br><span class="line">        head[from] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dep[now] = dep[f] + <span class="number">1</span>;</span><br><span class="line">        dfn[now] = ++cnt;</span><br><span class="line">        u[++sum] = now;</span><br><span class="line">        kl[now] = sum;</span><br><span class="line">        fa[now] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i; i = k[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k[i].to == f)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dis[k[i].to] = dis[now] + k[i].w;</span><br><span class="line">            <span class="built_in">dfs</span>(k[i].to, now);</span><br><span class="line">            u[++sum] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kl[a] &gt; kl[b])</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">        a = kl[a];</span><br><span class="line">        b = kl[b];</span><br><span class="line">        <span class="type">int</span> len = __lg(b - a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mn</span>(st[a][len], st[b - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]).u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[a] &lt; dep[b])</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">return</span> dis[a] - dis[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i; i = k[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k[i].to == fa[now])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">solve</span>(k[i].to);</span><br><span class="line">            ans += <span class="number">1ll</span> * siz[now] * siz[k[i].to] * dis[now];</span><br><span class="line">            siz[now] += siz[k[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T1, T2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> np = ++tot, p = last;</span><br><span class="line">    last = np;</span><br><span class="line">    mx[np] = mx[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !ch[p][c]; p = fa[p])</span><br><span class="line">        ch[p][c] = np;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = ch[p][c];</span><br><span class="line">    <span class="keyword">if</span> (mx[q] == mx[p] + <span class="number">1</span>)</span><br><span class="line">        fa[np] = q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nq = ++tot;</span><br><span class="line">        mx[nq] = mx[p] + <span class="number">1</span>;</span><br><span class="line">        fa[nq] = fa[q];</span><br><span class="line">        fa[q] = fa[np] = nq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">            ch[nq][i] = ch[q][i];</span><br><span class="line">        <span class="keyword">for</span> (; p &amp;&amp; ch[p][c] == q; p = fa[p])</span><br><span class="line">            ch[p][c] = nq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> T1.dfn[a] &lt; T1.dfn[b]; &#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; (c + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pe</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">extend</span>(c[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        id[i] = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, tot)</span><br><span class="line">        T1.<span class="built_in">add</span>(fa[i], i, mx[i] - mx[fa[i]]);</span><br><span class="line">    T1.<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    T1.<span class="built_in">build</span>();</span><br><span class="line">    <span class="type">int</span> s, p[N];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i, s)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; p[i];</span><br><span class="line">            p[i] = id[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + s, cmp);</span><br><span class="line">        t.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        T2.id[<span class="number">1</span>] = ++T2.num;</span><br><span class="line">        <span class="built_in">re</span>(i, s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                T2.siz[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x = p[i], y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (T1.<span class="built_in">lca</span>(t.<span class="built_in">top</span>(), x) != t.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                y = t.<span class="built_in">top</span>();</span><br><span class="line">                t.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (T1.<span class="built_in">lca</span>(t.<span class="built_in">top</span>(), x) != t.<span class="built_in">top</span>())</span><br><span class="line">                    T2.<span class="built_in">add</span>(T2.id[t.<span class="built_in">top</span>()], T2.id[y], T1.<span class="built_in">get</span>(t.<span class="built_in">top</span>(), y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> z = T1.<span class="built_in">lca</span>(y, x);</span><br><span class="line">                <span class="keyword">if</span> (z != t.<span class="built_in">top</span>())</span><br><span class="line">                    t.<span class="built_in">push</span>(z), T2.id[z] = ++T2.num;</span><br><span class="line">                T2.<span class="built_in">add</span>(T2.id[z], T2.id[y], T1.<span class="built_in">get</span>(z, y));</span><br><span class="line">            &#125;</span><br><span class="line">            T2.id[x] = ++T2.num;</span><br><span class="line">            T2.siz[T2.num] = <span class="number">1</span>;</span><br><span class="line">            t.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.<span class="built_in">top</span>();</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">            T2.<span class="built_in">add</span>(T2.id[t.<span class="built_in">top</span>()], T2.id[x], T1.<span class="built_in">get</span>(x, t.<span class="built_in">top</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        T2.<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        T2.<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">        T2.<span class="built_in">clear</span>(T2.num);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>笛卡尔树</tag>
        <tag>字符串</tag>
        <tag>SA</tag>
        <tag>后缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1129D</title>
    <url>/2024/01/19/CF1129D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1129D">Isolation</a></p>
<span id="more"></span>
<p>这怎么评出 *2900 的。</p>
<p>显然设 <span class="math inline">\(f_i\)</span> 为前缀 <span
class="math inline">\(i\)</span> 的答案，每次枚举当前段从哪里加入。</p>
<p>定义 <span class="math inline">\(w(l,r)\)</span> 为：<span
class="math inline">\(l,r\)</span> 内恰好出现过一次的元素个数。</p>
<p>容易得到： <span class="math display">\[
f_i=\sum_{j=1}^{i-1}f_j[w(j+1,i)\le k]
\]</span> 平方的复杂度太慢，考虑优化。</p>
<p>固定 <span class="math inline">\(i\)</span>，<span
class="math inline">\(w(j,i)\)</span> 单调不增，也就是说满足条件的 <span
class="math inline">\(j\)</span> 一定是当前 <span
class="math inline">\([1,i]\)</span> 的一段连续后缀。</p>
<p>单调的东西可以想到二分，需要通过 <span
class="math inline">\(w(l,r)\)</span> 的值来 <code>check</code>。</p>
<p>设 <span class="math inline">\(pre(i)\)</span> 为 <span
class="math inline">\(i\)</span> 前面第一个满足 <span
class="math inline">\(a[i]=a[x]\)</span> 的 <span
class="math inline">\(x\)</span>。</p>
<p>容易发现，对于当前新增的一个 <span
class="math inline">\(a[r]\)</span>，会使 <span
class="math inline">\(l\in [pre(i)+1,i]\)</span> 的 <span
class="math inline">\(w(l,r)\)</span> 加一；<span
class="math inline">\(l\in[pre(pre(i))+1,pre(i)]\)</span> 的 <span
class="math inline">\(w(l,r)\)</span> 减一。</p>
<p>二分过程中需要用 <span class="math inline">\(w(mid,r)\)</span>
的值。</p>
<p>据 lxl 所说，区间 <span
class="math inline">\(+1/-1\)</span>，求区间恰好等于 <span
class="math inline">\(x\)</span> 的个数，这样的问题没有 <span
class="math inline">\(\textrm{polylog}\)</span> 做法，只能分块。</p>
<p>现在我们可以分块+二分找到后缀端点，维护前缀和转移到 <span
class="math inline">\(f_r\)</span>，复杂度 <span
class="math inline">\(O(n\sqrt{n}\log n)\)</span>——有点多此一举？</p>
<p>分块都写了，是否是后缀，有没有单调性就不重要了。直接动态维护每个
<span class="math inline">\(f_j[w(j+1,i)\le k]\)</span>
是否造成贡献就行。</p>
<p>设 <span class="math inline">\(s(i,j)\)</span> 表示第 <span
class="math inline">\(i\)</span> 个块中 <span
class="math inline">\(w(l+1,r)=j\)</span> 的 <span
class="math inline">\(f_l\)</span> 之和，<span
class="math inline">\(tag_i\)</span> 表示第 <span
class="math inline">\(i\)</span>
个块的位移懒标记，只有当前块被当作散块处理时才下放标记。</p>
<p>当块 <span class="math inline">\(+1\)</span> 时，<span
class="math inline">\(ans\leftarrow ans-s(i,k-tag_i)\)</span>。</p>
<p>当块 <span class="math inline">\(-1\)</span> 时，<span
class="math inline">\(ans\leftarrow ans+s(i,k-tag_i+1)\)</span>。</p>
<p>容易理解，<span class="math inline">\(+1/-1\)</span> 只会影响正好在
<span class="math inline">\(\le k\)</span> 边界上的贡献。</p>
<p>做完了。</p>
<p>注意 <span class="math inline">\(s\)</span>
第二维可能会有负数下标，开二倍数组，整体位移 <span
class="math inline">\(n\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = <span class="number">320</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, k, Ans, B, a[N], pre[N], las[N];</span><br><span class="line"><span class="type">int</span> bel[N], s[M][N], cnt[N], f[N], tag[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a -= b;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        a += mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= mod)</span><br><span class="line">        a -= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bu = bel[u];</span><br><span class="line">    cnt[u] -= tag[bu];</span><br><span class="line">    <span class="built_in">inc</span>(Ans, v);</span><br><span class="line">    <span class="built_in">inc</span>(s[bu][cnt[u] + n], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bu = bel[u];</span><br><span class="line">    <span class="keyword">if</span> (cnt[u] + tag[bu] &lt;= k)</span><br><span class="line">        <span class="built_in">dec</span>(Ans, f[u - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">dec</span>(s[bu][cnt[u] + n], f[u - <span class="number">1</span>]);</span><br><span class="line">    cnt[u] += v;</span><br><span class="line">    <span class="keyword">if</span> (cnt[u] + tag[bu] &lt;= k)</span><br><span class="line">        <span class="built_in">inc</span>(Ans, f[u - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">inc</span>(s[bu][cnt[u] + n], f[u - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> bl = bel[L], br = bel[R];</span><br><span class="line">    <span class="keyword">if</span> (bl + <span class="number">1</span> &gt;= br)</span><br><span class="line">        <span class="built_in">rep</span>(i, L, R)</span><br><span class="line">            <span class="built_in">update</span>(i, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, L, bl * B)</span><br><span class="line">            <span class="built_in">update</span>(i, v);</span><br><span class="line">        <span class="built_in">rep</span>(i, (br - <span class="number">1</span>) * B + <span class="number">1</span>, R)</span><br><span class="line">            <span class="built_in">update</span>(i, v);</span><br><span class="line">        <span class="built_in">rep</span>(i, bl + <span class="number">1</span>, br - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (~v)</span><br><span class="line">                <span class="built_in">dec</span>(Ans, s[i][k - tag[i] + n]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">inc</span>(Ans, s[i][k - tag[i] + <span class="number">1</span> + n]);</span><br><span class="line">            tag[i] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, k);</span><br><span class="line">    B = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pre[i] = las[a[i]], las[a[i]] = i;</span><br><span class="line">        bel[i] = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    B = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modify</span>(pre[i] + <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">modify</span>(pre[pre[i]] + <span class="number">1</span>, pre[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + <span class="number">1</span>, f[i] = Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>CF713C</title>
    <url>/2024/01/19/CF713C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF713C">Sonya and Problem
Wihtout a Legend</a></p>
<span id="more"></span>
<p>最初的 slope trick 模板题。</p>
<p>把常用用法放前面了。</p>
<p>slope trick
可以优化连续分段凸函数的<strong>相加、平移、最值</strong>等操作。</p>
<p>一般要求每一段都是一次函数，且斜率为整数。</p>
<p>将凸壳转化成集合和直线的过程在下文题解内。</p>
<h2 id="相加">相加</h2>
<p>直线的 <span class="math inline">\(k,b\)</span>
相加，集合做合并。</p>
<h2 id="找最值点">找最值点</h2>
<p>下凸函数求最小值为例。</p>
<p>也就是找斜率为 <span class="math inline">\(0\)</span>
的线段（允许端点重合）。</p>
<p>常用一个大根堆 <span class="math inline">\(L\)</span> 和小根堆 <span
class="math inline">\(R\)</span> 维护拐点，<span
class="math inline">\(L\)</span> 存目标线段左侧拐点，<span
class="math inline">\(R\)</span>
存目标线段右侧拐点，<code>L.top()</code> 和 <code>R.top</code>
就是这条线段的左右端点。</p>
<p>维护方法：始终保持 <span
class="math inline">\(k+L.size()=0\)</span>，将多余点扔进 <span
class="math inline">\(R\)</span>，这里的 <span
class="math inline">\(k\)</span> 就是前面的斜率极差，原因见题解。</p>
<p>当 <span class="math inline">\(k\)</span>（斜率）减小时，要从 <span
class="math inline">\(R\)</span> 中取点补进 <span
class="math inline">\(L\)</span>，再加入新点。</p>
<h2 id="前后缀最值">前后缀最值</h2>
<p>以前缀 <span class="math inline">\(\min\)</span> 为例。</p>
<p>其实就是扔掉了 <span class="math inline">\(R\)</span>
中的所有拐点，因为第一个斜率 <span class="math inline">\(0\)</span>
的线段后面都是斜率为 <span class="math inline">\(0\)</span>
的，不仅斜率单调，函数值也单调。</p>
<p>实现时可以只维护 <span class="math inline">\(L\)</span>
堆。也就是此题的维护方式。</p>
<h2 id="平移">平移</h2>
<p>直线直接移。集合就在堆上打 <span
class="math inline">\(tag\)</span>。</p>
<h2 id="题解">题解</h2>
<p>严格递增不好做，将 <span class="math inline">\(a_i\)</span> 换成
<span class="math inline">\(a_i-i\)</span>
后求单调不降的答案。容易发现和原问题等价。</p>
<p>设 <span class="math inline">\(f(i,j)\)</span> 表示将 <span
class="math inline">\(a_i\)</span> 变成 <span
class="math inline">\(j\)</span>，使得 <span
class="math inline">\([1,i]\)</span> 不降所需要的最小操作数，有： <span
class="math display">\[
f(i,j)=\min_{1\le k\le j}f(i-1,k)+|a_i-j|
\]</span> 然后这样其实就过了。但是没啥含量，事实上可以继续优化。</p>
<p>需要使用 slope trick。这是一种依赖凸性的对最优化DP的优化手段。 <span
class="math display">\[
\begin{aligned}
&amp;F_i(x)=f(i,x)\\
&amp;G_i(x)=\min_{1\le k\le x}f(i,k)\\
&amp;W_i(x)=|a_i-x|
\end{aligned}
\]</span> 式子变为： <span class="math display">\[
F_i(x)=G_{i-1}(x)+W_i(x)
\]</span> 容易发现，<span class="math inline">\(F,G,W\)</span>
这三个函数全是凸的。</p>
<p>证明也不难：</p>
<ul>
<li>首先，<span class="math inline">\(W\)</span>
是绝对值形式，显然下凸。那么，<span
class="math inline">\(F_1,G_1\)</span> 也是下凸的。</li>
<li><span class="math inline">\(G_i\)</span> 是 <span
class="math inline">\(F_i\)</span> 的一段前缀 <span
class="math inline">\(\min\)</span>，显然 <span
class="math inline">\(G_i\)</span> 是凸的，或者说是单调的。</li>
<li>然后可以归纳法，<span class="math inline">\(G_{i-1}\)</span>
是凸的，<span class="math inline">\(W_i\)</span>
也是凸的，两个凸函数相加肯定还是凸的，所以 <span
class="math inline">\(F_i\)</span> 是凸的。</li>
</ul>
<p>而且有个很好的性质，斜率均是整数。因为每次加入的 <span
class="math inline">\(W_i\)</span> 斜率是整数。</p>
<p>然后有一个重要的维护手段，通过维护拐点来维护凸壳。</p>
<p>可以用一个集合和一个一次函数表示一个凸壳。</p>
<p>对于凸壳上的点 <span
class="math inline">\(p\)</span>，如果点两侧斜率不同，设斜率之差的绝对值为
<span class="math inline">\(d\)</span>，就放 <span
class="math inline">\(d\)</span> 个 <span
class="math inline">\(p\)</span>（每当斜率变化 <span
class="math inline">\(1\)</span>
就放进去一个横坐标）。由于凸壳横坐标最大的点会延申出去，用一次函数描述延伸出的直线即可。</p>
<p>设凸函数 <span class="math inline">\(C_1,C_2\)</span> 的集合为 <span
class="math inline">\(S_1,S_2\)</span>，直线分别为 <span
class="math inline">\(l_1,l_2\)</span>，则另一凸函数 <span
class="math inline">\(C_3=C_1+C_2\)</span> 的集合为 <span
class="math inline">\(S_3=S_1\cup S_2\)</span>，末尾直线是 <span
class="math inline">\(l_3=l_1+l_2\)</span>（斜率相加，截距相加）。</p>
<p>容易发现（实在不行就打表吧），<span class="math inline">\(F\)</span>
的末尾直线斜率为 <span class="math inline">\(1\)</span>，<span
class="math inline">\(G\)</span> 的末尾直线斜率为 <span
class="math inline">\(0\)</span>。因为 <span
class="math inline">\(F\)</span> 的最后一段肯定是加进去的 <span
class="math inline">\(W_i\)</span>，绝对值函数右侧斜率为 <span
class="math inline">\(1\)</span>；<span class="math inline">\(G\)</span>
作为前缀 <span
class="math inline">\(\min\)</span>，最后一段显然是水平直线。</p>
<p><span class="math inline">\(G_{i-1}\)</span> 转移到 <span
class="math inline">\(F_i\)</span> 的过程，相当于加上 <span
class="math inline">\(W_i\)</span>。根据上述定义，<span
class="math inline">\(W_i\)</span> 的集合是 <span
class="math inline">\(\{a_i,a_i\}\)</span>（两个直线斜率分别 <span
class="math inline">\(-1,1\)</span>，差 <span
class="math inline">\(2\)</span>）。</p>
<p>设 <span class="math inline">\(G_{i-1}\)</span> 的“最低拐点”为 <span
class="math inline">\(p\)</span>（同时也是 <span
class="math inline">\(F_{i-1}\)</span> 的）：</p>
<ul>
<li>动态维护一个 <span class="math inline">\(p\)</span> 左侧的斜率变化量
<span class="math inline">\(k\)</span>。加上 <span
class="math inline">\(W_i\)</span> 后，<span
class="math inline">\(k\leftarrow k-1\)</span>，集合加入 <span
class="math inline">\(\{a_i,a_i\}\)</span>。</li>
<li>为了严格按照定义来，这个凸壳的集合大小必须等于 <span
class="math inline">\(|k|\)</span>，因为斜率变动 <span
class="math inline">\(1\)</span>
就放一个点。所以要从右到左扔掉多余的点（就是在前面写的从 <span
class="math inline">\(L\)</span> 放到 <span
class="math inline">\(R\)</span>，不需要维护 <span
class="math inline">\(R\)</span>
就可以直接扔了），其实只会扔掉一个点。</li>
<li>扔的时候判一下是否会对答案做贡献（要扔的 <span
class="math inline">\(p\)</span> 满足 <span
class="math inline">\(p&gt;a_i\)</span>，这样我们需要将 <span
class="math inline">\(a_i\)</span> 改为 <span
class="math inline">\(p\)</span> 满足序列单调不降，答案加 <span
class="math inline">\(p-a_i\)</span>。</li>
<li>整个过程中相当于让最优点从 <span class="math inline">\(p\)</span>
转成了 <span class="math inline">\(a_i\)</span>。</li>
</ul>
<p>容易发现我们只需要最优点和它左边的点，也就是说那条末尾延申的直线和凸壳中斜率为正（<span
class="math inline">\(p\)</span> 右边）的部分可以不管。</p>
<p>代码十分简略。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,x=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        x=x-i;</span><br><span class="line">        k--;</span><br><span class="line">        q.<span class="built_in">push</span>(x),q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(k+q.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;q.<span class="built_in">top</span>())ans+=q.<span class="built_in">top</span>()-x;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>slope-trick</tag>
      </tags>
  </entry>
  <entry>
    <title>P4331</title>
    <url>/2024/01/20/P4331/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4331">P4331 [BalticOI
2004] Sequence</a></p>
<span id="more"></span>
<p>容易发现题目和<a href="https://www.luogu.com.cn/problem/CF713C">Sonya
and Problem Wihtout a Legend</a>相同，有题解：<a
href="https://h01yshhmy.github.io/2024/01/19/CF713C/">CF713C |
h01yshhmy</a>，不再赘述。</p>
<p>主要区别在于输出答案。</p>
<p>考虑记录过程中斜率为 <span class="math inline">\(0\)</span>
的线段左端点，也就是最优的 <span class="math inline">\(f(i,x)\)</span>
中的 <span class="math inline">\(x\)</span>。记为 <span
class="math inline">\(pos(i)\)</span>。</p>
<p>容易发现，需要满足 <span class="math inline">\(pos(i)\le
pos(i+1)\)</span> 才能使序列单调不降，所以答案就是： <span
class="math display">\[
b_i=\min_{j=i}^{n}pos(j)
\]</span> 也就是后缀 <span class="math inline">\(\min\)</span>。</p>
<p>求出 <span class="math inline">\(b\)</span>
之后可以用更直观的方式算答案： <span class="math display">\[
ans=\sum_{i=1}^n|a_i-b_i|
\]</span> 比CF713C题解的写法好。</p>
<p>最后别忘了给 <span class="math inline">\(b_i\)</span> 加上 <span
class="math inline">\(i\)</span>，将问题还原为严格递增。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pos[N],a[N],n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]=a[i]-i;</span><br><span class="line">        k--;</span><br><span class="line">        q.<span class="built_in">push</span>(a[i]),q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(k+q.<span class="built_in">size</span>()&gt;<span class="number">0</span>)q.<span class="built_in">pop</span>();</span><br><span class="line">        pos[i]=q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pe</span>(i,n<span class="number">-1</span>)pos[i]=<span class="built_in">min</span>(pos[i+<span class="number">1</span>],pos[i]);</span><br><span class="line">    <span class="built_in">re</span>(i,n)ans+=<span class="built_in">abs</span>(a[i]-pos[i]);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(pos[i]+i,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>slope-trick</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC217H</title>
    <url>/2024/01/20/ABC217H/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc217_h">[ABC217H]
Snuketoon</a></p>
<span id="more"></span>
<p>写一个朴素 DP，设 <span class="math inline">\(f(i,j)\)</span>
为：只考虑前 <span class="math inline">\(i\)</span> 个事件，当前位置在
<span class="math inline">\(j\)</span> 点的最小伤害量。</p>
<p>容易得到转移： <span class="math display">\[
f(i,j)=\begin{cases}\min\limits_{|j-k|\le
T_i-T_{i-1}}f(j-1,k)+\max(0,X_i-j)&amp;D_i=0\\\min\limits_{|j-k|\le
T_i-T_{i-1}}f(i-1,k)+\max(0,j-X_i)&amp;D_i=1\end{cases}
\]</span> 转移很自然。考虑优化。</p>
<p>容易证明，式子里的每一项都是一个凸函数。可以归纳出来。</p>
<p>可以使用 slope trick。</p>
<p>对于 <span class="math inline">\(\min\)</span> 来说，可以在 <span
class="math inline">\([j-(T_i-T_{i-1}),j+(T_i-T_{i-1})]\)</span>
的范围内找最小值。也就是说，对于当前凸壳斜率为 <span
class="math inline">\(0\)</span>
线段左侧的拐点，会向右找到更小的值；对于右侧的拐点，会向左找到更小的值。</p>
<p>相当于使左侧的图形向左平移 <span
class="math inline">\(T_i-T_{i-1}\)</span>，右侧图形向右平移 <span
class="math inline">\(T_i-T_{i-1}\)</span>，斜率为 <span
class="math inline">\(0\)</span>
的线段延长，补足空缺。画图容易理解。</p>
<p>对于凸壳平移，为左右的集合打 <span class="math inline">\(tag\)</span>
即可。</p>
<p>对于加入的 <span class="math inline">\(\max\)</span> 来说，<span
class="math inline">\(\max(0,X_i-j)\)</span> 形如 <code>\_</code>，<span
class="math inline">\(\max(0,j-X_i)\)</span> 形如
<code>_/</code>，此题答案要在斜率为 <span
class="math inline">\(0\)</span> 线段的左侧（包括自己）找，所以只有加入
<span class="math inline">\(\max(0,X_i-j)\)</span>
的时候需要改变当前维护的斜率变化量，使变化量 <span
class="math inline">\(-1\)</span>（显然 <span
class="math inline">\(g(j)=\max(0,X_i-j)\)</span> 斜率为 <span
class="math inline">\(-1\)</span>）。</p>
<p>注意到本题还有限制：<span class="math inline">\(\forall
f(i,j),j\in[-T_i,T_i]\)</span>，原因显然，这是移动极限。</p>
<p>所以加入新的 <span class="math inline">\(X_i\)</span>
的时候需要限制一下。</p>
<p>对于每个 <span
class="math inline">\(i\)</span>，将右侧的最靠左端点，也就是斜率为 <span
class="math inline">\(0\)</span> 线段的右端点记为 <span
class="math inline">\(pos(i)\)</span>，也就是 <span
class="math inline">\(f(i,pos(i))\)</span> 最优。</p>
<p>然而每个 <span class="math inline">\(pos(i)\)</span> 都只考虑了当前
<span class="math inline">\(i\)</span>
这个前缀，我们还是需要考虑合法性：在 <span
class="math inline">\(T_i-T_{i-1}\)</span> 的时间里能否走到。</p>
<p>处理一下即可，走不到就尽可能靠近 <span
class="math inline">\(pos(i)\)</span>，因为是凸的，所以这种贪心正确。</p>
<p>其他操作都和<a
href="https://h01yshhmy.github.io/2024/01/19/CF713C/">CF713C |
h01yshhmy</a>中所写基本一致。</p>
<p>注意要先补充左侧集合直到满足 <span
class="math inline">\(k+L.size()=0\)</span>，再加入当前新点，原因显然，先加入就补不了了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,T[N],D[N],X[N],pos[N],res[N];</span><br><span class="line">priority_queue&lt;ll&gt; L;</span><br><span class="line">priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt;&gt; R;</span><br><span class="line">ll ltag,rtag;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(T[i],D[i],X[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="type">int</span> d=T[i]-T[i<span class="number">-1</span>];</span><br><span class="line">        ltag-=d,rtag+=d;</span><br><span class="line">        <span class="keyword">if</span>(D[i]==<span class="number">0</span>)k--;</span><br><span class="line">        <span class="keyword">while</span>(!R.<span class="built_in">empty</span>()&amp;&amp;k+(<span class="type">int</span>)L.<span class="built_in">size</span>()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            L.<span class="built_in">push</span>(R.<span class="built_in">top</span>()+rtag-ltag);</span><br><span class="line">            R.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="built_in">min</span>(T[i],<span class="built_in">max</span>(-T[i],X[i]));</span><br><span class="line">        L.<span class="built_in">push</span>(p-ltag);</span><br><span class="line">        <span class="keyword">while</span>(k+(<span class="type">int</span>)L.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            R.<span class="built_in">push</span>(L.<span class="built_in">top</span>()+ltag-rtag);</span><br><span class="line">            L.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        pos[i]=R.<span class="built_in">empty</span>()?T[i]:R.<span class="built_in">top</span>()+rtag;</span><br><span class="line">    &#125;</span><br><span class="line">    res[n]=pos[n];</span><br><span class="line">    <span class="built_in">pe</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> d=T[i+<span class="number">1</span>]-T[i];</span><br><span class="line">        <span class="keyword">if</span>(res[i+<span class="number">1</span>]&gt;=pos[i])&#123;</span><br><span class="line">            res[i]=<span class="built_in">max</span>(pos[i],res[i+<span class="number">1</span>]-d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res[i]=<span class="built_in">min</span>(pos[i],res[i+<span class="number">1</span>]+d);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(D[i])ans+=<span class="built_in">max</span>(<span class="number">0</span>,res[i]-X[i]);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">max</span>(<span class="number">0</span>,X[i]-res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>slope-trick</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ6240</title>
    <url>/2024/01/20/LOJ6240/</url>
    <content><![CDATA[<p><a href="https://loj.ac/p/6240">#6240. 仙人掌</a></p>
<span id="more"></span>
<p>奇怪期望题。</p>
<p>先不想仙人掌，考虑树怎么做。</p>
<p>很难想到，有一种贡献方式：枚举 <span
class="math inline">\(u,v\)</span>，如果 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的路径上第一个被删除的点是 <span
class="math inline">\(u\)</span>，那么 <span
class="math inline">\(u,v\)</span> 就能对答案造成 <span
class="math inline">\(1\)</span> 的贡献。设 <span
class="math inline">\(path(u,v)\)</span> 为路径点集，容易发现 <span
class="math inline">\((u,v)\)</span> 的贡献是 <span
class="math inline">\(\frac{1}{|path(u,v)|}\)</span>。</p>
<p>考虑基环树怎么做。</p>
<p>这个倒是有题：<a href="https://www.luogu.com.cn/problem/CF235D">Graph
Game</a>。</p>
<p>如果 <span class="math inline">\(u,v\)</span>
路径之间不经过环，贡献不变。</p>
<p>否则，按照 <span class="math inline">\(u,v\)</span>
所在的子树，将环分成 <span class="math inline">\(a,b\)</span> 两部分。记
<span class="math inline">\(u\)</span> 到环的路径是 <span
class="math inline">\(x\)</span>。</p>
<p>容易发现，要么 <span class="math inline">\(x\cup a\)</span>
中第一个被删的是 <span class="math inline">\(u\)</span>，要么 <span
class="math inline">\(x\cup b\)</span> 中第一个被删的是 <span
class="math inline">\(u\)</span>。</p>
<p>不能直接加起来，需要容斥，减去 <span class="math inline">\(x\cup
a\cup b\)</span> 中第一次被删的是 <span class="math inline">\(u\)</span>
的概率，显然这部分被重复计数了。</p>
<p>贡献为 <span
class="math inline">\(\frac{1}{|x|+|a|}+\frac{1}{|x|+|b|}-\frac{1}{|x|+|a|+|b|}\)</span>。</p>
<p>进一步加强问题，考虑仙人掌怎么做。</p>
<p>现在图上有多个不相交的环，会出现多层的容斥，暴力的复杂度指数级。</p>
<p>需要 DP。</p>
<p>设 <span class="math inline">\(f(u,i)\)</span> 为：对于当前 <span
class="math inline">\(u\)</span>，所有 <span
class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(v\in
subtree(u)\)</span> 造成的贡献中，<span
class="math inline">\(\frac{1}{i}\)</span> 的总贡献（容斥）系数。</p>
<p>子树限制无所谓，正好可以不重不漏。</p>
<p>仙人掌 DP 当然要圆方树。</p>
<p>在圆方树上的“相邻”圆点上转移，就是隔了一个方点的圆点。</p>
<p>容易发现，这两个圆点 <span class="math inline">\(u,v\)</span>
要么在扔掉环后的图上相邻（树边），要么在同一个环内。</p>
<p>将树边看作二元环，统一解法。</p>
<p>处理出环大小，容易得到 <span class="math inline">\(u,v\)</span>
对应在环上的 <span class="math inline">\(a,b\)</span>。</p>
<p>做转移： <span class="math display">\[
\begin{aligned}
f(u,i)&amp;\to f(v,i+a)\\
f(u,i)&amp;\to f(v,i+b)\\
-f(u,i)&amp;\to f(v,i+a+b)
\end{aligned}
\]</span> 过程中枚举 <span
class="math inline">\(i\)</span>。较容易理解，和基环树的容斥思路相同。</p>
<p>每走到一个圆点，为答案贡献： <span class="math display">\[
\sum_{i}\frac{f(u,i)}{i}
\]</span> 注意这样只能统计 <span class="math inline">\(u\)</span>
到子树内的 <span
class="math inline">\(v\)</span>。我们在外层需要再枚举一个根，跑 <span
class="math inline">\(n\)</span> 次上述 DP，得到全部 <span
class="math inline">\((u,v)\)</span> 的贡献和。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">805</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], T[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], col[N][N], num, sta[N], tp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++num;</span><br><span class="line">    sta[++tp] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">                tot++;</span><br><span class="line">                T[u].<span class="built_in">pb</span>(tot), T[tot].<span class="built_in">pb</span>(u);</span><br><span class="line">                col[tot][u] = d++;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = sta[tp--];</span><br><span class="line">                    T[tot].<span class="built_in">pb</span>(tmp), T[tmp].<span class="built_in">pb</span>(tot);</span><br><span class="line">                    col[tot][tmp] = d++;</span><br><span class="line">                &#125; <span class="keyword">while</span> (tmp != v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][N], inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = <span class="number">1ll</span> * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N], ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i, sz)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans + <span class="number">1ll</span> * f[u][i] * inv[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : T[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, (<span class="type">int</span>)T[p].<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == col[p][u])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> v = T[p][i], a = <span class="built_in">abs</span>(col[p][u] - col[p][v]) - <span class="number">1</span>, b = (<span class="type">int</span>)T[p].<span class="built_in">size</span>() - a - <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">re</span>(j, sz)</span><br><span class="line">            &#123;</span><br><span class="line">                f[v][j + a + <span class="number">1</span>] = (f[v][j + a + <span class="number">1</span>] + f[u][j]) % mod;</span><br><span class="line">                f[v][j + b + <span class="number">1</span>] = (f[v][j + b + <span class="number">1</span>] + f[u][j]) % mod;</span><br><span class="line">                f[v][j + a + b + <span class="number">1</span>] = (f[v][j + a + b + <span class="number">1</span>] - f[u][j] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(v, p, sz + a + b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    tot = n;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v), G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>容斥</tag>
        <tag>概率与期望</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>P9058</title>
    <url>/2024/01/21/P9058/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9058">P9058 [Ynoi2004]
rpmtdq</a></p>
<span id="more"></span>
<p>询问的限制和树结构不相关，考虑在下标这一维上做些处理。</p>
<p>容易有思路：设 <span
class="math inline">\(g(i)=\min\limits_{j&gt;i}dis(i,j)\)</span>，做扫描线，扫一个
<span class="math inline">\(r\)</span>，动态维护当前 <span
class="math inline">\(i,j\in [1,r]\)</span> 的 <span
class="math inline">\(g\)</span>，扫到询问 <span
class="math inline">\([l,r]\)</span> 的时候，查询 <span
class="math inline">\(\min\limits_{i\in[l,r]}g(i)\)</span>
就是答案。</p>
<p>每次加入新的 <span class="math inline">\((i,r)\)</span> 修改 <span
class="math inline">\(g(i)\)</span>，查询的是后缀。需要单点取 <span
class="math inline">\(\min\)</span> 后缀查 <span
class="math inline">\(\min\)</span>，树状数组可以解决。</p>
<p>但是加入的 <span class="math inline">\((i,r)\)</span> 太多了（<span
class="math inline">\(O(n^2)\)</span> 量级），需要去掉一些。</p>
<p>设有两个点对 <span
class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，满足 <span
class="math inline">\(x_1\le x_2\le y_2\le x_1\)</span>，且 <span
class="math inline">\(dis(x_1,y_1)\ge dis(x_2,y_2)\)</span>，显然 <span
class="math inline">\((x_1,y_1)\)</span> 有贡献的时候 <span
class="math inline">\((x_2,y_2)\)</span> 也有贡献，而且 <span
class="math inline">\((x_2,y_2)\)</span> 比 <span
class="math inline">\((x_1,y_1)\)</span> 更优。所以 <span
class="math inline">\((x_1,y_1)\)</span> 是无用的。我们称 <span
class="math inline">\((x_2,y_2)\)</span> <strong>支配</strong>了 <span
class="math inline">\((x_1,y_1)\)</span>。</p>
<p>我们称一个点对 <span class="math inline">\((x,y)\)</span>
是支配点对，<strong>当且仅当它不被任何其他点对支配</strong>。</p>
<p>考虑找出一个集合 <span class="math inline">\(S\)</span>
包含所有的支配点对，且尽可能让 <span class="math inline">\(S\)</span>
的大小可接受。</p>
<p>找一下一个点对成为支配点对的<strong>必要</strong>条件。</p>
<p>树上点对（路径）问题，考虑点分治找支配点对。</p>
<p>对于一个支配点对 <span
class="math inline">\(x,y\)</span>，一定存在一个分治中心 <span
class="math inline">\(rt\)</span> 使它们分布在两个不同的子树中。</p>
<p>不妨钦定 <span class="math inline">\(dis(x,rt)\le
dis(y,rt)\)</span>，设 <span class="math inline">\(T\)</span>
表示当前连通块中满足 <span class="math inline">\(dis(z,rt)\le
dis(y,rt)\)</span> 且 <span class="math inline">\(y\ne z\)</span> 的
<span class="math inline">\(z\)</span> 构成的集合，则 <span
class="math inline">\(x\)</span> <strong>一定是 <span
class="math inline">\(T\)</span> 中最大的 <span
class="math inline">\(&lt;y\)</span> 的数（前驱）或最小的 <span
class="math inline">\(&gt;y\)</span>
的数（后继）</strong>，感性理解就很对。</p>
<p>考虑证明：</p>
<ul>
<li>反证，以前驱为例，设 <span class="math inline">\(y\)</span> 的前驱为
<span class="math inline">\(p\)</span>，若 <span
class="math inline">\(x&lt;p\)</span>，根据 <span
class="math inline">\(T\)</span> 定义可知 <span
class="math inline">\(dis(x,rt),dis(p,rt)\le dis(y,rt)\)</span>。</li>
<li>首先 <span class="math inline">\(dis(x,p)\le
dis(x,rt)+dis(p,rt)\)</span> 和 <span
class="math inline">\(dis(x,rt)+dis(y,rt)=dis(x,y)\)</span>
一定满足，这是距离的性质（前面钦定了 <span
class="math inline">\(x,y\)</span> 不在同一个子树）。</li>
<li>和第一个式子联立，有 <span class="math inline">\(dis(x,p)\le
dis(x,rt)+dis(p,rt)\le dis(x,rt)+dis(y,rt)=dis(x,y)\)</span>。</li>
<li>而且有 <span class="math inline">\(x&lt;p&lt;y\)</span>。</li>
<li>容易发现，<span class="math inline">\((x,y)\)</span> 被 <span
class="math inline">\((x,p)\)</span> 支配了。</li>
</ul>
<p>后继的证明同理。</p>
<p>具体到实现上怎么做？</p>
<p>点分治过程中，存一下当前分治中心所在连通块的所有点，用深搜暴力找即可，并顺便算出这些点
<span class="math inline">\(u\)</span> 的 <span
class="math inline">\(dis(u,rt)\)</span>。</p>
<p>将这些点按照点编号升序排序，并加入一个 <span
class="math inline">\(dis(u,rt)\)</span> 单调递增的单调栈。</p>
<p>加入点 <span class="math inline">\(y\)</span> 时，<code>pop</code>
掉不合法点后，栈顶一定是满足 <span class="math inline">\(dis(z,rt)\le
dis(y,rt)\)</span> 的前驱 <span
class="math inline">\(z\)</span>，找到支配点对。</p>
<p>对于后继，倒着加入即可。</p>
<p>点分治过程会进行 <span class="math inline">\(O(\log n)\)</span>
层，每一层每一个点只会组成 <span class="math inline">\(O(1)\)</span>
个支配点对，说明总支配点对个数是 <span class="math inline">\(O(n\log
n)\)</span> 的。</p>
<p>现在我们将 <span class="math inline">\(|S|\)</span> 的规模从 <span
class="math inline">\(O(n^2)\)</span> 降到了 <span
class="math inline">\(O(n\log n)\)</span>，可以做最初的扫描线了。</p>
<p>具体一些细节见代码。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log ^2n+q\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int, ll&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q, head[N], cnt, siz[N], top;</span><br><span class="line"><span class="type">bool</span> del[N];</span><br><span class="line">ll ans[M];</span><br><span class="line">pil buc[N], stk[N];</span><br><span class="line"><span class="type">int</span> top2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; use[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125; a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Query&gt; qr[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    a[cnt].to = v;</span><br><span class="line">    a[cnt].nxt = head[u];</span><br><span class="line">    a[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">    use[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">findroot</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> f, <span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[rt] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    pii ans = <span class="built_in">make_pair</span>(inf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[rt]; i; i = a[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i].to;</span><br><span class="line">        <span class="keyword">if</span> (del[t] || t == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">findroot</span>(t, rt, pre));</span><br><span class="line">        siz[rt] += siz[t];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, siz[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">mkp</span>(<span class="built_in">max</span>(mx, pre - siz[rt]), rt));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> f, ll s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buc[++top] = <span class="built_in">mkp</span>(rt, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[rt]; i; i = a[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i].to;</span><br><span class="line">        <span class="keyword">if</span> (t == f || del[t])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(t, rt, s + a[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = <span class="built_in">findroot</span>(rt, <span class="number">0</span>, pre).se;</span><br><span class="line">    <span class="type">int</span> res = siz[rt];</span><br><span class="line">    del[root] = <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[root]; i; i = a[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i].to;</span><br><span class="line">        <span class="keyword">if</span> (del[t])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(t, root, a[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    buc[++top] = <span class="built_in">mkp</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(buc + <span class="number">1</span>, buc + top + <span class="number">1</span>);</span><br><span class="line">    top2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = buc[i].fi;</span><br><span class="line">        ll d = buc[i].se;</span><br><span class="line">        <span class="keyword">while</span> (top2 &amp;&amp; stk[top2].se &gt; d)</span><br><span class="line">            top2--;</span><br><span class="line">        <span class="built_in">push</span>(id, stk[top2].fi);</span><br><span class="line">        stk[++top2] = buc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    top2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = buc[i].fi;</span><br><span class="line">        ll d = buc[i].se;</span><br><span class="line">        <span class="keyword">while</span> (top2 &amp;&amp; stk[top2].se &gt; d)</span><br><span class="line">            top2--;</span><br><span class="line">        <span class="built_in">push</span>(id, stk[top2].fi);</span><br><span class="line">        stk[++top2] = buc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[root]; i; i = a[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i].to;</span><br><span class="line">        <span class="keyword">if</span> (del[t])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">solve</span>(t, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ST_table</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dep[N], ind[N], lg[N &lt;&lt; <span class="number">1</span>], cnt, st[<span class="number">20</span>][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    ll de[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dep[rt] = dep[f] + <span class="number">1</span>;</span><br><span class="line">        st[<span class="number">0</span>][++cnt] = rt, ind[rt] = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[rt]; i; i = a[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = a[i].to;</span><br><span class="line">            <span class="keyword">if</span> (t == f)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            de[t] = de[rt] + a[i].w;</span><br><span class="line">            <span class="built_in">dfs</span>(t, rt);</span><br><span class="line">            st[<span class="number">0</span>][++cnt] = rt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= cnt; j++)</span><br><span class="line">                st[i][j] = <span class="built_in">cmp</span>(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++)</span><br><span class="line">            lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = ind[x], y = ind[y];</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="type">int</span> i = lg[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(st[i][x], st[i][y - p + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> de[x] + de[y] - <span class="number">2</span> * de[<span class="built_in">LCA</span>(x, y)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(i) (i &amp; -i)</span></span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            t[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, ll v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">            t[i] = <span class="built_in">min</span>(t[i], v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll ans = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, t[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">    s.<span class="built_in">init</span>();</span><br><span class="line">    T.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(l, r);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            ans[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            qr[r].<span class="built_in">emplace_back</span>((Query)&#123;l, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(use[i].<span class="built_in">begin</span>(), use[i].<span class="built_in">end</span>());</span><br><span class="line">        use[i].<span class="built_in">resize</span>(<span class="built_in">unique</span>(use[i].<span class="built_in">begin</span>(), use[i].<span class="built_in">end</span>()) - use[i].<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : use[i])</span><br><span class="line">            T.<span class="built_in">add</span>(t, s.<span class="built_in">dis</span>(t, i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : qr[i])</span><br><span class="line">            ans[t.id] = T.<span class="built_in">query</span>(t.l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>扫描线</tag>
        <tag>点分治</tag>
        <tag>支配对</tag>
      </tags>
  </entry>
  <entry>
    <title>P7603</title>
    <url>/2024/01/21/P7603/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7603">P7603 [THUPC2021]
鬼街</a></p>
<span id="more"></span>
<p>lxl 的奇妙 trick：减半警报器的模板题。</p>
<p><strong>减半警报器</strong>：维护一个数据结构，初始给定一些范围，每个范围有权值，每次操作
<span class="math inline">\((x,v)\)</span> 把包含点 <span
class="math inline">\(x\)</span> 的范围权值都减去 <span
class="math inline">\(v\)</span>，求每个范围被减到 <span
class="math inline">\(\le 0\)</span> 的最早时刻。</p>
<p>处理方式是将初始权值平均分给范围内每个点（一个点可能被多个范围分配权值），一旦有一个点的某个权值减到
<span class="math inline">\(\le 0\)</span>
就直接让这个权值对应的范围重新分配剩下的值。</p>
<p>这个 trick 的理论基础是：<span class="math inline">\(\sum_{i=1}^n
a_i=s,\max_{i=1}^n a_i\ge \dfrac{s}{n}\)</span>。</p>
<p>设范围最大为 <span
class="math inline">\(k\)</span>，对每个范围，每次都能至少减掉剩余权值的
<span class="math inline">\(\frac{1}{k}\)</span>，减 <span
class="math inline">\(\log_{\frac{k}{k-1}}\)</span> 次就能让权值 <span
class="math inline">\(\le 0\)</span>。</p>
<p>回到这道题。</p>
<p>首先，注意到 <span class="math inline">\(10^5\)</span>
内的数，质因子个数不超过 <span class="math inline">\(k=6\)</span>
个。</p>
<p>将每个监视器的 <span class="math inline">\(y\)</span>
平均分配到被监视的每个位置，对于每个质因子，需要维护一个支持全局减，查询全局最小值，删除全局最小值的数据结构。</p>
<p>开值域个优先队列即可。</p>
<p>总元素个数是 <span class="math inline">\(kn\)</span> 的，时间复杂度
<span
class="math inline">\(O(kn\log_{\frac{k}{k-1}}n\log_2n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, qn, del[N], pos[N], all;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fac[N];</span><br><span class="line">ll cnt[N], val[N];</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line">priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt;&gt; q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">using</span> t3 = tuple&lt;ll, ll, ll&gt;;</span><br><span class="line">vector&lt;t3&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (del[id])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ll v = val[id];</span><br><span class="line">    <span class="type">int</span> s = fac[pos[id]].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : fac[pos[id]])</span><br><span class="line">    &#123;</span><br><span class="line">        v -= cnt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">eb</span>(id), del[id] = <span class="number">1</span>, <span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : fac[pos[id]])</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">eb</span>(t3&#123;p, (v - <span class="number">1</span>) / s + <span class="number">1</span> + cnt[p], id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> p, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[p] += v;</span><br><span class="line">    <span class="keyword">while</span> (!q[p].<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [tot, id] = q[p].<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (tot &gt; cnt[p])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[p].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">check</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [pos, tot, id] : res)</span><br><span class="line">    &#123;</span><br><span class="line">        q[pos].<span class="built_in">push</span>(&#123;tot, id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, qn);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fac[i].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[j].<span class="built_in">eb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>, x = <span class="number">0</span>, lasans = <span class="number">0</span>;</span><br><span class="line">    ll y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (qn--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op, x, y);</span><br><span class="line">        y ^= lasans;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : fac[x])</span><br><span class="line">                <span class="built_in">check</span>(i, y);</span><br><span class="line">            <span class="built_in">stable_sort</span>(<span class="built_in">range</span>(ans));</span><br><span class="line">            <span class="built_in">write</span>(lasans = (<span class="type">int</span>)ans.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : ans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">write</span>(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ans.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            all++;</span><br><span class="line">            pos[all] = x;</span><br><span class="line">            val[all] = y;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : fac[x])</span><br><span class="line">            &#123;</span><br><span class="line">                val[all] += cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">check</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [pos, tot, id] : res)</span><br><span class="line">            &#123;</span><br><span class="line">                q[pos].<span class="built_in">push</span>(<span class="built_in">mkp</span>(tot, id));</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>减半警报器</tag>
      </tags>
  </entry>
  <entry>
    <title>240123T3</title>
    <url>/2024/01/23/240123T3/</url>
    <content><![CDATA[<p>没有链接，线下模拟赛题。</p>
<span id="more"></span>
<h2 id="题面">题面</h2>
<p>对一个不定长度的序列 <span class="math inline">\(a\)</span>
计数。这个序列有以下性质：</p>
<ul>
<li>序列之和为 <span class="math inline">\(n\)</span>。</li>
<li>序列的任意相邻两项之差的绝对值必须为 <span
class="math inline">\(1\)</span>。</li>
<li>定义序列的权值为 <span class="math inline">\(\prod_i
c^{[a_i&gt;a_{i+1}]}\)</span>。</li>
</ul>
<p>求所有合法序列的权值<strong>之和</strong>。</p>
<p><span class="math inline">\(1\le n\le 2\times 10^5\)</span>，<span
class="math inline">\(1\le c\le 10^9\)</span>。</p>
<h2 id="题解">题解</h2>
<p>限制总和，考虑根号分治。</p>
<p>对于所有数都小于 <span class="math inline">\(\sqrt{n}\)</span>
的情况，值域有根号限制。</p>
<p>对于所有数都大于 <span class="math inline">\(\sqrt{n}\)</span>
的情况，长度最长 <span class="math inline">\(\sqrt{n}\)</span>。</p>
<p>考虑两种 DP 分别计数。</p>
<p>对于所有数小于 <span
class="math inline">\(\sqrt{n}\)</span>，较为容易。</p>
<p>设 <span class="math inline">\(f(i,j)\)</span>：总和为 <span
class="math inline">\(i\)</span>，当前末尾是 <span
class="math inline">\(j\)</span>，转移： <span class="math display">\[
\begin{aligned}
&amp;f(i,j)\to f(i+j+1,j+1)\\
&amp;f(i,j)\times c\to f(i+j-1,j-1)
\end{aligned}
\]</span> 第一维 <span class="math inline">\(O(n)\)</span>，第二维 <span
class="math inline">\(O(\sqrt{n})\)</span>，复杂度可以接受。</p>
<p>其实空间上还有小优化：外层枚举 <span
class="math inline">\(i\)</span>，内层枚举的 <span
class="math inline">\(j\le \sqrt{n}\)</span>，所以可以对第一维模一个
<span class="math inline">\(O(\sqrt{n})\)</span>
的数（可能还带点常数），这样空间做到 <span
class="math inline">\(O(n)\)</span>。</p>
<p>思考第二个 DP 怎么做。</p>
<p>总和 <span class="math inline">\(O(n)\)</span>，末尾数 <span
class="math inline">\(O(n)\)</span>，长度 <span
class="math inline">\(O(\sqrt{n})\)</span>。</p>
<p>先弄点暴力的。设 <span class="math inline">\(g(i,j,k)\)</span>：前
<span class="math inline">\(i\)</span> 个，末尾 <span
class="math inline">\(j\)</span>，总和 <span
class="math inline">\(k\)</span> 的答案。 <span class="math display">\[
\begin{aligned}
&amp;g(i,j,k)\to g(i+1,j+1,k+j+1)\\
&amp;g(i,j,k)\times c\to g(i+1,j-1,k+j-1)
\end{aligned}
\]</span> 末尾和总和不能同时在状态内。</p>
<p>对于这样一个折线的计数，考虑记录距离起点的偏移量之和，并对<strong>起点</strong>转移，每次
<span class="math inline">\(i\to i+1\)</span> 的时候，和第一种 DP
相反，看作在整个序列的<strong>开头</strong>加入了一个数。</p>
<p>形式化偏移量：<span class="math inline">\(\sum a_i-a_1=\sum
a_i-i\times a_1\)</span>。</p>
<p>设 <span class="math inline">\(g(i,j)\)</span>：前 <span
class="math inline">\(i\)</span> 个，<span
class="math inline">\(j=\sum_{k} a_k-a_1\)</span> 的答案。</p>
<p>我们这里的 <span class="math inline">\(a_1\)</span>
是最后要枚举的（是为了不重不漏。我们需要最后钦定一个 <span
class="math inline">\(a_1\)</span>），所以过程中的变化量都要<strong>加到
<span class="math inline">\(j\)</span> 上</strong>。</p>
<p>也就是，要么使 <span class="math inline">\(a&#39;_1\to
a_1-1\)</span>，要么使 <span class="math inline">\(a&#39;_1\to
a_1+1\)</span>，这里 <span class="math inline">\(a&#39;_1\)</span>
是新的开头。</p>
<p>容易发现，前者会使 <span class="math inline">\(j\to
j+i\)</span>（每个都多偏移 <span
class="math inline">\(1\)</span>），后者使 <span
class="math inline">\(j\to j-i\)</span>（每个都多偏移 <span
class="math inline">\(-1\)</span>），有转移： <span
class="math display">\[
\begin{aligned}
&amp;g(i,j)\to g(i+1,j+i)\\
&amp;g(i,j)\times c\to g(i+1,j-i)
\end{aligned}
\]</span> 显然第一维可以滚掉。</p>
<p>为了防止出现负数，第二维整体位移一个 <span
class="math inline">\(O(\sqrt{n})\)</span> 的数就行，因为 <span
class="math inline">\(i\)</span> 是根号级别的。</p>
<p>对于每个长度 <span class="math inline">\(i\)</span>
要统计一次答案：先从 <span class="math inline">\(a_1=0\)</span>
开始，不断使 <span class="math inline">\(a_1\gets
a_1+1\)</span>，直到超过 <span class="math inline">\(n\)</span>。</p>
<p>总时间复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，总空间复杂度 <span
class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2005</span>][<span class="number">2005</span>], g[<span class="number">2</span>][<span class="number">300005</span>], n, c, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x = (x + y &gt;= mod ? x + y - mod : x + y); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;homework.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;homework.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">sqrt</span>(n), k2 = <span class="built_in">sqrt</span>(<span class="number">2</span> * n) + <span class="number">1</span>, k3 = <span class="built_in">sqrt</span>(<span class="number">2</span> * n + k2 * (k2 + <span class="number">1</span>)) + <span class="number">1</span>, p = k3 + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// &lt; k2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k2; i++)</span><br><span class="line">        f[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k3; j++)</span><br><span class="line">            f[(i - <span class="number">1</span>) % p][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k3; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f[i % p][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == n)</span><br><span class="line">                <span class="built_in">add</span>(ans, f[i % p][j]);</span><br><span class="line">            <span class="keyword">if</span> (i + j + <span class="number">1</span> &lt;= n)</span><br><span class="line">                <span class="built_in">add</span>(f[(i + j + <span class="number">1</span>) % p][j + <span class="number">1</span>], f[i % p][j]);</span><br><span class="line">            <span class="keyword">if</span> (i + j - <span class="number">1</span> &lt;= n &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">add</span>(f[(i + j - <span class="number">1</span>) % p][j - <span class="number">1</span>], <span class="number">1ll</span> * c * f[i % p][j] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt; k2</span></span><br><span class="line">    g[<span class="number">1</span>][k2] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k2 + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            g[p ^ <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!g[p][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + k2 + i &lt;= n)</span><br><span class="line">                <span class="built_in">add</span>(g[p ^ <span class="number">1</span>][j + k2 + i], g[p][j]);</span><br><span class="line">            <span class="keyword">if</span> (j + k2 - i &lt;= n)</span><br><span class="line">                <span class="built_in">add</span>(g[p ^ <span class="number">1</span>][j + k2 - i], <span class="number">1ll</span> * c * g[p][j] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j -= i) <span class="comment">// a[1] from 0 to the limit</span></span><br><span class="line">            <span class="built_in">add</span>(ans, g[p][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>:D:P</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4156</title>
    <url>/2024/01/23/P4156/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4156">P4156 [WC2016]
论战捆竹竿</a></p>
<span id="more"></span>
<p>对题意的初步转化较为容易，难点在后面。</p>
<p>显然，每次可以将长度增加串的任意一个周期长度。</p>
<p>设 <span class="math inline">\(P\)</span> 为 串的周期集合，<span
class="math inline">\(p\)</span> 为串的周期序列（排好序的）。</p>
<p>将全部周期列成序列 <span
class="math inline">\(p\)</span>，竹竿长度形如 <span
class="math inline">\(\sum_{i}p_ix_i\)</span>，满足 <span
class="math inline">\(\forall i,x_i\ge 0\)</span>。</p>
<p>可以用 同余最短路 通过前 6 个点，<code>bitset</code> 优化背包通过 7
到 10~12 的测试点（没写，全是目测）。</p>
<p>背包没啥前途，考虑优化最短路过程。</p>
<p>退回到 <span class="math inline">\(border\)</span> 阶段。</p>
<p>有性质：一个字符串的所有 <span class="math inline">\(border\)</span>
排序后，至少存在一种将序列划分为若干个连续段的方案，使得每个连续段均为<strong>等差数列</strong>，且段的个数为
<span class="math inline">\(O(\log |S|)\)</span>。</p>
<p><del>我测还要证明吗</del>证明：</p>
<ul>
<li>弱周期引理应该是众所周知：若 <span class="math inline">\(p,q\in
P\)</span> 且 <span class="math inline">\(p+q\le |S|\)</span>，有 <span
class="math inline">\(\gcd(p,q)\in P\)</span>。</li>
<li>考虑两个 <span class="math inline">\(|S|\)</span> 的 <span
class="math inline">\(border\)</span>：<span
class="math inline">\(a,b\)</span>，其中 <span
class="math inline">\(b\)</span> 是最长 <span
class="math inline">\(border\)</span>，<span class="math inline">\(a\ge
\frac{|S|}{2}\)</span>。</li>
<li>我们另 <span class="math inline">\(p,q\)</span> 为对应周期：<span
class="math inline">\(p=|S|-a,\,q=|S|-b\)</span>。</li>
<li>有弱周期定理，<span class="math inline">\(\gcd(p,q)\)</span> 是
<span class="math inline">\(S\)</span> 的周期，<span
class="math inline">\(|S|-\gcd(p,q)\)</span> 是 <span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(border\)</span>。</li>
<li>又因为 <span class="math inline">\(b\)</span> 是最长 <span
class="math inline">\(border\)</span>，所以 <span
class="math inline">\(\gcd(p,q)=q\)</span>，也就是 <span
class="math inline">\(q|p\)</span>。</li>
<li>由周期定义，<span class="math inline">\(k\times q\)</span> 也是
<span class="math inline">\(S\)</span> 的周期，所以 <span
class="math inline">\(|S|-k\times q\)</span> 都是 <span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(border\)</span>，因此<strong>所有长度大于等于当前串一半的
<span class="math inline">\(border\)</span> 构成等差数列</strong>。</li>
<li>我们将当前 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(border\)</span> 分为长度 <span
class="math inline">\(\ge \frac{|S|}{2}\)</span>
的和其他部分，第一部分是等差数列，第二部分继续递归。最多 <span
class="math inline">\(\log |S|\)</span> 层，得证。</li>
</ul>
<p>将不同等差数列分开处理。</p>
<p>对于 <span class="math inline">\(x,x+d,x+2d,\cdots x+kd\)</span>，设
<span class="math inline">\(k\in[1,r]\)</span>，我们在 <span
class="math inline">\(\bmod x\)</span> 下跑同余最短路，对于 <span
class="math inline">\(i\in[0,x-1]\)</span> 连 <span
class="math inline">\(i\to (i+kd)\bmod x\)</span>
的边。容易发现，最终一定会形成环，且一共有 <span
class="math inline">\(\gcd(x,d)\)</span> 个环，我们对每个环分开做。</p>
<p>考虑 <span class="math inline">\(dis\)</span> 最小的点 <span
class="math inline">\(p\)</span>，注意到<strong>不存在跨过 <span
class="math inline">\(p\)</span> 的松弛操作</strong>（不然为啥不以 <span
class="math inline">\(p\)</span> 为起点），因此可以在 <span
class="math inline">\(p\)</span> 处断环为链，同时忽略跨过 <span
class="math inline">\(p\)</span> 的边。容易发现，<strong>图变成了
DAG</strong>，只要遵循拓扑序，就可以使用看起来并不图论的方式做松弛<del>比如单调队列</del>。</p>
<p>对于一般的同余最短路，如果我们可以单次增长 <span
class="math inline">\(l\)</span>，<span class="math inline">\(i\to
(i+l)\bmod x\)</span> 的边权应为 <span
class="math inline">\(l\)</span>，容易发现，这里<strong>第 <span
class="math inline">\(i\)</span> 个点</strong>到<strong>第 <span
class="math inline">\(j\)</span> 个点</strong>连边的边权应该为 <span
class="math inline">\(x+(j-i)\times d\)</span>，注意第 <span
class="math inline">\(i\)</span> 个点和点 <span
class="math inline">\(i\)</span> 是有区别的。</p>
<p>因此，对于每个 <span class="math inline">\(i\)</span>，算出 <span
class="math inline">\(j=i-k,k\in[1,r]\)</span> 中最小的 <span
class="math inline">\(dis(i)+(j-i)\times d+x\)</span>（<span
class="math inline">\(dis\)</span>
就是最短路），对于每个点找滑动窗口内最小值，只需要用单调队列维护即可。</p>
<p>同一个等差数列内，环和环之间的信息合并是简单的，对 <span
class="math inline">\(dis\)</span> 不断取 <span
class="math inline">\(\min\)</span> 就行。</p>
<p>现在考虑怎么从一个等差数列转移到另一个等差数列上，设两个等差数列分别形如
<span class="math inline">\(a_1+kd_1\)</span> 和 <span
class="math inline">\(a_2+kd_2\)</span>，需要用 <span
class="math inline">\(dis(i)\)</span> 更新 <span
class="math inline">\((dis(i)+ka_1)\bmod a_2\)</span>
的答案，容易发现和上面环和环之间本质相同，拆成 <span
class="math inline">\(\gcd(a_1,a_2)\)</span>
个环，环内从最小值开始维护前缀最小值更新即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，<span
class="math inline">\(\log\)</span> 来自等差数列个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll Len;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> nxt[N], border[N], que[N], seq[N], pos[N], tp, tot, cur;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    <span class="built_in">memset</span>(border, <span class="number">0</span>, <span class="built_in">sizeof</span>(border));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span> &amp;&amp; s[p + <span class="number">1</span>] != s[i])</span><br><span class="line">            p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span> (s[p + <span class="number">1</span>] == s[i])</span><br><span class="line">            p++;</span><br><span class="line">        nxt[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = nxt[n];</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        border[++tot] = n - p;</span><br><span class="line">        p = nxt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    border[++tot] = n;</span><br><span class="line">&#125;</span><br><span class="line">ll dis[N], res[N], sta[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chgmod</span><span class="params">(<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = __gcd(mod, cur);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cur - <span class="number">1</span>) res[i] = dis[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, mod - <span class="number">1</span>) dis[i] = INF;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cur - <span class="number">1</span>) dis[res[i] % mod] = <span class="built_in">min</span>(dis[res[i] % mod], res[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cnt - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tp = <span class="number">0</span>;</span><br><span class="line">        que[++tp] = i;</span><br><span class="line">        <span class="type">int</span> p = (i + cur) % mod;</span><br><span class="line">        <span class="keyword">while</span> (p != que[<span class="number">1</span>])</span><br><span class="line">            que[++tp] = p, p = (p + cur) % mod;</span><br><span class="line">        <span class="built_in">rep</span>(j, tp + <span class="number">1</span>, tp * <span class="number">2</span>) que[j] = que[j - tp];</span><br><span class="line">        tp *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, tp) dis[que[j]] = <span class="built_in">min</span>(dis[que[j]], dis[que[j - <span class="number">1</span>]] + cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> dif, <span class="type">int</span> siz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = __gcd(now, dif);</span><br><span class="line">    <span class="built_in">chgmod</span>(now);</span><br><span class="line">    <span class="keyword">if</span> (dif &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cnt - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tp = <span class="number">0</span>;</span><br><span class="line">        que[++tp] = i;</span><br><span class="line">        <span class="type">int</span> tmp = (i + dif) % now;</span><br><span class="line">        <span class="keyword">while</span> (tmp != que[<span class="number">1</span>])</span><br><span class="line">            que[++tp] = tmp, tmp = (tmp + dif) % now;</span><br><span class="line">        <span class="type">int</span> minpos = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">re</span>(j, tp) <span class="keyword">if</span> (dis[que[j]] &lt; dis[que[minpos]]) minpos = j;</span><br><span class="line">        <span class="type">int</span> tmpcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, minpos, tp) seq[++tmpcnt] = que[j];</span><br><span class="line">        <span class="built_in">re</span>(j, minpos - <span class="number">1</span>) seq[++tmpcnt] = que[j];</span><br><span class="line">        <span class="type">int</span> hd = <span class="number">1</span>, tl = <span class="number">1</span>;</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>, sta[<span class="number">1</span>] = dis[seq[<span class="number">1</span>]] - dif;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, tp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (hd &lt;= tl &amp;&amp; pos[hd] + siz &lt; j)</span><br><span class="line">                hd++;</span><br><span class="line">            <span class="keyword">if</span> (hd &lt;= tl)</span><br><span class="line">                dis[seq[j]] = <span class="built_in">min</span>(dis[seq[j]], sta[hd] + j * <span class="number">1ll</span> * dif + now);</span><br><span class="line">            <span class="keyword">while</span> (hd &lt;= tl &amp;&amp; sta[tl] &gt;= dis[seq[j]] - j * <span class="number">1ll</span> * dif)</span><br><span class="line">                tl--;</span><br><span class="line">            sta[++tl] = dis[seq[j]] - j * <span class="number">1ll</span> * dif, pos[tl] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Len;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    Len -= n;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cur = n;</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= tot; i = j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (border[j + <span class="number">1</span>] - border[j] == border[i + <span class="number">1</span>] - border[i])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="built_in">work</span>(border[i], border[i + <span class="number">1</span>] - border[i], j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cur - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt;= Len)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += (Len - dis[i]) / cur + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Strin</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1762E</title>
    <url>/2024/01/24/CF1762E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1762E">Tree Sum</a></p>
<span id="more"></span>
<p>题意：一个 <span class="math inline">\(n\)</span>
个点的有边权树，边权 <span
class="math inline">\(\{-1,1\}\)</span>，定义两点之间距离为边权和，求全部情况中
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的距离之和。</p>
<p>设 <span class="math inline">\(g(u)=\prod_{(v,u)\in
E}w(u,v)\)</span>。</p>
<p>思考对于一个形态固定的树，如何染边。</p>
<p>结论一：<span class="math inline">\(n\)</span> 为奇数时答案为 <span
class="math inline">\(0\)</span>。</p>
<p>证明：有 <span
class="math inline">\(\prod_{u}g(u)=(-1)^{n}\)</span>，注意这里全是乘法，允许对每条边拆贡献，容易发现一条边会贡献两次，<span
class="math inline">\(\prod_{u}g(u)=\prod_{(u,v)\in
E}w(u,v)^2=1\)</span> 显然恒成立，当 <span class="math inline">\(n\bmod
2=1\)</span> 的时候存在矛盾。</p>
<p>相邻的边相关的性质，最特殊的当然是叶子。考虑经典的剥叶子套路。</p>
<p>结论二：形态确定的偶数个点的树，染色方案为 <span
class="math inline">\(1\)</span>。</p>
<p>证明：叶子到父亲的边显然需要染 <span
class="math inline">\(-1\)</span>，继续向上，父亲需要根据有几个叶子决定染什么颜色，显然这个决定是唯一的，可以看作每次删去一层叶子。</p>
<p>结论三：对于合法方案中 <span class="math inline">\(w(u,v)=1\)</span>
的边 <span class="math inline">\((u,v)\)</span>，删去不影响合法性。</p>
<p>证明：显然。</p>
<p>于是可以设计计数过程：删去某条边，并钦定点 <span
class="math inline">\(1\)</span> 所在的连通块大小，保证不重不漏。</p>
<p>显然删去的这条边一定出现在 <span class="math inline">\(1\)</span> 到
<span class="math inline">\(n\)</span> 的路径上。</p>
<p>设点 <span class="math inline">\(1\)</span> 所在连通块大小为 <span
class="math inline">\(i\)</span>，点 <span
class="math inline">\(n\)</span> 所在连通块大小为 <span
class="math inline">\(n-i\)</span>。</p>
<ul>
<li>删边方案为两连通块中任意两点，贡献 <span
class="math inline">\(i\times (n-i)\)</span>。</li>
<li>当 <span class="math inline">\(i\)</span>
为奇数的时候，显然断掉的这条边权值必须为 <span
class="math inline">\(-1\)</span>，相当于为两个连通块各自贡献了一个点；反之如果是偶数，边权只能是
<span class="math inline">\(1\)</span>。</li>
<li>可以选择剩余 <span class="math inline">\(n-2\)</span> 个点中 <span
class="math inline">\(i-1\)</span> 个点和 <span
class="math inline">\(i\)</span> 连通，方案数 <span
class="math inline">\(\binom{n-2}{i-1}\)</span>。</li>
<li>两侧需要计数全部生成树个数，根据 <span
class="math inline">\(\textrm{Prufer}\)</span> 序列，贡献为 <span
class="math inline">\(i^{i-2}\times (n-i)^{n-i-2}\)</span>。</li>
</ul>
<p>可以看作，对于每条路径上的边，算出了这条边在每个形态的树中的总贡献系数，然后再乘上边权。</p>
<p>答案为： <span class="math display">\[
\sum_{i=1}^{n-1}(-1)^i\binom{n-2}{i-1}i^{i-1}(n-i)^{n-i-1}
\]</span> 时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ret=<span class="number">1ll</span>*((i&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>)*<span class="built_in">C</span>(n<span class="number">-2</span>,i<span class="number">-1</span>)%mod*<span class="built_in">qpow</span>(i,i<span class="number">-1</span>)%mod*<span class="built_in">qpow</span>(n-i,n-i<span class="number">-1</span>)%mod;</span><br><span class="line">        ans=((ans+ret)%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>P5984</title>
    <url>/2024/01/25/P5984/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5984">P5984 [PA2019]
Podatki drogowe</a></p>
<span id="more"></span>
<p>看到第 <span class="math inline">\(k\)</span>
小，路径，容易得到一个二分套点分治的大体思路。</p>
<p>先考虑怎么表示一个巨大的数：有经典题 <a
href="https://www.luogu.com.cn/problem/CF464E">The Classic
Problem</a>。可以用线段树维护这样的高精度数字，比较两个数字大小，需要线段树维护哈希值，找第一个（最高位的）对应数位不同的位置，单次是
<span class="math inline">\(O(\log n)\)</span> 的。</p>
<p>对于两个数的加法，注意到一个数最多是 <span
class="math inline">\(n-1\)</span> 个 <span
class="math inline">\(n^z\)</span> 之和，对于这个 <span
class="math inline">\(n\)</span> 进制的数，不会出现进位。</p>
<p>为了后面思路更自然，代码更好写，采用边分治，核心思路无影响。</p>
<p>我们可以将每个分治中心两侧的路径集合排序。对于分布在两侧的路径 <span
class="math inline">\(x,y\)</span>，满足 <span
class="math inline">\(w(x)+w(y)\le K\)</span> 的 <span
class="math inline">\(y\)</span> 对于 <span
class="math inline">\(x\)</span>
来说，是一个前缀，且排序后显然存在单调性。也就是说，只需要简单双指针，就可以得到每个
<span class="math inline">\(x\)</span> 的 <span
class="math inline">\(y\)</span>
前缀有多长。加起来统计出：当前分治中心处理的路径中，权值 <span
class="math inline">\(\le K\)</span> 的路径条数，也就是权值为 <span
class="math inline">\(K\)</span> 路径的<strong>排名</strong>。</p>
<p>设上文中这个前缀的长度为 <span
class="math inline">\(F(i,x,K)\)</span>，<span
class="math inline">\(i\)</span> 代表分支中心编号。</p>
<p>边分治不需要“在线”做，对于每个分治中心，两侧的“路径的一半”的权值（线段树的树根）存进
<code>vector</code> 中，并直接排序，方便二分过程。</p>
<p>那二分怎么做呢？</p>
<p>可能会想到二分排名，虽然我们可以根据路径算排名，但是根据排名算路径是很难的。</p>
<p>考虑二分路径——路径还能二分？</p>
<p>很难想到，可以随机化。</p>
<p>维护 <span class="math inline">\(L(i,j),R(i,j)\)</span>
表示，在之前的过程中，我们得到了这样的信息：在分治中心 <span
class="math inline">\(i\)</span> 中，第 <span
class="math inline">\(k\)</span> 小的路径需要满足： 第 <span
class="math inline">\(j\)</span>
个“路径的一半”可以在分治块的另一半中找到长度<strong>至少</strong>为
<span class="math inline">\(L(i,j)\)</span> 的 <span
class="math inline">\(y\)</span>
前缀，可以找到长度<strong>至多</strong>为 <span
class="math inline">\(R(i,j)\)</span> 的 <span
class="math inline">\(y\)</span> 前缀。</p>
<p>在当前 <span class="math inline">\([l,r]\)</span>
中随机出一个路径的下标 <span
class="math inline">\(idx\in[1,lim]\)</span>，并根据这个下标找到对应路径，容易发现，<span
class="math inline">\(R(i,j)-L(i,j)+1\)</span> 就是 <span
class="math inline">\(j\)</span> 可以在下标中贡献的路径条数。</p>
<p>值得一提，分治块之间并没有排序，这里求出的路径并不是第 <span
class="math inline">\(idx\)</span>
小的路径，只是这个下标对应的路径而已。</p>
<p>算出路径的排名，根据排名和 <span class="math inline">\(k\)</span>
的关系变动当前 <span class="math inline">\(L,R,lim\)</span> 即可。<span
class="math inline">\(lim\)</span> 可以看作根据 <span
class="math inline">\(L,R\)</span> 不断动态维护的 <span
class="math inline">\(\sum_{i,j} R(i,j)-L(i,j)+1\)</span>。</p>
<p>复杂度分析：</p>
<p>边分治，一共 <span class="math inline">\(O(\log n)\)</span> 层，共计
<span class="math inline">\(O(n\log n)\)</span>
个点需要排序，排序单次比较复杂度 <span class="math inline">\(O(\log
n)\)</span>，预处理加排序的总复杂度为 <span
class="math inline">\(O(n\log^3 n)\)</span>。</p>
<p>后续处理答案，随机 <span class="math inline">\(t\)</span>
次，期望复杂度为 <span class="math inline">\(O(\log
n)\)</span>，为了保底大概 <span class="math inline">\(t\in
[50,60]\)</span>
答案比较准；每次要枚举每个分治块（边分树上子树大小之和），双指针过程中，指针移动一次需要比较一次，需要
<span class="math inline">\(O(\log n)\)</span>，总复杂度 <span
class="math inline">\(O(tn\log ^2 n)\)</span>。</p>
<p>总复杂度为 <span class="math inline">\(O(n\log ^3 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, center;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rt1[N * <span class="number">4</span>], rt2[N * <span class="number">4</span>];</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> Main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> le[NN], ri[NN], siz[NN], cnt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tree[NN], val[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> loc, <span class="type">int</span> y, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loc &lt; l || loc &gt; r)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="type">int</span> i = ++cnt;</span><br><span class="line">        tree[i] = tree[y] + val[loc];</span><br><span class="line">        siz[i] = siz[y] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l != r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            le[i] = <span class="built_in">insert</span>(loc, le[y], l, mid);</span><br><span class="line">            ri[i] = <span class="built_in">insert</span>(loc, ri[y], mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l != r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[ri[a]] + tree[ri[b]] != tree[ri[c]] + tree[ri[d]])</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                a = ri[a], b = ri[b], c = ri[c], d = ri[d];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">                a = le[a], b = le[b], c = le[c], d = le[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> siz[a] + siz[b] &lt; siz[c] + siz[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ccmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(x, <span class="number">0</span>, y, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; L[N * <span class="number">4</span>], R[N * <span class="number">4</span>], pos[N * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y)</span><br><span class="line">        &#123;</span><br><span class="line">            x = _x, y = _y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;b) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cmp</span>(x, y, b.x, b.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans, base = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> md = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            base = base * n % md;</span><br><span class="line">            ans = (ans + (siz[x] + siz[y]) * base) % md;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Get</span>(le[x], le[y], l, mid);</span><br><span class="line">        <span class="built_in">Get</span>(ri[x], ri[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lim = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= center; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L[i].<span class="built_in">resize</span>(rt1[i].<span class="built_in">size</span>());</span><br><span class="line">            R[i].<span class="built_in">resize</span>(rt1[i].<span class="built_in">size</span>());</span><br><span class="line">            pos[i].<span class="built_in">resize</span>(rt1[i].<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : R[i])</span><br><span class="line">                it = rt2[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            lim += <span class="number">1ll</span> * rt1[i].<span class="built_in">size</span>() * rt2[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node <span class="title">mid</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">60</span>; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> idx = <span class="built_in">rnd</span>() % lim + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; idx &amp;&amp; i &lt;= center; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; rt1[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = R[i][j] - L[i][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt;= idx)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mid = <span class="built_in">node</span>(rt1[i][j], rt2[i][L[i][j] + idx - <span class="number">1</span>]);</span><br><span class="line">                        idx = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        idx -= tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= center; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> r = rt2[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; rt1[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = <span class="built_in">min</span>(r, R[i][j]);</span><br><span class="line">                    <span class="keyword">while</span> (r &gt;= L[i][j] &amp;&amp; mid &lt; <span class="built_in">node</span>(rt1[i][j], rt2[i][r]))</span><br><span class="line">                        r--;</span><br><span class="line">                    pos[i][j] = r;</span><br><span class="line">                    tmp += r - L[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                lim = tmp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= center; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; rt1[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                        R[i][j] = pos[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k -= tmp;</span><br><span class="line">                lim -= tmp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= center; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; rt1[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                        L[i][j] = pos[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Get</span>(mid.x, mid.y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ver[N * <span class="number">4</span>], ne[N * <span class="number">4</span>], head[N * <span class="number">2</span>], cnt = <span class="number">1</span>, val[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ver[++cnt] = y;</span><br><span class="line">        ne[cnt] = head[x];</span><br><span class="line">        head[x] = cnt;</span><br><span class="line">        val[cnt] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; son[N];</span><br><span class="line">    <span class="type">int</span> las[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : son[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = it.first;</span><br><span class="line">            <span class="keyword">if</span> (u == fi)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init</span>(u, x);</span><br><span class="line">            <span class="keyword">if</span> (!las[x])</span><br><span class="line">                <span class="built_in">link</span>(x, u, it.second), <span class="built_in">link</span>(u, x, it.second), las[x] = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">link</span>(las[x], ++m, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">link</span>(m, las[x], <span class="number">0</span>);</span><br><span class="line">                las[x] = m;</span><br><span class="line">                <span class="built_in">link</span>(las[x], u, it.second);</span><br><span class="line">                <span class="built_in">link</span>(u, las[x], it.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> siz[N * <span class="number">2</span>], mxp[N * <span class="number">2</span>], root;</span><br><span class="line">    <span class="type">bool</span> vis[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findrt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fi, <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || u == fi)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">findrt</span>(u, x, tot);</span><br><span class="line">            siz[x] += siz[u];</span><br><span class="line">            mxp[i &gt;&gt; <span class="number">1</span>] = <span class="built_in">max</span>(tot - siz[u], siz[u]);</span><br><span class="line">            <span class="keyword">if</span> (mxp[root] &gt; mxp[i &gt;&gt; <span class="number">1</span>])</span><br><span class="line">                root = (i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rt[N * <span class="number">2</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= n)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(rt[x]);</span><br><span class="line">        siz[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || u == fi)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rt[u] = Main::<span class="built_in">insert</span>(val[i], rt[x]);</span><br><span class="line">            <span class="built_in">dfs</span>(u, x);</span><br><span class="line">            siz[x] += siz[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mxp[root = <span class="number">0</span>] = m;</span><br><span class="line">        <span class="built_in">findrt</span>(x, x, tot);</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[root &lt;&lt; <span class="number">1</span>] = vis[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> U = ver[root &lt;&lt; <span class="number">1</span>], V = ver[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        ++center;</span><br><span class="line">        rt[U] = <span class="number">0</span>;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(U, V);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), Main::ccmp);</span><br><span class="line">        <span class="built_in">swap</span>(rt1[center], vec);</span><br><span class="line">        rt[V] = Main::<span class="built_in">insert</span>(val[root &lt;&lt; <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(V, U);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), Main::ccmp);</span><br><span class="line">        <span class="built_in">swap</span>(rt2[center], vec);</span><br><span class="line">        <span class="built_in">solve</span>(U, siz[U]);</span><br><span class="line">        <span class="built_in">solve</span>(V, siz[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            Main::val[i] = <span class="built_in">rnd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;v);</span><br><span class="line">            son[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y, v));</span><br><span class="line">            son[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, v));</span><br><span class="line">        &#125;</span><br><span class="line">        m = n;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    Init::<span class="built_in">main</span>();</span><br><span class="line">    Main::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>点分治</tag>
        <tag>随机化</tag>
        <tag>边分治</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC125E</title>
    <url>/2024/01/25/ARC125E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc125_e">[ARC125E]
Snack</a></p>
<span id="more"></span>
<p>有一个 trick 集合为此题超集的题目：<a
href="https://h01yshhmy.github.io/2023/12/11/ABC332G/">ABC332G |
h01yshhmy</a>，写这篇是因为想的时间实在有点长。</p>
<p>网络流模型容易得到。</p>
<ul>
<li>源点流零食 <span class="math inline">\(i\)</span>，流量 <span
class="math inline">\(a_i\)</span>。</li>
<li>零食 <span class="math inline">\(i\)</span> 流小孩 <span
class="math inline">\(j\)</span>，流量 <span
class="math inline">\(b_j\)</span>。</li>
<li>小孩 <span class="math inline">\(i\)</span> 流汇点，流量 <span
class="math inline">\(c_i\)</span>。</li>
</ul>
<p>答案为最大流。</p>
<p>最大流转最小割，考虑割边决策。</p>
<p>先枚举源点到每个零食的边是否割掉，设保留了 <span
class="math inline">\(k\)</span> 个零食。</p>
<p>容易发现，每个小孩有两种决策，要么把从这 <span
class="math inline">\(k\)</span>
个零食连过来的边全割掉，要么割自己到汇点的边，这个代价为 <span
class="math inline">\(\min(kb_i,c_i)\)</span>，注意零食到小孩的流量和小孩编号相关。</p>
<p>因为此图形态较为特殊，可以将全局的最优化问题分成小问题。</p>
<p>容易发现这个决策和这 <span class="math inline">\(k\)</span>
个零食具体是哪个无关，贪心的想，显然优先断掉 <span
class="math inline">\(a_i\)</span> 更小的。先将 <span
class="math inline">\(a\)</span> 升序排序，每次选的 <span
class="math inline">\(k\)</span> 个是 <span
class="math inline">\(a\)</span> 上的一个前缀。</p>
<p>容易发现，随着 <span class="math inline">\(k\)</span> 的增长，每个
<span class="math inline">\(\min(kb_i,c_i)\)</span>
的图像会出现拐点，且只有一个拐点，后续贡献恒为 <span
class="math inline">\(c_i\)</span>。</p>
<p>我们按照 <span class="math inline">\(\frac{c_i}{b_i}\)</span>
升序遍历小孩，显然当前贡献为 <span class="math inline">\(kb_i\)</span>
的部分一定是这个遍历序列的一段前缀，用指针维护这个前缀即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, b[N], p[N];</span><br><span class="line">ll a[N], c[N], f[N], ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="built_in">re</span>(i, n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">re</span>(i, m) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">re</span>(i, m) <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">re</span>(i, m)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = c[i] / b[i] + <span class="number">1</span>, p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="built_in">greater</span>&lt;ll&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + m + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">         &#123; <span class="keyword">return</span> f[x] &lt; f[y]; &#125;);</span><br><span class="line">    ll as = <span class="built_in">accumulate</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">0ll</span>), cs = <span class="number">0</span>, bs = <span class="built_in">accumulate</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>, <span class="number">0ll</span>);</span><br><span class="line">    ans = as;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>, j = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        as -= a[k], cs += bs;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= m &amp;&amp; f[p[j]] &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cs -= <span class="number">1ll</span> * k * b[p[j]] - c[p[j]], bs -= b[p[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, as + cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最大流最小割</tag>
        <tag>网络流</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1715E</title>
    <url>/2024/01/25/CF1715E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1715E">Long Way
Home</a></p>
<span id="more"></span>
<p>是 <a href="https://h01yshhmy.github.io/2023/12/02/U169078/">U169078
| h01yshhmy</a> 的严格加强版。</p>
<p>考虑每次“加入”一个 <span class="math inline">\((u-v)^2\)</span>
的贡献。</p>
<p>首先，跑一次 <span class="math inline">\(k=0\)</span>
时的最短路，得到初始 <span class="math inline">\(dis\)</span> 数组。</p>
<p>然后，<strong>暴力更新</strong>即可。有转移式子： <span
class="math display">\[
\begin{aligned}
dis(u)=\min_{v=1}^ndis(v)+(u-v)^2
\end{aligned}
\]</span> 考虑两个 <span class="math inline">\(v:p,q\)</span>，其中
<span class="math inline">\(p\)</span> 比 <span
class="math inline">\(q\)</span> 更优，钦定 <span
class="math inline">\(p&gt;q\)</span>： <span class="math display">\[
\begin{aligned}
&amp;dis(p)+(u-p)^2&lt;dis(q)+(u-q)^2\\
&amp;dis(p)-2up+p^2&lt;dis(q)-2uq+q^2\\
&amp;\frac{(dis(p)+p^2)-(dis(q)+q^2)}{p-q}&lt; 2u
\end{aligned}
\]</span> 单调队列维护凸壳，在 DP 过程中记录被更新的 <span
class="math inline">\(dis(u)\)</span>，从这些 <span
class="math inline">\(u\)</span> 开始跑。</p>
<p>当然也可以全跑一遍，不影响复杂度。</p>
<p>时间复杂度 <span class="math inline">\(O(km\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7232</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N], sum[N], z;</span><br><span class="line"><span class="type">short</span> vis[N];</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">long</span> <span class="type">long</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].nxt = h[u];</span><br><span class="line">    h[u] = cnt;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> llt &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; x.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tmp;</span><br><span class="line">priority_queue&lt;llt&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span> (!p.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[tmp.id])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[tmp.id] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[tmp.id]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[e[i].v] &gt; dis[tmp.id] + e[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e[i].v] = dis[tmp.id] + e[i].w;</span><br><span class="line">                p.<span class="built_in">push</span>((llt)&#123;e[i].v, dis[e[i].v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q[N &lt;&lt; <span class="number">4</span>], head = <span class="number">1</span>, tail = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000000732.0</span>;</span><br><span class="line">    <span class="keyword">return</span> (sum[i] + (<span class="number">1ll</span>) * i * i - sum[j] - (<span class="number">1ll</span>) * j * j) * <span class="number">1.0</span> / (i - j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;x, &amp;y, &amp;z), <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    p.<span class="built_in">push</span>((llt)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tail = <span class="number">1</span>;</span><br><span class="line">        q[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sum[i] = dis[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; <span class="built_in">slope</span>(q[tail - <span class="number">1</span>], q[tail]) &gt; <span class="built_in">slope</span>(q[tail - <span class="number">1</span>], i))</span><br><span class="line">                --tail;</span><br><span class="line">            q[++tail] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; <span class="built_in">slope</span>(q[head], q[head + <span class="number">1</span>]) &lt; <span class="number">2.0</span> * i)</span><br><span class="line">                ++head;</span><br><span class="line">            <span class="type">int</span> j = q[head];</span><br><span class="line">            <span class="keyword">if</span> (dis[i] &gt; sum[j] + (i - j) * (i - j))</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i] = sum[j] + (<span class="number">1ll</span>) * (i - j) * (i - j);</span><br><span class="line">                p.<span class="built_in">push</span>((llt)&#123;i, dis[i]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dij</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ Round</title>
    <url>/2024/01/28/UOJ-Round-19-A/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/contest/51/problem/513">【UR
#19】清扫银河</a></p>
<span id="more"></span>
<p>我们称不能通行的边为 <span class="math inline">\(1\)</span>
边，最终目标得到全 <span class="math inline">\(0\)</span> 边的图。</p>
<p>首先，完全相同的操作最多执行一次。</p>
<p>考虑操作一，众所周知，无向图所有简单环都可以通过“极小环”异或得到，这里的“极小环”指
DFS 树上只含一条非树边的环。显然这样的环只有 <span
class="math inline">\(m-n+1\)</span> 个。</p>
<p>考虑操作二，发现我们还能剩下 <span class="math inline">\(n\)</span>
次操作，不如直接简化，每次只翻转一个单点相邻的边。</p>
<p>都是一样的思想，将范围大的操作无损拆成小的，减少操作方案数。</p>
<p>正好 <span class="math inline">\(m+1\)</span>
次操作，可以忽略操作次数限制。</p>
<p>我们可以列出一些异或方程组，一共 <span
class="math inline">\(m+1\)</span> 个变量，复杂度过高。</p>
<p>将操作二全部做完再考虑操作一，容易发现，操作一可以将子图中全部边都异或成
<span class="math inline">\(0\)</span>，当且仅当子图中每个点 <span
class="math inline">\(1\)</span>
权边度数均为偶数。不难通过欧拉回路的思路得到。</p>
<p>问题变为能否通过操作二将全部点的 <span
class="math inline">\(1\)</span> 权边度数变为偶数。<span
class="math inline">\(n\)</span> 个变量 <span
class="math inline">\(n\)</span>
个方程，高斯消元解异或方程组即可，或者线性基：将每种操作二表示为 <span
class="math inline">\(n\)</span> 维 <span
class="math inline">\(0/1\)</span> 向量（根据相邻 <span
class="math inline">\(1\)</span> 边个数奇偶性），判断这 <span
class="math inline">\(n\)</span> 个向量能否线性表示出全 <span
class="math inline">\(0\)</span>。</p>
<p>使用 <code>bitset</code> 加速，时间复杂度 <span
class="math inline">\(O(\frac{n^3}{\omega})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V, E;</span><br><span class="line">bitset&lt;N&gt; G[N], lb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(bitset&lt;N&gt; &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x._Find_first(); i != N; i = x._Find_first()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lb[i].<span class="built_in">none</span>()) <span class="keyword">return</span> lb[i] = x, <span class="literal">true</span>;</span><br><span class="line">    x ^= lb[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, u, v, w;</span><br><span class="line">  cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= V; ++i) G[i].<span class="built_in">reset</span>(), lb[i].<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, G[u].<span class="built_in">set</span>(v), G[v].<span class="built_in">set</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (w) G-&gt;<span class="built_in">flip</span>(u), G-&gt;<span class="built_in">flip</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= V; ++i) <span class="built_in">insert</span>(G[i].<span class="built_in">set</span>(i, G[i].<span class="built_in">count</span>() &amp; <span class="number">1</span>));</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">insert</span>(G[<span class="number">0</span>]) ? <span class="string">&quot;no\n&quot;</span> : <span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (cin &gt;&gt; T; T; --T) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
</search>
