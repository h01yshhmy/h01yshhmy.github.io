<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABC127E</title>
    <url>/2023/12/01/ABC127E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc127_e">[ABC127E] Cell
Distance</a></p>
<span id="more"></span>
<p>首先发现行和列可以拆开算。</p>
<p>考虑拆贡献，计算行上两点距离为 <span class="math inline">\(i\)</span>
的线段的个数：<span class="math inline">\((n-i)\times
m^2\)</span>，单个对答案的贡献为 <span
class="math inline">\(i\)</span>。</p>
<p>因为距离为 <span class="math inline">\(i\)</span> 的线段可以放 <span
class="math inline">\(n-i\)</span> 个，然后两个点的 <span
class="math inline">\(y\)</span> 值随便取，共 <span
class="math inline">\(m^2\)</span> 种。</p>
<p>列同理。</p>
<p>最终答案为：</p>
<p><span
class="math inline">\((m^2\times\sum\limits_{i=1}^{n-1}i(n-i)+n^2\times\sum\limits_{i=1}^{m-1}i(m-i))\dbinom{n\times
m-2}{k-2}\)</span></p>
<p>最后的组合数：剩下的 <span class="math inline">\(k-2\)</span> 个点在
<span class="math inline">\(n\times m-2\)</span> 个空位内随意选。</p>
<p>此类算全部总方案的题一般都是拆贡献。不要考虑最终点的分布，想最好算的（两个点情况）然后数出所有可能就好了。</p>
<p>一项内一般只贡献一个小部分的答案，不会出现重复计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=inv[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[m]%Mod*inv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*i*(n-i)%Mod*m%Mod*m%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*i*(m-i)%Mod*n%Mod*n%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*<span class="built_in">C</span>(n*m<span class="number">-2</span>,k<span class="number">-2</span>)%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC132F</title>
    <url>/2023/12/01/ABC132F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc132_f">[ABC132F]
Small Products</a></p>
<span id="more"></span>
<p>虽然 <span class="math inline">\(n\)</span>
很大，但是还是考虑DP。</p>
<p>朴素的DP很好得到：</p>
<p><span class="math inline">\(f[i][j]\)</span> 表示长度 <span
class="math inline">\(i\)</span> 为的序列，序列末尾的数为 <span
class="math inline">\(j\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=\sum_{v=1}^{\lfloor\frac{n}{j}\rfloor}f[i-1][v]\\
&amp;g[i][j]=\sum_{v=1}^jf[i][v]\\
&amp;f[i][j]=g[i-1][\lfloor\frac{n}{j}\rfloor]\\
\end{aligned}
\]</span></p>
<p>（有时候填表法和刷表法都要写一写，笔者一直在考虑刷表的倍数形式
导致这题没做出来/ng）</p>
<p>即使前缀和优化，时空复杂度也均为 <span
class="math inline">\(O(nk)\)</span>，过不去。</p>
<p>看到这个分数下取整，可以想到一些根号算法：数论分块。</p>
<p>怎么做呢？</p>
<p>发现，如果有 <span
class="math inline">\(\lfloor\frac{n}{u}\rfloor=\lfloor\frac{n}{v}\rfloor\)</span>，那么
<span class="math inline">\(f[i][u]=f[i][v]\)</span>。</p>
<p>所以我们可以把每一种 <span
class="math inline">\(\lfloor\frac{n}{j}\rfloor\)</span>合并到一个<code>DP</code>状态里。</p>
<p>预处理出每一段的长度，转移时乘上长度即可。</p>
<p>设 <span class="math inline">\(cnt\)</span> 为块的个数，<span
class="math inline">\(f[i][j]\)</span> 为长度为<span
class="math inline">\(i\)</span>，最后一块的 <span
class="math inline">\(\lfloor\frac{n}{x}\rfloor=j\)</span>。</p>
<p>转移式子：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=len[j]\times g[i-1][cnt-j+1]\\
&amp;g[i][j]=g[i][j-1]+f[i][j]
\end{aligned}
\]</span></p>
<p><span class="math inline">\(cnt-j+1\)</span> 为 <span
class="math inline">\(\left\lfloor\dfrac{n}{\lfloor\frac{n}{x}\rfloor}\right\rfloor\)</span>
的编号，显然这是当前值为 <span
class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span>
的枚举上界。（数论分块值域乘除和编号加减相关，并左右对称）</p>
<p>时空复杂度均为 <span
class="math inline">\(O(k\sqrt{n})\)</span>，可以通过。</p>
<p>由于一些原因，数论分块的数组最好开二倍根号以上的空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">105</span>)</span>,<span class="title">sqN</span><span class="params">(<span class="number">80000</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[N][sqN],g[N][sqN];</span><br><span class="line"><span class="type">int</span> len[sqN],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),n);</span><br><span class="line">        len[++cnt]=r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        f[<span class="number">1</span>][i]=len[i];</span><br><span class="line">        g[<span class="number">1</span>][i]=(g[<span class="number">1</span>][i<span class="number">-1</span>]+f[<span class="number">1</span>][i])%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,cnt)&#123;</span><br><span class="line">            f[i][j]=len[j]*g[i<span class="number">-1</span>][cnt-j+<span class="number">1</span>]%Mod;</span><br><span class="line">            g[i][j]=(g[i][j<span class="number">-1</span>]+f[i][j])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;g[k][cnt]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>我会根号</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC242F</title>
    <url>/2023/12/01/ABC242F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc242_f">[ABC242F]
Black and White Rooks</a></p>
<span id="more"></span>
<p>计数，先考虑放车的性质。</p>
<p>发现题目的要求实质上是：同一行/列内只能有一种颜色。</p>
<p>因为只要有两种颜色就一定有分界点，可以互相攻击。</p>
<p>显然的思路：枚举黑色用了 <span class="math inline">\(i\)</span> 行
<span class="math inline">\(j\)</span> 列。</p>
<p>可能会有一些比较naive的想法，直接乘上组合数求个和之类。</p>
<p>但稍加思考 直接组合数显然会出现放不满行列的情况，会算重。</p>
<p>所以要容斥。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为恰好黑色的放了
<span class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数，<span
class="math inline">\(g[i][j]\)</span> 为黑色的至多放了 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数。（<span
class="math inline">\(f,g\)</span>
这里均只考虑黑色方案，白色先不管，且均不含行列在总共 <span
class="math inline">\(n,m\)</span> 个中的位置的贡献）</p>
<p>有二项式反演：</p>
<p><span class="math display">\[
\begin{aligned}
g[n][m]&amp;=\sum_{i=1}^n\sum_{j=1}^m\binom{n}{i}\binom{m}{j}f[i][j]\\
f[n][m]&amp;=\sum_{i=1}^n(-1)^{n-i}\binom{n}{i}\sum_{j=1}^m(-1)^{m-j}\binom{m}{j}g[i][j]\\
&amp;=\sum_{i=1}^n\sum_{j=1}^m(-1)^{n+m-i-j}\binom{n}{i}\binom{m}{j}g[i][j]
\end{aligned}
\]</span></p>
<p>那么 <span class="math inline">\(g\)</span> 好算吗？很好算。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;g[i][j]=\dbinom{i\times j}{B}
\end{aligned}
\]</span></p>
<p>交叉点上随便选。</p>
<p>最终答案需要考虑上白色的方案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;Ans=\sum_{i=1}^n\sum_{j=1}^m\binom{n}{i}\binom{m}{j}f[i][j]\times\dbinom{(n-i)(m-j)}{W}
\end{aligned}
\]</span></p>
<p>容易理解：剩下 <span class="math inline">\((n-i)(m-j)\)</span>
个位置随意选都合法。</p>
<p>因为 <span class="math inline">\(f\)</span>
的状态设计为“恰好方案”，所有不重不漏。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2m^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">55</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,B,W;</span><br><span class="line"><span class="type">int</span> fac[N*N],ifac[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2500</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,m,B,W);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            g[i][j]=<span class="built_in">C</span>(i*j,B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> op=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(u,n)<span class="built_in">re</span>(v,m)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,u)<span class="built_in">re</span>(j,v)&#123;</span><br><span class="line">            op=((u+v-i-j)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">            f[u][v]=(f[u][v]+<span class="number">1ll</span>*op*<span class="built_in">C</span>(u,i)*<span class="built_in">C</span>(v,j)%Mod*g[i][j]%Mod+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            ans=(ans+<span class="number">1ll</span>*<span class="built_in">C</span>(n,i)*<span class="built_in">C</span>(m,j)%Mod*f[i][j]%Mod*<span class="built_in">C</span>((n-i)*(m-j),W)%Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>DP</tag>
        <tag>反演</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC162E</title>
    <url>/2023/12/01/ABC162E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_abc162_e">[ABC162E] Sum
of gcd of Tuples (Hard)</a></p>
<span id="more"></span>
<p><span class="math inline">\(\gcd(a[j])=bx\)</span> 的充要条件是 <span
class="math inline">\(a[j]\)</span> 都是 <span
class="math inline">\(x\)</span> 的倍数。</p>
<p>设 <span class="math inline">\(f_i\)</span> 是 <span
class="math inline">\(\gcd(a[j])\)</span> 为 <span
class="math inline">\(i\)</span> 的数列个数。</p>
<p><span
class="math inline">\(f_i=\lfloor\frac{k}{i}\rfloor^n-\sum\limits_{j=2}^{\lfloor\frac{k}{i}\rfloor
}f_{i\times j}\)</span>。</p>
<p>前一项为任选的倍数，通过快速幂<span class="math inline">\(O(\log
n)\)</span>，后一项为减掉 <span class="math inline">\(gcd(a[j])=mi,m\ge
2\)</span> 的个数，调和级数 <span class="math inline">\(O(\ln
k)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(k\log n+k\ln
k)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,f[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">pe</span>(i,k)&#123;</span><br><span class="line">        f[i]=<span class="built_in">qpow</span>(k/i,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=k;j+=i)&#123;</span><br><span class="line">            f[i]=(f[i]-f[j]+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,k)&#123;</span><br><span class="line">        ans=(ans+f[i]*<span class="number">1ll</span>*i%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC020C</title>
    <url>/2023/12/02/AGC020C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_agc020_c">[AGC020C]
Median Sum</a></p>
<span id="more"></span>
<p>看上去像是DP。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数能否组成 <span
class="math inline">\(j\)</span>。</p>
<p>显然有 <span class="math inline">\(f[i][j]=f[i-1][j]\cup
f[i-1][j-a[i]]\)</span></p>
<p>滚掉第一维，发现后面是一个整体位移后做按位与，可以用bitset优化。</p>
<p>如何求中位数？</p>
<p>似乎不太能直接扫，因为不知道每个数到底能被多少个子集拼出来。</p>
<p>但真的需要知道吗？</p>
<p>如果所有子集和序列中，<span class="math inline">\(x\)</span> 有 <span
class="math inline">\(m\)</span> 个，那么 <span
class="math inline">\(\sum a[i]-x\)</span> 也有个 <span
class="math inline">\(m\)</span>，选和不选是对称的，左边有 <span
class="math inline">\(m\)</span> 个右边也一定有对应的 <span
class="math inline">\(m\)</span> 个。</p>
<p>所以我们并不需要知道具体有多少个，从 <span
class="math inline">\(\lceil\frac{\sum a[i]}{2}\rceil\)</span>
开始扫，遇到第一个可以拼出来的就是答案了。</p>
<p>时间复杂度 <span
class="math inline">\(O(\frac{n^2A}{w})\)</span>，<span
class="math inline">\(10^8\)</span> 左右，常数很小，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2005</span>)</span></span>;</span><br><span class="line">bitset&lt;N*N&gt; f;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f|=f&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,(sum+<span class="number">1</span>)/<span class="number">2</span>,sum)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i])&#123;</span><br><span class="line">            <span class="built_in">write</span>(i,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC022E</title>
    <url>/2023/12/02/AGC022E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_agc022_e">[AGC022E]
Median Replace</a></p>
<span id="more"></span>
<p>看起来很奇妙的题。</p>
<p>像这种把某些字符合并的题目似乎都有套路</p>
<p>就是确定消去的优先顺序然后用栈来维护消去的情况</p>
<p>最后用DP的状态来确定栈的情况，做转移。</p>
<p>先想想怎么判断字符串可以被消成 <span
class="math inline">\(1\)</span>。</p>
<p>用一个栈维护，然后分讨，设新加入的字符为 <span
class="math inline">\(c\)</span>：</p>
<ul>
<li><p>若 <span class="math inline">\(c=0\)</span>：由于三个 <span
class="math inline">\(0\)</span> 抵消为一个 <span
class="math inline">\(0\)</span> 严格不劣，因此若原来栈顶有两个 <span
class="math inline">\(0\)</span> 则抵消为一个，否则加一个 <span
class="math inline">\(0\)</span>。</p></li>
<li><p>若 <span class="math inline">\(c=1\)</span>：如果栈顶是 <span
class="math inline">\(0\)</span>，可以直接将这个 <span
class="math inline">\(0\)</span> 与新加的 <span
class="math inline">\(1\)</span>
抵消（因为无论和另外哪个数取中位数，答案都是另外那个数）；如果栈顶为
<span
class="math inline">\(1\)</span>，若已经有两个了，那么这个串一定合法，因此直接忽略掉这个
<span class="math inline">\(1\)</span> 就可以了，否则加一个 <span
class="math inline">\(1\)</span>。</p></li>
</ul>
<p>这其实是一种优先级。</p>
<p>根据这个过程，可以发现栈内 <span class="math inline">\(0\)</span> 和
<span class="math inline">\(1\)</span> 的个数都在 <span
class="math inline">\([0,2]\)</span> 内，放进DP状态。</p>
<p>设 <span class="math inline">\(f[i][a][b]\)</span> 为当前处理到前
<span class="math inline">\(i\)</span> 个字符，栈内 <span
class="math inline">\(a\)</span> 个 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(b\)</span> 个 <span
class="math inline">\(0\)</span> 的答案。</p>
<p>接下来考虑怎么转移，当然需要分讨。</p>
<p>如果加入 <span class="math inline">\(0\)</span>： <span
class="math display">\[
\begin{aligned}
&amp;f[i][a][1]=f[i-1][a][0]+f[i-1][a][2]
&amp;f[i][a][2]=f[i-1][a][1]
\end{aligned}
\]</span> 如果加入 <span class="math inline">\(1\)</span>： <span
class="math display">\[
\begin{aligned}
&amp;f[i][a][b]=f[i-1][a][b+1]
&amp;f[i][1][0]=f[i-1][0][0]
&amp;f[i][2][0]=f[i-1][1][0]+f[i-1][2][0]
\end{aligned}
\]</span> 如果是问号，两个都跑一遍。</p>
<p>（上文所有 <span class="math inline">\(=\)</span>
都应该为加等于）</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ll f[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adm</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=(x+y)%Mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">pe</span>(i,n)s[i]=s[i<span class="number">-1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">2</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">2</span>],f[i<span class="number">-1</span>][a][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">0</span>],f[i<span class="number">-1</span>][a][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">adm</span>(f[i][a][<span class="number">1</span>],f[i<span class="number">-1</span>][a][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">2</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adm</span>(f[i][<span class="number">2</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,i)&#123;</span><br><span class="line">            <span class="built_in">adm</span>(ans,f[n][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC100E</title>
    <url>/2023/12/01/ARC100E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc100_c">[ARC100E] Or
Plus Max</a></p>
<span id="more"></span>
<p>首先发现直接每次找 <span class="math inline">\(i or j\le k\)</span>
的答案并不好找。</p>
<p>所以对答案做转化：设 <span class="math inline">\(f_k\)</span>
为恰好的最大 <span class="math inline">\(i or j=k\)</span> 的最大 <span
class="math inline">\(a_i+a_j\)</span>。</p>
<p><span class="math inline">\(ans_k=\max\limits_{i=1}^kf_i\)</span></p>
<p>现在的问题转化为求 <span class="math inline">\(f_k\)</span></p>
<p>如果将每个数看做一个集合 会发现:</p>
<p><span class="math inline">\(f_k=\max\limits_{i,j\subseteq
k}a_i+a_j\)</span>。</p>
<p>显然 <span class="math inline">\(f_k\)</span> 一定是取所有 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 中的最大值和次大值。</p>
<p>可以用高维前缀和（子集和DP）在<span
class="math inline">\(O(n2^n)\)</span>的复杂度内
求出最大值和次大值。</p>
<p>此类求<span class="math inline">\(\le K\)</span>不好做，<span
class="math inline">\(=K\)</span>好做的问题，都可以转化成求<span
class="math inline">\(=K\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">((<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    m=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        f[i][<span class="number">1</span>]=-inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(s,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[s][<span class="number">0</span>]&gt;f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>])&#123;</span><br><span class="line">                    f[s][<span class="number">1</span>]=<span class="built_in">max</span>(f[s][<span class="number">1</span>],f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[s][<span class="number">1</span>]=<span class="built_in">max</span>(f[s][<span class="number">0</span>],f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">1</span>]);</span><br><span class="line">                    f[s][<span class="number">0</span>]=f[s^(<span class="number">1</span>&lt;&lt;i)][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i][<span class="number">0</span>]+f[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
        <tag>子集和DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC074F</title>
    <url>/2023/12/01/ARC074F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT_arc074_d">[ARC074F]
Lotus Leaves</a></p>
<span id="more"></span>
<p>看到数据范围和方格图题面，想到网络流。</p>
<p>发现一个 <span class="math inline">\(o\)</span>
的作用是连接一行和一列。所以我们只需要对行和列建点，表格中的每个位置作为一条边。</p>
<p>很显然，题目可以转化为：最少去掉多少个 <span
class="math inline">\(o\)</span> 边，可以不连通。</p>
<p>也就是最小割的模板。</p>
<p>那么关于连边的部分也就出来了。</p>
<p>具体的，如果是 <span
class="math inline">\(o\)</span>，让对应的行和列连流量为 <span
class="math inline">\(1\)</span>
的边；如果是起点的话，源点和行，列分别连不限流的边，如果是终点的话，行，列分别和汇点连不限流的边。</p>
<p>代码写的<code>dinic</code>，时间复杂度上界为 <span
class="math inline">\(O(HW(H+W)^3)\)</span>，可以说是完全没有参考意义，实际跑的很快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">105</span>)</span>,<span class="title">rN</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,st,ed;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,fl;</span><br><span class="line">&#125;e[rN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[rN],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].fl=fl;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFl</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,fl);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lev[rN],cur[rN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    <span class="built_in">memset</span>(lev,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(lev));</span><br><span class="line">    lev[st]=<span class="number">0</span>;q.<span class="built_in">push</span>(st);</span><br><span class="line">    cur[st]=head[st];</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(lev[v]==inf&amp;&amp;e[i].fl)&#123;</span><br><span class="line">                lev[v]=lev[u]+<span class="number">1</span>;</span><br><span class="line">                cur[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lev[ed]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==ed)<span class="keyword">return</span> flw;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,v=<span class="number">0</span>,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i&amp;&amp;flw&gt;<span class="number">0</span>;i=e[i].nxt)&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(lev[v]!=lev[u]+<span class="number">1</span>||e[i].fl&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].fl,flw));</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>)lev[v]=inf;</span><br><span class="line">        flw-=c,e[i].fl-=c,e[i^<span class="number">1</span>].fl+=c,res+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    st=<span class="number">0</span>,ed=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;(s[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123; </span><br><span class="line">        <span class="built_in">re</span>(j,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">ae</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">ae</span>(j+n,i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">addFl</span>(st,i,inf);</span><br><span class="line">                <span class="built_in">addFl</span>(st,j+n,inf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">addFl</span>(i,ed,inf);</span><br><span class="line">                <span class="built_in">addFl</span>(j+n,ed,inf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(st,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=inf)cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1023F</title>
    <url>/2023/12/01/CF1023F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1023F">Mobile Phone
Network</a></p>
<span id="more"></span>
<p>先将题面翻译成能看的版本：</p>
<p>有 <span class="math inline">\(k\)</span> 个边权待定的边，还有 <span
class="math inline">\(m\)</span> 条已经确定的边。</p>
<p>在为 <span class="math inline">\(k\)</span>
条边确定权值后，使图的最小生成树包括全部 <span
class="math inline">\(k\)</span> 条边，最大化 <span
class="math inline">\(k\)</span> 条边的边权和。</p>
<p>生成树相关的题一般是分树边和非树边讨论。</p>
<p>有一个比较容易得到的思路：</p>
<p>先把 <span class="math inline">\(k\)</span>
条边都加到图里，然后仿照<code>Kruskal</code>的思想，将 <span
class="math inline">\(m\)</span>
条边排序，如果能连接两个不同连通块，就加边。</p>
<p>而加入的这些边对 <span class="math inline">\(k\)</span>
条边的边权是没有约束的，因为它们都是生成树上的边。</p>
<p>而对于不在生成树上的边：<span
class="math inline">\((u,v,w)\)</span>，对 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 路径上的未定边权都有边权要 <span
class="math inline">\(\le w\)</span> 的约束，</p>
<p>这个性质较为重要，所有约束完成后就是非树边不在生成树中的条件。</p>
<p>这个可以用树链剖分+线段树（可以写吉司机）做区间覆盖。</p>
<p>这道题就做完了，调题用了快1h。</p>
<p>为了方便写，所有未定边权初始边权都为极大值，复杂度 <span
class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>其实有更优的并查集做法：可以将区间<span
class="math inline">\(\min\)</span>覆盖的操作按覆盖的值排序，从小往大覆盖，用并查集维护已经被更新的部分，复杂度降到
<span class="math inline">\(O(n\log n)\)</span>，瓶颈在排序了。</p>
<p>下面有两份代码。</p>
<p>树剖：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w,nxt;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edg</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;be[N];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> added[N];</span><br><span class="line"><span class="type">int</span> hd[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hd[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> hd[x]=<span class="built_in">findfa</span>(hd[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x),y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    hd[x]=y;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],top[N],dfn[N],idx[N],dfcnt,siz[N],hson[N];</span><br><span class="line"><span class="type">int</span> ini[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dep[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        ini[v]=e[i].w;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp,dfn[u]=++dfcnt;</span><br><span class="line">    idx[dfcnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(hson[u]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(top[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tcp</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> mx,lz;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mx=ini[idx[l]];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].mx=v;</span><br><span class="line">        t[rt].lz=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mx&gt;=t[rt].lz)<span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">rs</span>(rt)].mx&gt;=t[rt].lz)<span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;t[rt].mx)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modPath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            ans[idx[l]]=t[rt].mx;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">solve</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)hd[i]=i;</span><br><span class="line">    <span class="built_in">re</span>(i,k)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">ae</span>(u,v,inf);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,inf);</span><br><span class="line">        hd[<span class="built_in">findfa</span>(u)]=<span class="built_in">findfa</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;be[i].u&gt;&gt;be[i].v&gt;&gt;be[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(be+<span class="number">1</span>,be+m+<span class="number">1</span>,[](Edg a,Edg b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        u=be[i].u,v=be[i].v;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">merge</span>(u,v))&#123;</span><br><span class="line">            <span class="built_in">ae</span>(u,v,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ae</span>(v,u,<span class="number">0</span>);</span><br><span class="line">            added[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> lca=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(added[i])<span class="keyword">continue</span>;</span><br><span class="line">        u=be[i].u,v=be[i].v,w=be[i].w;</span><br><span class="line">        lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">        t.<span class="built_in">modPath</span>(lca,u,w);</span><br><span class="line">        t.<span class="built_in">modPath</span>(lca,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==inf)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是并查集，是题解区复制的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1110000</span>;</span><br><span class="line"><span class="type">int</span> n,k,m1,m2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu_edge</span>&#123;<span class="type">int</span> x,y,w;&#125;dsu_e[N];</span><br><span class="line"><span class="type">int</span> dsu_fa[N],mst_e[N],mst_top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dsu_cmp</span><span class="params">(dsu_edge a,dsu_edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dsu_find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x==dsu_fa[x]?x:dsu_fa[x]=<span class="built_in">dsu_find</span>(dsu_fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_dsu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a = dsu_e[i].x,b = dsu_e[i].y;</span><br><span class="line">    a = <span class="built_in">dsu_find</span>(a);</span><br><span class="line">    b = <span class="built_in">dsu_find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">continue</span>;</span><br><span class="line">    mst_e[i] = <span class="number">1</span>;</span><br><span class="line">    dsu_fa[a] = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLE</span>&#123;</span><br><span class="line">  <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> fuck = <span class="number">0</span>,head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++fuck].to = y;</span><br><span class="line">  e[fuck].nxt = head[x];</span><br><span class="line">  e[fuck].w = w;</span><br><span class="line">  head[x] = fuck;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_mst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(mst_e[i])</span><br><span class="line">    &#123;</span><br><span class="line">      dsu_edge a = dsu_e[i];</span><br><span class="line">      <span class="built_in">add</span>(a.x,a.y,a.w);</span><br><span class="line">      <span class="built_in">add</span>(a.y,a.x,a.w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N],d[N],cost[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[x] = fa;d[x] = dep;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x];i;i = e[i].nxt)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">    cost[y] = e[i].w;</span><br><span class="line">    <span class="built_in">dfs</span>(y,x,dep+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>();m1 = <span class="built_in">read</span>();m2 = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dsu_fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dsu_e[i].x = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].y = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].w = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = m1+<span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    dsu_e[i].x = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].y = <span class="built_in">read</span>();</span><br><span class="line">    dsu_e[i].w = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dsu_e+<span class="number">1</span>,dsu_e+m1+m2+<span class="number">1</span>,dsu_cmp);</span><br><span class="line">  <span class="built_in">solve_dsu</span>();</span><br><span class="line">  <span class="built_in">solve_mst</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dsu_fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = m1+<span class="number">1</span>;i &lt;= m1+m2;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(mst_e[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">dsu_find</span>(dsu_e[i].x),b = <span class="built_in">dsu_find</span>(dsu_e[i].y),c = dsu_e[i].w;</span><br><span class="line">    <span class="keyword">while</span>(a != b)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[a]&lt;d[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">      <span class="keyword">if</span>(cost[a] &lt;= <span class="number">0</span>) ans += c,num++;</span><br><span class="line">      <span class="type">int</span> fa = <span class="built_in">dsu_find</span>(f[a]);</span><br><span class="line">      dsu_fa[a] = fa;</span><br><span class="line">      a = <span class="built_in">dsu_find</span>(a); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; m1) ans=<span class="number">-1</span>;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>并查集</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1114F</title>
    <url>/2023/12/01/CF1114F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1114F">Please, another
Queries on Array?</a></p>
<span id="more"></span>
<p>看起来非常线段树。</p>
<p>首先 考虑欧拉函数 <span class="math inline">\(\varphi\)</span>
的形式化式子：</p>
<p><span class="math inline">\(\varphi(n)=n\times \prod\limits_{p\in
P}\dfrac{p-1}{p}\)</span></p>
<p><span class="math inline">\(P\)</span> 为 <span
class="math inline">\(n\)</span> 的质因子组成的集合。</p>
<p><span class="math inline">\(n\)</span>
可以用线段树维护区间乘解决，后面的质因子如何处理？</p>
<p>可以发现 我们不关心每种质因子的数量，只需要记录是否存在即可。</p>
<p>值域很小，<span class="math inline">\(300\)</span> 内的质数只有 <span
class="math inline">\(62\)</span> 个。</p>
<p>暴力用数组记录 会大大增加复杂度；<span
class="math inline">\(62\)</span> 个状态，正好可以状压。</p>
<p>线段树维护每一个区间内的乘积 和 乘积的所有质因子状态。</p>
<p>时间复杂度，<span class="math inline">\(O(62(n+q)+q\log^2
n)\)</span>（两个 <span class="math inline">\(\log\)</span>
是区间乘的快速幂），可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4e5</span>+<span class="number">5</span>)</span>,<span class="title">V</span><span class="params">(<span class="number">305</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span>,<span class="title">pN</span><span class="params">(<span class="number">62</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> prm[pN+<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,Q,a[N];</span><br><span class="line">ll inv[V],f[pN+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,V<span class="number">-5</span>)inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">        f[i]=(prm[i]<span class="number">-1</span>)*inv[prm[i]]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll sta=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;prm[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(x%prm[i]==<span class="number">0</span>)sta|=(<span class="number">1ll</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">    ll mul,sta;</span><br><span class="line">    <span class="built_in">dat</span>(ll _m=<span class="number">0</span>,ll _s=<span class="number">0</span>)&#123;</span><br><span class="line">        mul=_m,sta=_s;</span><br><span class="line">    &#125;</span><br><span class="line">    dat <span class="keyword">operator</span>+(<span class="type">const</span> dat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        dat c;</span><br><span class="line">        c.mul=mul*b.mul%Mod;</span><br><span class="line">        c.sta=sta|b.sta;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        dat v,lz;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].v=t[<span class="built_in">ls</span>(rt)].v+t[<span class="built_in">rs</span>(rt)].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].lz.mul=<span class="number">1</span>,t[rt].len=r-l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].v=<span class="built_in">dat</span>(a[l],<span class="built_in">calc</span>(a[l]));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,dat val)</span></span>&#123;</span><br><span class="line">        t[rt].lz=t[rt].lz+val;</span><br><span class="line">        val.mul=<span class="built_in">qpow</span>(val.mul,t[rt].len);</span><br><span class="line">        t[rt].v=t[rt].v+val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz.sta==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="built_in">dat</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,dat val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,val);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">dat <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> t[rt].v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr)+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,Q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">12</span>];</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    dat ans;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r,x);</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,<span class="built_in">dat</span>(x,<span class="built_in">calc</span>(x)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r);</span><br><span class="line">            ans=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">re</span>(i,pN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.sta&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    ans.mul=ans.mul*f[i]%Mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write</span>(ans.mul,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>状态压缩</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1142C</title>
    <url>/2023/12/01/CF1142C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1142C">U2</a></p>
<span id="more"></span>
<p>小思维 + 二维凸包模板。</p>
<p>题意：给 <span class="math inline">\(n\)</span> 个点，过 <span
class="math inline">\(n\)</span> 个点中任意两点做二次函数 <span
class="math inline">\(y=x^2+bx+c\)</span>，问有多少种二次函数满足图像上方没有点。</p>
<p>上方没有点，可以想到上凸壳。</p>
<p>如果没有 <span
class="math inline">\(x^2\)</span>，显然合法情况为：直线 <span
class="math inline">\(bx+c\)</span> 过上凸壳上的相邻两点。</p>
<p>可以将所有点的坐标转为 <span
class="math inline">\((x,y_1)\)</span>：<span
class="math inline">\((x,y-x^2)\)</span>，这样就没有 <span
class="math inline">\(x^2\)</span> 了。</p>
<p>对新的点求上凸壳，答案也就是上凸壳上的边数，因为每条边都对应了一种一次函数
<span class="math inline">\(y_1=bx+c\)</span>。</p>
<p>直接跑 Graham 即可，时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-b.x,y-b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sta[N],tp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> mny=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[i].y-=p[i].x*p[i].x;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].y&lt;p[mny].y||(p[i].y==p[mny].y&amp;&amp;p[i].x&lt;p[mny].x))&#123;</span><br><span class="line">                mny=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(p[<span class="number">1</span>],p[mny]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        p[i].x-=p[<span class="number">1</span>].x;</span><br><span class="line">        p[i].y-=p[<span class="number">1</span>].y;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">2</span>,p+n+<span class="number">1</span>,[](Point a,Point b)&#123;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">cross</span>(a-p[<span class="number">1</span>],b-p[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>&amp;&amp;<span class="built_in">dist</span>(p[<span class="number">0</span>],a)&lt;<span class="built_in">dist</span>(p[<span class="number">0</span>],b))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cross</span>(p[sta[tp]]-p[sta[tp<span class="number">-1</span>]],p[i]-p[sta[tp]])&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tp--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[tp+<span class="number">1</span>]=sta[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,tp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[sta[i+<span class="number">1</span>]].x&lt;p[sta[i]].x)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1149B</title>
    <url>/2023/12/01/CF1149B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1149B">Three
Religions</a></p>
<span id="more"></span>
<p>有点罕见的DP。</p>
<p>可能会先想到一个贪心——枚举三个串的全排列，每个串都从贪心匹配到，标记匹配过的字符。稍加思考会发现这是假的（母串：<code>acacbc</code>，子串：<code>ac,bc,ca</code>）</p>
<p>所以考虑DP。</p>
<p>发现一共只有 <span class="math inline">\(k=3\)</span> 个串—— <span
class="math inline">\(k\)</span> 极小。且小串的长度最长也只有 <span
class="math inline">\(250\)</span>，所以可以直接记录 <span
class="math inline">\(k\)</span> 个状态。</p>
<p>设 <span class="math inline">\(f[i][j][k]\)</span> 为三个串分别匹配到
<span class="math inline">\(i\)</span>, <span
class="math inline">\(j\)</span> ,<span class="math inline">\(k\)</span>
位，最短需要在母串中匹配的前缀长度。</p>
<p><span class="math inline">\(nxt[i][c]\)</span> 为 母串中第 <span
class="math inline">\(i\)</span> 个位置以及后面的位置中，第一次出现字符
<span class="math inline">\(c\)</span> 的位置。 <span
class="math display">\[
\begin{aligned}
f[i]&amp;[j][k]=\min\{\\
    &amp;nxt[f[i-1][j][k]][s[1][i]],\\
    &amp;nxt[f[i][j-1][k]][s[2][j]],\\
    &amp;nxt[f[i][j][k-1]][s[3][k]]\\
\}
\end{aligned}
\]</span> 然而这是静态的，考虑加入/删除怎么做。</p>
<p>加入一个新字符时，新加入的状态最多只有 <span
class="math inline">\(1\times 250\times 250\)</span> 个。</p>
<p>删除字符直接 <span
class="math inline">\(len[id]-1\)</span>，加入字符时顺便覆盖之前减掉的状态就好了。</p>
<p>总复杂度 <span class="math inline">\(O(q\times
250^2\)</span>)，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">L</span><span class="params">(<span class="number">255</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,Q;</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>][L],f[L][L][L],nxt[N][<span class="number">27</span>],len[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;Q;</span><br><span class="line">    cin&gt;&gt;(t+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)nxt[n+<span class="number">1</span>][i]=nxt[n+<span class="number">2</span>][i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==j+<span class="string">&#x27;a&#x27;</span>)nxt[i][j]=i;</span><br><span class="line">            <span class="keyword">else</span> nxt[i][j]=nxt[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op,c;</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;id&gt;&gt;c;</span><br><span class="line">            s[id][++len[id]]=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i,((id==<span class="number">1</span>)?len[<span class="number">1</span>]:<span class="number">0</span>),len[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,((id==<span class="number">2</span>)?len[<span class="number">2</span>]:<span class="number">0</span>),len[<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="built_in">rep</span>(k,((id==<span class="number">3</span>)?len[<span class="number">3</span>]:<span class="number">0</span>),len[<span class="number">3</span>])&#123;</span><br><span class="line">                        <span class="type">int</span> &amp;sta=f[i][j][k];sta=n+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i)sta=<span class="built_in">min</span>(sta,nxt[f[i<span class="number">-1</span>][j][k]+<span class="number">1</span>][s[<span class="number">1</span>][i]]);</span><br><span class="line">                        <span class="keyword">if</span>(j)sta=<span class="built_in">min</span>(sta,nxt[f[i][j<span class="number">-1</span>][k]+<span class="number">1</span>][s[<span class="number">2</span>][j]]);</span><br><span class="line">                        <span class="keyword">if</span>(k)sta=<span class="built_in">min</span>(sta,nxt[f[i][j][k<span class="number">-1</span>]+<span class="number">1</span>][s[<span class="number">3</span>][k]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;id;</span><br><span class="line">            len[id]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[len[<span class="number">1</span>]][len[<span class="number">2</span>]][len[<span class="number">3</span>]]&lt;=n)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1156E</title>
    <url>/2023/12/01/CF1156E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1156E">Special Segments
of Permutation</a></p>
<span id="more"></span>
<p>我觉得是好题。</p>
<p>同类题：CF1175F</p>
<p>题意：给定一个排列 <span class="math inline">\(p\)</span>，求满足
<span class="math inline">\(p_l+p_r=\max_{i=l}^rp_i\)</span> 的 <span
class="math inline">\((l,r)\)</span> 个数。</p>
<p>数区间的题，要么枚举端点，要么分治。</p>
<p>容易有一个枚举 <span
class="math inline">\(r\)</span>，在枚举过的前缀中数 <span
class="math inline">\(\max_{i=l}^rp_i-p_l\)</span>
出现了几次的想法，这个题面看起来就很单调栈。</p>
<p>但是不太可做。</p>
<p>尝试另一种枚举思路：枚举 <span class="math inline">\(i\)</span>。</p>
<p>设 <span class="math inline">\(l_i,r_i\)</span> 为 <span
class="math inline">\(i\)</span> 左边和右边第一个大于 <span
class="math inline">\(p_i\)</span> 的位置。</p>
<p>可以发现，以 <span class="math inline">\(p_i\)</span> 为最大值的
<span class="math inline">\((l,r)\)</span>，一定满足 <span
class="math inline">\(l\in[l_i+1,i),r\in(i,r_i-1]\)</span>。</p>
<p>现在有了一个十分朴素的 <span class="math inline">\(O(n^3)\)</span>
算法，枚举 <span class="math inline">\(i,l,r\)</span> 判断是否合法。</p>
<p>显然可以加速这个过程，因为是排列，可以直接处理出每个数的位置 。</p>
<p>枚举 <span class="math inline">\(l\)</span>，判断 <span
class="math inline">\(pos[p_i-p_l]\)</span> 是否在 <span
class="math inline">\((i,r_i-l]\)</span> 内，时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>似乎要在这里结束了？</p>
<p>但如果尝试了一个看似玄学的优化：在 <span
class="math inline">\(l,r\)</span>
对应区间中选短的那个去枚举，可以直接AC。</p>
<p>为什么呢？</p>
<p>考虑对 <span class="math inline">\(p\)</span>
建立笛卡尔树，深度越小，数越大，根为最大值。</p>
<p>对排列建笛卡尔树，有：排列上一段区间对应树上的一个子树的关键性质。</p>
<p>更进一步的，树上的 <span class="math inline">\(p_i\)</span>
对应的子树区间就是 <span
class="math inline">\([l_i+1,r_i-1]\)</span>，证明就略了（<del>OI不需要证明</del>）</p>
<p>那么我们每次找短的区间枚举，就相当于找两个儿子中<code>size</code>小的子树，统计答案。</p>
<p>这是启发式合并的逆过程，是一种“启发式分裂”。</p>
<p>如果在笛卡尔树上从底到根做，就是一种启发式合并的过程。</p>
<p>可以发现，直接从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
枚举子树的根和启发式合并，要遍历的总大小是一样的，只是处理每棵子树的顺序变了而已。</p>
<p>所以本题也有很多写法：</p>
<ul>
<li>建笛卡尔树，用set启发式合并，复杂度 <span
class="math inline">\(O(n\log^2 n)\)</span>。</li>
<li>不建笛卡尔树，分治模拟出虚拟笛卡尔树，ST表查区间最大值位置（找区间内左右儿子的分界），复杂度
<span class="math inline">\(O(n\log n)\)</span>。</li>
<li>直接模拟前面写的那个过程，复杂度 <span class="math inline">\(O(n\log
n)\)</span>。</li>
</ul>
<p>代码写的最后一种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],pos[N],lm[N],rm[N];</span><br><span class="line"><span class="type">int</span> sta[N],tp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>]=inf,sta[tp=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&amp;&amp;a[sta[tp]]&lt;a[i])tp--;</span><br><span class="line">        lm[i]=sta[tp];</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    a[n+<span class="number">1</span>]=inf,sta[tp=<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pe</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tp&amp;&amp;a[sta[tp]]&lt;a[i])tp--;</span><br><span class="line">        rm[i]=sta[tp];</span><br><span class="line">        sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        l=lm[i]+<span class="number">1</span>,r=rm[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;i&amp;&amp;i&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-l&lt;r-i)&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,l,i<span class="number">-1</span>)&#123;</span><br><span class="line">                    p=pos[a[i]-a[j]];</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;p&amp;&amp;p&lt;=r)ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">rep</span>(j,i+<span class="number">1</span>,r)&#123;</span><br><span class="line">                    p=pos[a[i]-a[j]];</span><br><span class="line">                    <span class="keyword">if</span>(l&lt;=p&amp;&amp;p&lt;i)ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>奇妙</category>
      </categories>
      <tags>
        <tag>笛卡尔树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1175F</title>
    <url>/2023/12/01/CF1175F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1175F">The Number of
Subpermutations</a></p>
<span id="more"></span>
<p>和 CF1156E 是同类题，也是 [<a
href="https://h01yshhmy.github.io/2023/11/25/CF1156E/">CF1156E |
h01yshhmy</a>] 中的第二个做法，个人觉得这种做法很有拓展性。</p>
<p>对题意的合法条件做转化：</p>
<ul>
<li><span class="math inline">\([l,r]\)</span> 中没有重复数字。</li>
<li><span class="math inline">\([l,r]\)</span> 中最大值为 <span
class="math inline">\(r-l+1\)</span>。</li>
</ul>
<p>都很显然。</p>
<p>对于第一个条件，设 <span class="math inline">\(pre[i]\)</span> 为
<span class="math inline">\(i\)</span> 前面第一个和 <span
class="math inline">\(a[i]\)</span> 相等的位置。</p>
<p>那么 <span class="math inline">\(\max_{i=l}^rpre[i]&lt;l\)</span>
和第一个条件是等价的。</p>
<p>当然这里可以直接写ST表，不过 <span
class="math inline">\(\max_{i=1}^lpre[i]&lt;l\)</span>
一定成立，所以只需要将 <span class="math inline">\(pre\)</span> 改为
<span class="math inline">\(pre\)</span> 的前缀最大值，判断 <span
class="math inline">\(pre[r]&lt;l\)</span> 即可。</p>
<p>对于第二个条件，ST表即可。</p>
<p>如何寻找区间呢？可以在笛卡尔树上分治。</p>
<p>但是没必要建出笛卡尔树，直接分治是一样的。</p>
<p>对于当前分治区间 <span
class="math inline">\([l,r]\)</span>，找到区间内最大值位置 <span
class="math inline">\(p\)</span>，对于 <span
class="math inline">\([l,p-1\)</span>,<span
class="math inline">\([p+1,r]\)</span> 的子问题显然可以递归。</p>
<p>对于跨过 <span class="math inline">\(p\)</span> 的区间，长度为 <span
class="math inline">\(a[p]\)</span> 才能合法，考虑枚举所有长度为 <span
class="math inline">\(a[p]\)</span> 的跨过 <span
class="math inline">\(p\)</span> 的区间。</p>
<p>要么枚举左端点，要么枚举右端点。</p>
<p>枚举短的那一边就可以保证复杂度，因为枚举的长度每递归一层都至少减半，或者倒过来看，从底向上每次长度至少翻倍。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],pre[N],lg[N],ans;</span><br><span class="line">pii fval[N][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qryPos</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(fval[l][k],fval[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]).se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pos=<span class="built_in">qryPos</span>(l,r),len=a[pos];</span><br><span class="line">    <span class="built_in">solve</span>(l,pos<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(pos+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">if</span>(pos-l&lt;=r-pos)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,l,pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+len<span class="number">-1</span>&lt;=r&amp;&amp;i+len<span class="number">-1</span>&gt;=pos&amp;&amp;pre[i+len<span class="number">-1</span>]&lt;i)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,pos,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-len+<span class="number">1</span>&gt;=l&amp;&amp;i-len+<span class="number">1</span>&lt;=pos&amp;&amp;pre[i]&lt;i-len+<span class="number">1</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        fval[i][<span class="number">0</span>]=&#123;a[i],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pre[i]=pos[a[i]];</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        pre[i]=<span class="built_in">max</span>(pre[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j,<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>)&#123;</span><br><span class="line">            fval[i][j]=<span class="built_in">max</span>(fval[i][j<span class="number">-1</span>],fval[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>奇妙</category>
      </categories>
      <tags>
        <tag>笛卡尔树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1192B</title>
    <url>/2023/12/01/CF1192B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1192B">Dynamic
Diameter</a></p>
<span id="more"></span>
<p>首先对题目做形式化的转化。</p>
<p>修改 <span class="math inline">\(q\)</span>
次一条边的边权，每次修改后输出 <span
class="math inline">\(\max\limits_{u,v\in
V}dis[u]+dis[v]-2dis[lca(u,v)]\)</span>，强制在线。（<span
class="math inline">\(dis\)</span> 为到点 <span
class="math inline">\(1\)</span> 带权距离）</p>
<p>树上动态问题可能会想到LCT，这题的确有LCT写法：用矩阵优化朴素求带权直径的DP，然后用LCT维护矩阵（树上DDP）。</p>
<p>不过确实是太矢了。</p>
<p>有另一个做法：欧拉序+线段树。</p>
<p>我们先求出原树的欧拉序 <span class="math inline">\(eu\)</span>。设
<span class="math inline">\(L[u]\)</span>
为在欧拉序中第一次出现位置，<span class="math inline">\(R[u]\)</span>
为最后一次出现位置（注意，欧拉序中一个点可能出现多次）</p>
<p>发现有两个很好的性质：</p>
<ol type="1">
<li><p><span class="math inline">\(lca(u,v)\)</span> 在欧拉序中一定在
<span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间。</p></li>
<li><p>如果在 <span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间有比 <span
class="math inline">\(lca(u,v)\)</span> 深度更浅的节点，那么对于 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的其中一棵树的访问已经结束了，与该点在
<span class="math inline">\(L[u]\)</span> 和 <span
class="math inline">\(L[v]\)</span> 之间矛盾，也就是说 <span
class="math inline">\(lca(u,v)\)</span>
一定是最浅的点，而此题边权非负，深度换为 <span
class="math inline">\(dis\)</span> 不影响结论。</p></li>
</ol>
<p>形式化一下：</p>
<p><span class="math display">\[
\begin{aligned}
dis[lca(u,v)]=\min\limits_{i=L[u]}^{L[v]}dis[eu[i]]
\end{aligned}
\]</span></p>
<p>（上述其实是ST表+欧拉序 <span class="math inline">\(O(n\log
n)-O(1)\)</span> 求<code>LCA</code>的原理）</p>
<p>那么就可以用线段树维护欧拉序。</p>
<p>如何才能得到最大直径？</p>
<p>可以类比线段树维护连续段的做法。</p>
<p>我们分别维护：</p>
<ol type="1">
<li>区间内最大 <span class="math inline">\(dis\)</span> ，设为 <span
class="math inline">\(w\)</span>。</li>
<li>区间内最大 <span class="math inline">\(-2dis\)</span> ，设为 <span
class="math inline">\(m\)</span>。</li>
<li>区间内 左儿子区间内的 <span class="math inline">\(w\)</span>
减去右儿子内的 <span class="math inline">\(m\)</span> 的最大值（<span
class="math inline">\(dis[u]-2dis[lca]\)</span> 的最大值）设为 <span
class="math inline">\(lm\)</span>。</li>
<li>区间内 右儿子区间内的 <span class="math inline">\(w\)</span>
减去左儿子内的 <span class="math inline">\(m\)</span> 的最大值（<span
class="math inline">\(dis[v]-2dis[lca]\)</span> 的最大值）设为 <span
class="math inline">\(mr\)</span>。</li>
<li>区间内的答案（<span
class="math inline">\(dis[u]+dis[v]-2dis[lca]\)</span> 的最大值）设为
<span class="math inline">\(lmr\)</span> 。</li>
</ol>
<p>考虑怎么合并信息。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;w_u=\max\{w_l,w_r\}\\
&amp;m_u=\max\{m_l,m_r\}\\
&amp;lm_u=\max\{lm_l,lm_r,w_l+m_r\}\\
&amp;mr_u=\max\{mr_l,mr_r,m_l+w_r\}\\
&amp;lmr_u=\max\{lmr_l,lmr_r,lm_l+w_r,w_l+mr_r\}
\end{aligned}
\]</span></p>
<p>对于修改，修改一条边的边权会影响子树内全部 <span
class="math inline">\(dis\)</span>，区间修改即可。</p>
<p>答案就是全局 <span class="math inline">\(lmr\)</span>。</p>
<p>这种思维方式是比较有一般性的，直径的柿子和区间最大子段和 <span
class="math inline">\(\max\limits_{L-1\le l&lt;r\le R}
sum[r]-sum[l]\)</span> 本质相同，动态维护的方法也十分类似。</p>
<p>都是用线段树完成：求一个能拆成上述特殊形式的，二元函数 <span
class="math inline">\(f(l,r)\)</span>
的最值，此题无非是换成了欧拉序上。</p>
<p>因为线段树维护的是欧拉序，所以4倍空间的线段树要开8倍。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,ll&gt; &gt; G[N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">ll V,val[N],dis[N];</span><br><span class="line"><span class="type">int</span> dfn[N*<span class="number">2</span>],fa[N],tL[N],tR[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dfn[++dfncnt]=u;</span><br><span class="line">    tL[u]=dfncnt;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.fi==f)<span class="keyword">continue</span>;</span><br><span class="line">        dis[v.fi]=dis[u]+v.se;</span><br><span class="line">        <span class="built_in">dfs</span>(v.fi,u);</span><br><span class="line">        dfn[++dfncnt]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    tR[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        ll w,m,lm,mr,lmr,lz;</span><br><span class="line">    &#125;t[N*<span class="number">8</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].w=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].w,t[<span class="built_in">rs</span>(rt)].w);</span><br><span class="line">        t[rt].m=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].m,t[<span class="built_in">rs</span>(rt)].m);</span><br><span class="line">        t[rt].lm=<span class="built_in">max</span>(&#123;t[<span class="built_in">ls</span>(rt)].lm,t[<span class="built_in">rs</span>(rt)].lm,t[<span class="built_in">ls</span>(rt)].w+t[<span class="built_in">rs</span>(rt)].m&#125;);</span><br><span class="line">        t[rt].mr=<span class="built_in">max</span>(&#123;t[<span class="built_in">ls</span>(rt)].mr,t[<span class="built_in">rs</span>(rt)].mr,t[<span class="built_in">ls</span>(rt)].m+t[<span class="built_in">rs</span>(rt)].w&#125;);</span><br><span class="line">        t[rt].lmr=<span class="built_in">max</span>(&#123;</span><br><span class="line">            t[<span class="built_in">ls</span>(rt)].lmr,t[<span class="built_in">rs</span>(rt)].lmr,</span><br><span class="line">            t[<span class="built_in">ls</span>(rt)].w+t[<span class="built_in">rs</span>(rt)].mr,t[<span class="built_in">ls</span>(rt)].lm+t[<span class="built_in">rs</span>(rt)].w</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].w=dis[dfn[l]];</span><br><span class="line">            t[rt].m=<span class="number">-2</span>*dis[dfn[l]];</span><br><span class="line">            t[rt].lm=t[rt].mr=-dis[dfn[l]];</span><br><span class="line">            t[rt].lmr=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,ll v)</span></span>&#123;</span><br><span class="line">        t[rt].w+=v;</span><br><span class="line">        t[rt].m-=<span class="number">2</span>*v;</span><br><span class="line">        t[rt].lm-=v;t[rt].mr-=v;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">            t[rt].lz=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">&#125;E[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;V;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;E[i].u&gt;&gt;E[i].v&gt;&gt;val[i];</span><br><span class="line">        G[E[i].u].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(E[i].v,val[i]));</span><br><span class="line">        G[E[i].v].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(E[i].u,val[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,dfncnt);</span><br><span class="line">    <span class="type">int</span> d=<span class="number">0</span>,u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        d=(d+ans)%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        e=(e+ans)%V;</span><br><span class="line">        u=E[d].u;v=E[d].v;</span><br><span class="line">        <span class="keyword">if</span>(fa[v]==u)<span class="built_in">swap</span>(u,v);</span><br><span class="line">        t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,dfncnt,tL[u],tR[u],e-val[d]);</span><br><span class="line">        val[d]=e;</span><br><span class="line">        ans=t.t[<span class="number">1</span>].lmr;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>欧拉序</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1416D</title>
    <url>/2023/12/01/CF1416D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1416D">Graph and
Queries</a></p>
<span id="more"></span>
<p>重构树好题。</p>
<p>读完题一头雾水，想不到无边权的题竟然是Kruskal重构树。</p>
<p>删边看起来很困难，所以要离线，倒着做，删转加，现在暂时是比较经典的。</p>
<p>但是操作 <span class="math inline">\(1\)</span>
是要正着做的，倒着做的时候无法知道哪些 <span
class="math inline">\(u\)</span> 满足 <span
class="math inline">\(p_u=0\)</span>。</p>
<p>如何解决？先将删边倒着做，按倒序的加边顺序建立重构树，注意对边的处理可以不写边权不排序，实质上是以操作时间戳为关键字排序。</p>
<p>先将没有操作到的边都加进去，再倒着做删边，以加边顺序打时间戳。</p>
<p>因为我们是按照时间戳从小到大排序的，所以重构树满足 <span
class="math inline">\(\forall v\in subtree(u),w[v]\le
w[u]\)</span>（这是重构树性质），<span class="math inline">\(w\)</span>
为重构树上点权，也是操作时间戳，时间戳 <span class="math inline">\(\le
i\)</span> 说明这次merge是第 <span class="math inline">\(i\)</span>
次询问前执行的。</p>
<p>又因为和点 <span class="math inline">\(u\)</span>
有关系的所有并查集merge操作都在 <span class="math inline">\(u\)</span>
到根的链上。</p>
<p>那么对于节点 <span class="math inline">\(u\)</span>，时间戳在 <span
class="math inline">\(u\)</span> 的时间戳 之后 且 和 <span
class="math inline">\(u\)</span> 连通的点构成的点集，恰好是以重构树上
<span class="math inline">\(u\)</span> 的某个祖先 <span
class="math inline">\(v\)</span> 为根的子树。</p>
<p>可以通过重构树上倍增找 <span
class="math inline">\(v\)</span>，倍增找到祖先中深度最浅的时间戳 <span
class="math inline">\(\le\)</span> 当前操作序号的点即可。</p>
<p>也就是说，我们可以快速获得答案的分布区域了。</p>
<p>现在回到正向的时间线，正序处理所有操作 。</p>
<p>问题转化为：查找子树的叶子节点中最大值位置，并将其权值改为 <span
class="math inline">\(0\)</span>。</p>
<p>子树问题转为区间问题，线段树维护重构树叶子序列的最大值位置即可。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m+q)\log
n)\)</span>。</p>
<p>总结。</p>
<p>重构树在做 边权和连通性相关 的问题上，有奇效。</p>
<p>删边操作要么考虑倒序操作，要么考虑分块询问。</p>
<p>对于前者，可以把倒序的性质用一些数据结构保存下来，在正序操作时利用起来（比如重构树）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">Q</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,q,p[N],totn;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N*<span class="number">2</span>];</span><br><span class="line">pii qr[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tim[Q],ntim[N];</span><br><span class="line"><span class="keyword">namespace</span> buildT&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">    &#125;e[M],buc[M];</span><br><span class="line">    <span class="type">int</span> inG[M];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="built_in">read</span>(buc[i].u,buc[i].v);</span><br><span class="line">            inG[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">            <span class="built_in">read</span>(qr[i].fi,qr[i].se);</span><br><span class="line">            <span class="keyword">if</span>(qr[i].fi==<span class="number">2</span>)&#123;</span><br><span class="line">                inG[qr[i].se]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inG[i])&#123;</span><br><span class="line">                e[++cnt]=buc[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pe</span>(i,q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(qr[i].fi==<span class="number">2</span>)&#123;</span><br><span class="line">                e[++cnt]=buc[qr[i].se];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tim[i]=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">prework</span>();</span><br><span class="line">        <span class="built_in">re</span>(i,n)fa[i]=i;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">        totn=n;</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            u=<span class="built_in">findfa</span>(e[i].u);</span><br><span class="line">            v=<span class="built_in">findfa</span>(e[i].v);</span><br><span class="line">            <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">                totn++;</span><br><span class="line">                fa[totn]=totn;</span><br><span class="line">                fa[u]=fa[v]=totn;</span><br><span class="line">                ntim[totn]=i;</span><br><span class="line">                G[totn].<span class="built_in">pb</span>(u);</span><br><span class="line">                G[totn].<span class="built_in">pb</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> anc[N][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> tL[N],tR[N],rev[N],leafc;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,<span class="number">20</span>)&#123;</span><br><span class="line">        anc[u][i]=anc[anc[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tL[u]=n*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        anc[v][<span class="number">0</span>]=u;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        tL[u]=<span class="built_in">min</span>(tL[u],tL[v]);</span><br><span class="line">        tR[u]=<span class="built_in">max</span>(tR[u],tR[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(G[u].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++leafc;</span><br><span class="line">        tL[u]=tR[u]=leafc;</span><br><span class="line">        rev[leafc]=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAnc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">20</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i]&amp;&amp;ntim[anc[u][i]]&lt;=x)&#123;</span><br><span class="line">            u=anc[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    pii t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt]=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)],t[<span class="built_in">rs</span>(rt)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt]=&#123;p[rev[l]],l&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].fi=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pii <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> t[rt];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;pii res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    buildT::<span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,totn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)==i)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qr[i].fi==<span class="number">1</span>)&#123;</span><br><span class="line">            u=qr[i].se;</span><br><span class="line">            v=<span class="built_in">getAnc</span>(u,tim[i]);</span><br><span class="line">            pii res=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,tL[v],tR[v]);</span><br><span class="line">            <span class="built_in">write</span>(res.fi,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(res.fi)&#123;</span><br><span class="line">                t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,res.se);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>Kruskal重构树</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1687C</title>
    <url>/2023/12/01/CF1687C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1687C">Sanae and Giant
Robot</a></p>
<span id="more"></span>
<p>比较思维的题。</p>
<p>题目看起来很难做。</p>
<p>在题意描述的过程中没有找到性质，就尝试写数学式子。</p>
<p>区间之和相同看起来比较有用。</p>
<p>由 <span
class="math inline">\(\sum\limits_{i=l}^ra[i]=\sum\limits_{i=l}^rb[i]\)</span>
可得：<span class="math inline">\(\sum\limits_{i=l}^r
a[i]-b[i]=0\)</span>。（所以说合并下标相同的项是重要的）</p>
<p>设 <span class="math inline">\(c[i]=a[i]-b[i]\)</span>，发现要求变为
<span class="math inline">\(\sum\limits_{i=l}^rc[i]=0\)</span>。</p>
<p>回到将 <span class="math inline">\(b\)</span> 覆盖到 <span
class="math inline">\(a\)</span> 上的操作中，执行操作 <span
class="math inline">\((l,r)\)</span> 本质上是对 这一段的 <span
class="math inline">\(c\)</span> 整体赋值为 <span
class="math inline">\(0\)</span>，操作目标也就转化为 <span
class="math inline">\(\forall i\in[1,n],c[i]=0\)</span>。</p>
<p>对 <span class="math inline">\(c\)</span> 求前缀和 <span
class="math inline">\(s\)</span>，<span
class="math inline">\(s[r]-s[l-1]=0\)</span> 和
可以执行操作互为充要条件，且操作的本质变为对 <span
class="math inline">\([l,r]\)</span> 这一段的 <span
class="math inline">\(s\)</span> 整体赋值为 <span
class="math inline">\(s[l-1]\)</span>。</p>
<p>操作目标变为 <span class="math inline">\(\forall
i\in[1,n],s[i]=0\)</span>。</p>
<p>但是我们对执行操作的策略依然是一头雾水。</p>
<p>可以感性理解一下：每次选择 <span
class="math inline">\(s[l-1]=s[r]=0\)</span> 的 <span
class="math inline">\((l,r)\)</span> 一定更优，否则一定不会更优。</p>
<p>因为能对 <span class="math inline">\(s\)</span> 中 <span
class="math inline">\(0\)</span> 个数产生贡献的操作只能是 <span
class="math inline">\(s[r]=s[l-1]=0\)</span>
的，其他任何操作即使让一个不能匹配的 <span
class="math inline">\((l,r)\)</span> 找到了 <span
class="math inline">\(a\)</span> 中的匹配位置，也没有意义，因为不能增加
<span
class="math inline">\(0\)</span>。（不会严谨证明，只能这么说了）</p>
<p>思考怎么快速找到 <span class="math inline">\(s[r]=s[l-1]=0\)</span>
的 <span class="math inline">\((l,r)\)</span>。</p>
<p>发现 <span class="math inline">\((l,r)\)</span>
变多肯定是因为我们做了操作，也就是要在做操作的过程中，处理是否会制造更多
<span
class="math inline">\((l,r)\)</span>，这些区间是在“向外扩展”的，这很像是在广搜。</p>
<p>转成图论问题。</p>
<p>在所有 <span class="math inline">\(l-1\)</span> 和 <span
class="math inline">\(r\)</span>
连双向边，用<code>BFS</code>遍历整个图，初始在队列里加入 <span
class="math inline">\(\{i|s[i]=0\}\)</span>。</p>
<p>用<code>set</code>动态维护 <span class="math inline">\(\{i|s[i]\ne
0\}\)</span>，如果遍历到一条边 <span
class="math inline">\((u,v)\)</span> 满足 <span
class="math inline">\(s[v]=0\)</span>，直接暴力遍历set中位于 <span
class="math inline">\((u,v)\)</span> 之间的位置，把这些位置都覆盖上
<span class="math inline">\(0\)</span>，加入BFS队列，从set中删除。</p>
<p>答案只需要判断 <code>set.empty()</code> 即可。</p>
<p>容易发现每条边都只会被遍历两次，一个点也只会入队一次，出队一次，在<code>set</code>中同理。</p>
<p>多测别忘了清空。不要忘了点编号从 <span
class="math inline">\(0\)</span> 开始。（因为 <span
class="math inline">\(l-1\ge 0\)</span>，调了好久）</p>
<p>时间复杂度 <span class="math inline">\(O(T(n+m)\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T,n,m,a[N],b[N];</span><br><span class="line">ll sum[N],c[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            c[i]=a[i]-b[i];</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i])s.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n)G[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r);</span><br><span class="line">            G[l<span class="number">-1</span>].<span class="built_in">pb</span>(r);</span><br><span class="line">            G[r].<span class="built_in">pb</span>(l<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[v])<span class="keyword">continue</span>;</span><br><span class="line">                l=<span class="built_in">min</span>(u,v),r=<span class="built_in">max</span>(u,v);</span><br><span class="line">                <span class="keyword">auto</span> it=s.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">while</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;(*it)&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> p=*it;</span><br><span class="line">                    sum[p]=<span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(p);</span><br><span class="line">                    <span class="keyword">auto</span> era=it;it++;</span><br><span class="line">                    s.<span class="built_in">erase</span>(era);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1671E</title>
    <url>/2023/12/01/CF1671E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1671E">Preorder</a></p>
<span id="more"></span>
<p>考虑DP，设 <span class="math inline">\(f_u\)</span> 为以 <span
class="math inline">\(u\)</span> 为根子树内答案。</p>
<p>基础的想法是 <span class="math inline">\(f_u=2\times f_{lson}\times
f_{rson}\)</span> 乘法原理</p>
<p>但考虑到可能两个子树是“AB同构”的：存在一种交换方式
使得左子树与右子树的先序遍历产生AB串相同。</p>
<p>这种情况下 就不能乘2了。因为它们本质相同——交换过来后
每一种方案都在交换前出现过。</p>
<p>问题在于怎么判断两个子树是否同构。</p>
<p>直接判断先序遍历是否相等是不妥的，可能出现同构但遍历序列内有顺序颠倒。</p>
<p>所以我们可以直接钦定顺序
取子树内字典序最小的遍历方法判断同构就好了。</p>
<p>递归边界不是严格 <span
class="math inline">\([1,n]\)</span>，记得开双倍空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,f[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">string has[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rs</span>(rt)&gt;n)&#123;</span><br><span class="line">        f[rt]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">ls</span>(rt));</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">rs</span>(rt));</span><br><span class="line">    has[rt]=s[rt];</span><br><span class="line">    f[rt]=f[<span class="built_in">ls</span>(rt)]*<span class="number">1ll</span>*f[<span class="built_in">rs</span>(rt)]%Mod;</span><br><span class="line">    <span class="keyword">if</span>(has[<span class="built_in">ls</span>(rt)]!=has[<span class="built_in">rs</span>(rt)])f[rt]=f[rt]*<span class="number">2ll</span>%Mod;</span><br><span class="line">    <span class="keyword">if</span>(has[<span class="built_in">ls</span>(rt)]&lt;has[<span class="built_in">rs</span>(rt)])has[rt]+=has[<span class="built_in">ls</span>(rt)]+has[<span class="built_in">rs</span>(rt)];</span><br><span class="line">    <span class="keyword">else</span> has[rt]+=has[<span class="built_in">rs</span>(rt)]+has[<span class="built_in">ls</span>(rt)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        has[i]=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1753C</title>
    <url>/2023/12/01/CF1753C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1753C">Wish I Knew How to
Sort</a></p>
<span id="more"></span>
<p>这种过程较为复杂难以计数的题 考虑最终状态的性质。</p>
<p>最终一定是 <code>000...111</code>，所以考虑对 <span
class="math inline">\(0\)</span> 的个数做<code>DP</code>。</p>
<p>设一共有 <span class="math inline">\(cnt\)</span> 个 <span
class="math inline">\(0\)</span>，<span
class="math inline">\(f_i\)</span> 为前 <span
class="math inline">\(i\)</span> 个位置中放了 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span>。</p>
<p><span
class="math inline">\(f_i=f_{i-1}+\dfrac{C_n^2}{(cnt-i+1)^2}\)</span></p>
<p>这是为什么呢？</p>
<p>考虑期望的线性性，每次我们是在算 <span
class="math inline">\(i-1\)</span> 个 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span> 状态的期望。全部的操作方案为 <span
class="math inline">\(C_n^2\)</span>，而需要的操作方案是前 <span
class="math inline">\(cnt\)</span> 个位置中 <span
class="math inline">\(1\)</span> 的个数 <span
class="math inline">\(\times\)</span> 后 <span
class="math inline">\(n-cnt+1\)</span> 个位置中 <span
class="math inline">\(0\)</span> 的个数。</p>
<p>对于当前 <span class="math inline">\(i-1\)</span> 个 <span
class="math inline">\(0\)</span> 的状态来说，这两个个数都是 <span
class="math inline">\(cnt-i+1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T,n,a[N],cnt,f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n)cnt+=(a[i]==<span class="number">0</span>);</span><br><span class="line">        pre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,cnt)pre+=(a[i]==<span class="number">0</span>);</span><br><span class="line">        f[pre]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,pre+<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            f[i]=(f[i<span class="number">-1</span>]+(n*(n<span class="number">-1</span>)/<span class="number">2</span>)%Mod*<span class="built_in">qpow</span>((cnt-i+<span class="number">1</span>)*(cnt-i+<span class="number">1</span>),Mod<span class="number">-2</span>)%Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[cnt]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1806E</title>
    <url>/2023/12/01/CF1806E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1806E">Tree
Master</a></p>
<span id="more"></span>
<p>此题有很多做法：树分块，随机撒点，树上莫队。</p>
<p>但是都不如根号分治记搜好写。</p>
<p>所以写记搜。</p>
<p>发现这个题虽然一股数据结构味道，但是并不带修。</p>
<p>所以可以做很多预处理。</p>
<p>可能会想到优化 <span class="math inline">\(O(qn)\)</span>
暴力跳父亲的过程。</p>
<p>但不太好优化，转换思路——更直接一点，设 <span
class="math inline">\(f[u][v]\)</span> 为询问 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的答案。</p>
<p>不过记不下来这么多，所以改成 <span
class="math inline">\(f[u][i]\)</span> 为点 <span
class="math inline">\(u\)</span> 和这一层中第 <span
class="math inline">\(i\)</span> 个点的答案，且只记点数 <span
class="math inline">\(\le \sqrt{n}\)</span> 的层。</p>
<p>直接在暴力上跳的过程中记 <span class="math inline">\(f\)</span>
即可，就是记忆化搜索。</p>
<p>复杂度分析：</p>
<p>对于节点个数 <span class="math inline">\(\ge \sqrt{n}\)</span>
的层，一共 <span class="math inline">\(&lt; \sqrt{n}\)</span>
个，每一层跳的次数最多有 <span class="math inline">\(q\)</span>
次（询问都经过这一层），所以复杂度为 <span
class="math inline">\(O(q\sqrt{n})\)</span>。</p>
<p>对于节点个数 <span class="math inline">\(\le \sqrt{n}\)</span>
的层，设这一层有 <span class="math inline">\(m\)</span>
个点，最劣情况在当前层向上跳要跳 <span
class="math inline">\(m^2\)</span> 次（对当前层所有 <span
class="math inline">\(f[u][i]\)</span> 都记了一遍答案），一共最多有
<span class="math inline">\(\frac{n}{m}\)</span> 个这样的层，复杂度
<span class="math inline">\(m^2\times \frac{n}{m}=nm\)</span>，因为
<span class="math inline">\(m\le \sqrt{n}\)</span>，所以复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>总复杂度 <span
class="math inline">\(O((q+n)\sqrt{n})\)</span>，可以通过。</p>
<p>注：代码中 <span class="math inline">\(idx[u]\)</span> 是 <span
class="math inline">\(u\)</span>
在它那一层中的编号（当然，这一层的点数应该是 <span
class="math inline">\(\le \sqrt{n}\)</span>
的），这样写方便塞到连续的一段数组内，上述全部的“层”都是深度相关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,q,a[N],d[N],c[N],p[N],fa[N];</span><br><span class="line">ll f[N][<span class="number">500</span>];</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==y)<span class="keyword">return</span> s[x];</span><br><span class="line">  <span class="keyword">if</span>(c[d[x]]&lt;<span class="number">500</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][p[y]])<span class="keyword">return</span> f[x][p[y]];</span><br><span class="line">    <span class="keyword">return</span> f[x][p[y]]=<span class="built_in">solve</span>(fa[x],fa[y])+(ll)a[x]*a[y];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(fa[x],fa[y])+(ll)a[x]*a[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n,q);</span><br><span class="line">  <span class="built_in">re</span>(i,n)<span class="built_in">read</span>(a[i]);</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">2</span>,n)<span class="built_in">read</span>(fa[i]);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    s[i]=s[fa[i]]+(ll)a[i]*a[i];</span><br><span class="line">    d[i]=d[fa[i]]+<span class="number">1</span>;</span><br><span class="line">    p[i]=++c[d[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="built_in">read</span>(x,y);</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">solve</span>(x,y),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>我会根号</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1814D</title>
    <url>/2023/12/01/CF1814D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1814D">Balancing
Weapons</a></p>
<span id="more"></span>
<p>求最小调整次数，使得极差 <span class="math inline">\(\le
k\)</span></p>
<p>我们需要让调整次数尽量少，尽可能集中在一起。</p>
<p>显然，一定有一个 <span class="math inline">\(p_x\)</span>
是不动的，枚举这个 <span class="math inline">\(x\)</span>。</p>
<p>对于其他的，贪心的想，一共就只有三种取值：</p>
<ol type="1">
<li><span class="math inline">\(p_i=f_i\times d_i\)</span></li>
<li><span class="math inline">\(p_i=f_i\times
\lfloor\frac{p_x}{f_i}\rfloor\)</span></li>
<li><span class="math inline">\(p_i=f_i\times
\lceil\frac{p_x}{f_i}\rceil\)</span></li>
</ol>
<p>对所有的 <span class="math inline">\(p_i\)</span>
算出全部三种取值，以取值为关键字排序，用双指针找尽可能长的极差 <span
class="math inline">\(\le k\)</span>
的区间即可，区间越长越有可能包括全部 <span
class="math inline">\(n\)</span> 个。</p>
<p>在双指针扫描过程中，动态维护区间内包含的不同 <span
class="math inline">\(i\)</span> 的个数，如果区间内包括了全部 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(i\)</span> 的至少一种取值，就更新答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2\log
n)\)</span>，瓶颈在排序。</p>
<p>官方题解有更优复杂度：，被爆了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3005</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> node = <span class="keyword">struct</span> &#123;<span class="type">int</span> val, id, typ;&#125;;</span><br><span class="line"><span class="type">int</span> n, k, f[N], d[N], p[N], cnt[N];</span><br><span class="line"><span class="type">int</span> now, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> node&amp; x)</span> </span>&#123;</span><br><span class="line">  now -= x.typ;</span><br><span class="line">  cnt[x.id]++;</span><br><span class="line">  <span class="keyword">if</span> (cnt[x.id] == <span class="number">1</span>) tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">const</span> node&amp; x)</span> </span>&#123;</span><br><span class="line">  now += x.typ;</span><br><span class="line">  cnt[x.id]--;</span><br><span class="line">  <span class="keyword">if</span> (cnt[x.id] == <span class="number">0</span>) tot--;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  vec.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    cnt[i] = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&#123;p[i], i, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="type">int</span> tmp = x / f[i] * f[i];</span><br><span class="line">    <span class="keyword">if</span> (tmp) vec.<span class="built_in">push_back</span>(&#123;tmp, i, <span class="number">0</span>&#125;);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&#123;tmp + f[i], i, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">range</span>(vec), [](node x, node y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.val &lt; y.val;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>, res = n, len = vec.<span class="built_in">size</span>();</span><br><span class="line">  now = n, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (pos + <span class="number">1</span> &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[pos + <span class="number">1</span>].val &lt;= vec[i].val + k) &#123;</span><br><span class="line">      <span class="built_in">add</span>(vec[++pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)<span class="built_in">del</span>(vec[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (tot == n)res = <span class="built_in">min</span>(res, now);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">read</span>(T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">read</span>(n, k);</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      <span class="built_in">read</span>(f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      <span class="built_in">read</span>(d[i]);</span><br><span class="line">      p[i] = f[i] * d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, <span class="built_in">solve</span>(p[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1895D</title>
    <url>/2023/12/02/CF1895D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1895D">XOR
Construction</a></p>
<span id="more"></span>
<p>观察 <span class="math inline">\(b\)</span> 和 <span
class="math inline">\(a\)</span> 的关系。</p>
<p>对 <span class="math inline">\(a_i=b_i\oplus b_{i+1}\)</span>
变形，得 <span class="math inline">\(b_{i+1}=b_i\oplus a_i\)</span></p>
<p>发现是一个前缀和的形式，可以从 <span
class="math inline">\(b_1\)</span> 开始递推到 <span
class="math inline">\(b_n\)</span>。</p>
<p>但我们不知道 <span class="math inline">\(b_1\)</span> 的值。</p>
<p>问题转化成：找到一个首项 <span class="math inline">\(b_1\)</span>
，使得递推出的 <span class="math inline">\(b\)</span> 是一个 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(n-1\)</span> 的排列。</p>
<p>显然，对于一个排列，每个二进制位上的 <span
class="math inline">\(0\)</span> 个数一定大于等于 <span
class="math inline">\(1\)</span> 的个数，如果将排列塞到一个
<code>01Trie</code> 内，所有数一定是尽可能“靠左”（靠0）的。</p>
<p>先求出来 <span class="math inline">\(a\)</span> 的前缀和 <span
class="math inline">\(s_i=\oplus_{j=1}^i a_j\)</span>，有 <span
class="math inline">\(b_i=s_{i-1}\oplus b_1\)</span></p>
<p>可以通过对 <span class="math inline">\(b_1\)</span> 的调整，调整
<span class="math inline">\(s\)</span> 中所有数的二进制位上 <span
class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 的个数的大小关系。</p>
<p>时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">3e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i+<span class="number">1</span>]=b[i]^a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)&#123;</span><br><span class="line">        cnt1=cnt0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&gt;cnt0)&#123;</span><br><span class="line">            b[<span class="number">1</span>]|=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]^=b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF246E</title>
    <url>/2023/12/01/CF246E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF246E">Blood Cousins
Return</a></p>
<span id="more"></span>
<p>看起来比较像 dsu on tree。</p>
<p>首先先对询问离线，挂到树上。</p>
<p>暴力做法当然是对每个询问都查一遍子树，考虑优化。</p>
<p>我们需要一个数据结构，查询子树内某个深度中有多少种名字，为了保证复杂度，还需要支持快速合并儿子和父亲的信息。</p>
<p>可以用动态开点线段树，每棵线段树上维护每个深度上的信息，合并就直接线段树合并。</p>
<p>在线段树的每个节点上放一个<code>set</code>，存放名字，线段树合并的时候对两个<code>set</code>做启发式合并，查询直接查对应<code>set</code>的<code>size</code>。</p>
<p>做法非常暴力。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2
n)\)</span>，如果将set换成支持有序插入均摊 <span
class="math inline">\(O(1)\)</span> 的<code>splay</code>树，可以做到
<span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n,q,val[N],idxcnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    dep[u]=d;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pii&gt; qry[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    &#125;t[N*<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> ncnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt)rt=++ncnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].s.<span class="built_in">insert</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span>&amp; v,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u||!v)&#123;</span><br><span class="line">            u+=v,v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[u].s.<span class="built_in">size</span>()&lt;t[u].s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[u].s,t[v].s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">each</span>(i,t[v].s)t[u].s.<span class="built_in">insert</span>(i);</span><br><span class="line">            t[v].s.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">merge</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v),l,mid);</span><br><span class="line">        <span class="built_in">merge</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> t[rt].s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> rot[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    t.<span class="built_in">modify</span>(rot[u],<span class="number">1</span>,n,dep[u],val[u]);</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">solve</span>(v);</span><br><span class="line">        t.<span class="built_in">merge</span>(rot[u],rot[v],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">each</span>(i,qry[u])&#123;</span><br><span class="line">        ans[i.se]=t.<span class="built_in">query</span>(rot[u],<span class="number">1</span>,n,i.fi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;str&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(str))val[i]=mp[str];</span><br><span class="line">        <span class="keyword">else</span> mp[str]=val[i]=++idxcnt;</span><br><span class="line">        G[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]+k&lt;=n)&#123;</span><br><span class="line">            qry[x].<span class="built_in">pb</span>(&#123;dep[x]+k,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,q)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF258E</title>
    <url>/2023/12/01/CF258E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF258E">Little Elephant and
Tree</a></p>
<span id="more"></span>
<p>有“数据结构”思维。</p>
<p>题目翻译：给 <span class="math inline">\(m\)</span>
次操作，每次对两个子树添加一种颜色。<span
class="math inline">\(m\)</span> 次操作后输出 <span
class="math inline">\(i\)</span> 个数：和点 <span
class="math inline">\(i\)</span> 有至少一个相同颜色的点数。</p>
<p>两种思考方向：</p>
<ol type="1">
<li><p>点 <span class="math inline">\(i\)</span> 会被点 <span
class="math inline">\(i\)</span> 到根上的点覆盖，用线段树维护当前点
<span class="math inline">\(i\)</span>
到根这条路径上，挂上去的修改集合的并集的颜色拥有情况，计算线段树中非
<span class="math inline">\(0\)</span>
位置个数。结束这棵子树的处理后，再回溯，在线段树上减去集合的颜色贡献，比较自然。</p></li>
<li><p>将子树问题转为dfs序上的区间问题，设 <span
class="math inline">\(id[u]\)</span> 为点 <span
class="math inline">\(u\)</span> 在dfs序中位置，<span
class="math inline">\(f[id[i]][id[j]]\)</span> 为 第 <span
class="math inline">\(i\)</span> 个点和第 <span
class="math inline">\(j\)</span> 个点共有颜色个数，<span
class="math inline">\(L,R\)</span> 分别为子树在dfs序上的左右端点。</p>
<p>那么一次 <span class="math inline">\((u,v)\)</span> 操作等价于在
<span class="math inline">\(f\)</span> 上将 <span
class="math inline">\((L[u],L[v]),(R[u],R[v])\)</span> 这两个点对应的
矩形加 <span
class="math inline">\(1\)</span>，现在是一个二维区间问题，可以在一维上差分，另一维线段树维护。具体的，当前扫描到
的第 <span class="math inline">\(i\)</span> 行，处理在第 <span
class="math inline">\(i\)</span> 行上的修改（区间加差分后的 <span
class="math inline">\(+1/-1\)</span>），然后计算当前线段树的非
位置个数，得到答案。感觉这个过程是比较像扫描线的。</p></li>
</ol>
<p>写的是第二种思考方向，查询数列非 <span
class="math inline">\(0\)</span> 位置个数的写法在代码中。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mn,lz,cnt;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mn&lt;=t[<span class="built_in">rs</span>(rt)].mn)&#123;</span><br><span class="line">        t[rt].cnt+=t[<span class="built_in">ls</span>(rt)].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="built_in">ls</span>(rt)].mn&gt;=t[<span class="built_in">rs</span>(rt)].mn)&#123;</span><br><span class="line">        t[rt].cnt+=t[<span class="built_in">rs</span>(rt)].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    t[rt].mn+=v;</span><br><span class="line">    t[rt].lz+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">        t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    t[rt].cnt=r-l+<span class="number">1</span>;</span><br><span class="line">    t[rt].mn=t[rt].lz=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        <span class="built_in">update</span>(rt,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tL[N],tR[N],dfn[N],dfncnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    tL[u]=++dfncnt;</span><br><span class="line">    dfn[dfncnt]=u;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)<span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tR[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line">vector&lt;pii&gt; ch[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        d[tL[u]]++,d[tR[u]+<span class="number">1</span>]--;</span><br><span class="line">        d[tL[v]]++,d[tR[v]+<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">auto</span> add=[](<span class="type">int</span> p,<span class="type">int</span> x)&#123;</span><br><span class="line">            ch[tL[p]].<span class="built_in">pb</span>(&#123;x,<span class="number">1</span>&#125;);</span><br><span class="line">            ch[tR[p]+<span class="number">1</span>].<span class="built_in">pb</span>(&#123;x,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">add</span>(u,u);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        <span class="built_in">add</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">each</span>(j,ch[i])&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,tL[j.fi],tR[j.fi],j.se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">1</span>].mn&gt;<span class="number">0</span>)ans[dfn[i]]=n;</span><br><span class="line">        <span class="keyword">else</span> ans[dfn[i]]=n-t[<span class="number">1</span>].cnt;</span><br><span class="line">        ans[dfn[i]]=<span class="built_in">max</span>(<span class="number">0</span>,ans[dfn[i]]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF294C</title>
    <url>/2023/12/01/CF294C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF294C">Shaass and
Lights</a></p>
<span id="more"></span>
<p>划分出未被点亮的灯的极长连续段。</p>
<p>考虑中间的某一长 <span class="math inline">\(len_i\)</span>
的段是如何贡献答案的。</p>
<p>每一次可以在左边点或右边点 贡献为 <span
class="math inline">\(2^{len_i-1}\)</span>,要减一是因为最后一次只剩一个灯
没有左右区分。</p>
<p>拓展到多个段 发现选择的段的编号序列方案
就是：一个可重序列的排列数。</p>
<p>这是非常经典的问题，设有 <span class="math inline">\(n\)</span>
种数，<span class="math inline">\(i\)</span> 的个数为 <span
class="math inline">\(a_i\)</span>。</p>
<p>答案为：<span
class="math inline">\(\dfrac{(\sum_{i=1}^na_i)!}{\prod_{i=1}^{n}a_i!}\)</span></p>
<p>在本题中也就是 <span
class="math inline">\(\dfrac{(n-m)!}{\prod_{i=1}^{cnt}len_i!}\)</span></p>
<p>注意头和尾上的段只有一种点亮方式，没有贡献。</p>
<p>所以最后要乘上 <span
class="math inline">\(\prod_{i=2}^{cnt-1}2^{len_i-1}\)</span>，得到答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1005</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],l[N],fac[N],inv[N],p2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            res=(res*a)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a=(a*a)%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        l[++cnt]=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l[++cnt]=n-a[m];</span><br><span class="line">    fac[<span class="number">1</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    p2[<span class="number">0</span>]=<span class="number">1</span>,p2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        p2[i]=p2[i<span class="number">-1</span>]*<span class="number">2</span>%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=fac[n-m];</span><br><span class="line">    <span class="built_in">re</span>(i,cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=ans*inv[l[i]]%Mod;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;i!=cnt)ans=ans*p2[l[i]<span class="number">-1</span>]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>CF401D</title>
    <url>/2023/12/01/CF401D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF401D">Roman and
Numbers</a></p>
<span id="more"></span>
<p>（双倍经验）<a href="https://www.luogu.com.cn/problem/P4163">P4163
[SCOI2007] 排列</a></p>
<p>首先和整除相关 考虑记录每个同余类的状态</p>
<p><span class="math inline">\(n\)</span> 范围很大，考虑通过状压dp
从小的子问题合并到答案</p>
<p>先拆分： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">    a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 设 <span
class="math inline">\(f[s][i]\)</span> 为当前选了全集 <span
class="math inline">\(18\)</span> 位中的集合 <span
class="math inline">\(s\)</span> 重新排列 数字<span
class="math inline">\(=i\mod m\)</span>的 不同数字个数。</p>
<p>于是可以每次从比当前集合恰好少一个元素的状态转移过来
并直接计算要转移到哪个同余类： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!(s&gt;&gt;i&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">      f[s][(j*<span class="number">10</span>+a[i])%m]+=f[s^(<span class="number">1</span>&lt;&lt;i)][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但上述代码并不能考虑到前导零的影响 且还会数重。</p>
<p>比如 <span class="math inline">\(s=111_2\)</span> 可以从 <span
class="math inline">\(110_2\)</span> 和 <span
class="math inline">\(101_2\)</span> 转移过来，当 <span
class="math inline">\(n=122\)</span> 时，会被算重。</p>
<p>直接加入 <span class="math inline">\(vis\)</span>
数组去重，然后再加一点前导零判断，最终改为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">270000</span>)</span></span>;</span><br><span class="line">ll n,f[N][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> m,a[N],cnt,vis[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    ll x=n;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;i)&amp;&amp;!a[i])<span class="keyword">break</span>;<span class="comment">//前导零</span></span><br><span class="line">            <span class="keyword">if</span>(!(s&gt;&gt;i&amp;<span class="number">1</span>)||vis[a[i]])<span class="keyword">continue</span>;</span><br><span class="line">            vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                f[s][(j*<span class="number">10</span>+a[i])%m]+=f[s^(<span class="number">1</span>&lt;&lt;i)][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>][<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF487E</title>
    <url>/2023/12/01/CF487E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF487E">Tourists</a></p>
<span id="more"></span>
<p>圆方树上树剖，应该有点用处？</p>
<p>题意：两种操作，操作 <span class="math inline">\(1\)</span>
是单点修改点权，操作 <span class="math inline">\(2\)</span> 给定两个点
<span class="math inline">\(u,v\)</span>，求 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 所有路径中路径上最小值的最小值。</p>
<p>对操作 <span class="math inline">\(2\)</span> 进一步翻译：求最小的
<span class="math inline">\(w[c]\)</span> 满足 <span
class="math inline">\(c\)</span> 在 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>
的简单路径上（就是每个点最多经过一次的路径）。</p>
<p>转化到了和 <a
href="https://h01yshhmy.github.io/2023/11/28/P4630/">P4630 |
h01yshhmy</a> 相似的模型。</p>
<p>建立圆方树。</p>
<p>有结论：设 <span class="math inline">\(D\)</span> 为 圆点 <span
class="math inline">\(u\)</span> 到圆点 <span
class="math inline">\(v\)</span>
路径上方点的点集，方点点权为点双内圆点点权最小值，那么操作 <span
class="math inline">\(2\)</span> 答案是 <span
class="math inline">\(\min_{p\in D}w[p]\)</span>。</p>
<p>具体获得结论的过程在 <a
href="https://h01yshhmy.github.io/2023/11/28/P4630/">P4630 |
h01yshhmy</a>。</p>
<p>用树剖+线段树查询链上最值即可。</p>
<p>现在已经会做不带修的版本了，考虑加上操作 <span
class="math inline">\(1\)</span> 怎么办。</p>
<p>发现操作 <span class="math inline">\(1\)</span>
的困难之处在于，修改一个圆点，要修改所有点双包含这个圆点的方点的点权。</p>
<p>有一个比较好想，比较暴力的思路：对每个方点维护一个<code>multiset</code>，储存点双内点权，每次修改圆点时，遍历与这个圆点相连的方点，对他们的<code>multiset</code>删掉原点权，加入新点权，并更新方点点权。</p>
<p>但很显然，度数相关的复杂度是无法保证的，如果一个圆点连了一堆方点就爆了。</p>
<p>联想到树上问题中，父亲到儿子的操作太慢，可以转化成儿子到父亲，因为每个节点只有一个父节点。</p>
<p>注意到，在前面的暴力思路中，并没有把圆方树看做一个有根树，而我们可以把它变成有根树，选点
<span class="math inline">\(1\)</span> 为根即可。</p>
<p>现在将方点点权修改为：儿子中的点权最小值。</p>
<p>那么修改一个圆点只需要修改他的父亲方点的<code>multiset</code>，对这两个点都在线段树上更新一下点权即可。</p>
<p>查询的时候，如果两点的<code>lca</code>是方点，还要和<code>fa[lca]</code>的点权取个<code>min</code>，因为方点的父亲也在合法点双之内。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<p>总结：</p>
<p>圆方树对于 无向图上某两点之间全部简单路径中求值的问题 有奇效。</p>
<p>本质上是点双连通相关，圆点和方点的性质可以帮助我们快速建模和解题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> nid;</span><br><span class="line"><span class="keyword">namespace</span> TR&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to,nxt;</span><br><span class="line">    &#125;e[N*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N],ecnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        e[++ecnt].to=v;</span><br><span class="line">        e[ecnt].nxt=head[u];</span><br><span class="line">        head[u]=ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ae</span>(u,v);<span class="built_in">ae</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fa[N],dep[N],siz[N],hson[N],top[N],idx[N],dfn[N],dfncnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">        fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init1</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">                hson[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">        top[u]=tp;</span><br><span class="line">        dfn[idx[u]=++dfncnt]=u;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u])<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">init2</span>(hson[u],tp);</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==hson[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">init2</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt]=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)],t[<span class="built_in">rs</span>(rt)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[rt]=w[dfn[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[rt]=val;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,p,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,p,val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt];</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qrypath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=inf;</span><br><span class="line">        <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">            res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,nid,idx[top[u]],idx[u]));</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,nid,idx[u],idx[v]));</span><br><span class="line">        <span class="keyword">if</span>(u&gt;n)res=<span class="built_in">min</span>(res,w[fa[u]]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> GR&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to,nxt;</span><br><span class="line">    &#125;e[N*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N],ecnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        e[++ecnt].to=v;</span><br><span class="line">        e[ecnt].nxt=head[u];</span><br><span class="line">        head[u]=ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ae</span>(u,v);<span class="built_in">ae</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dfn[N],low[N],dfncnt,sta[N],tp;</span><br><span class="line">    <span class="type">int</span> bel[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        dfn[u]=low[u]=++dfncnt;</span><br><span class="line">        sta[++tp]=u;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">                    <span class="type">int</span> o=<span class="number">0</span>;nid++;</span><br><span class="line">                    <span class="keyword">do</span>&#123;</span><br><span class="line">                        o=sta[tp--];</span><br><span class="line">                        bel[o]=nid;</span><br><span class="line">                        TR::<span class="built_in">add</span>(o,nid);</span><br><span class="line">                    &#125;<span class="keyword">while</span>(o!=v);</span><br><span class="line">                    TR::<span class="built_in">add</span>(u,nid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    nid=n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        GR::<span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!GR::dfn[i])&#123;</span><br><span class="line">            GR::<span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TR::<span class="built_in">init1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    TR::<span class="built_in">init2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        s[TR::fa[i]-n].<span class="built_in">insert</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,n+<span class="number">1</span>,nid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i-n].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            w[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> w[i]=*s[i-n].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TR::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,nid);</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            TR::<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,nid,TR::idx[u],v);</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">1</span>)&#123;</span><br><span class="line">                w[u]=v;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fa=TR::fa[u];</span><br><span class="line">            s[fa-n].<span class="built_in">erase</span>(s[fa-n].<span class="built_in">find</span>(w[u]));</span><br><span class="line">            s[fa-n].<span class="built_in">insert</span>(v);</span><br><span class="line">            <span class="type">int</span> mn=*s[fa-n].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(mn!=w[fa])&#123;</span><br><span class="line">                TR::<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,nid,TR::idx[fa],mn);</span><br><span class="line">                w[fa]=mn;</span><br><span class="line">            &#125;</span><br><span class="line">            w[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;TR::<span class="built_in">qrypath</span>(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>双连通分量</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF559C</title>
    <url>/2023/12/01/CF559C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF559C">Gerald and Giant
Chess</a></p>
<span id="more"></span>
<p>双倍经验：<a href="https://www.luogu.com.cn/problem/AT_dp_y">Grid
2</a></p>
<p>首先，对于无障碍的地图，从 <span
class="math inline">\((x_1,y_1)\)</span> 到 <span
class="math inline">\((x_2,y_2)\)</span> 的路径数为 <span
class="math inline">\(\dbinom{x_2-x_1+y_2-y_1}{x_2-x_1}\)</span>，这里保证
<span class="math inline">\(x_1\le x_2,y_1\le y_2\)</span>。</p>
<p>观察数据范围，发现 <span class="math inline">\(n\le
2000\)</span>，考虑对黑点<code>DP</code>。</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为走到第 <span
class="math inline">\(i\)</span>
个黑点，<strong>且左上方所有的黑点都未被走过</strong>的路径方案数。<span
class="math inline">\(g[i][j]\)</span> 为从第 <span
class="math inline">\(i\)</span> 个黑点到第 <span
class="math inline">\(j\)</span>
个黑点假定无障碍的路径方案数（也就是上面那个组合数）。</p>
<p><span
class="math inline">\(f[i]=g[0][i]-\sum\limits_{j=1}^{i-1}f[j]\times
g[j][i]\)</span></p>
<p><span class="math inline">\(g[0][i]\)</span>
就是从起点出发；当然，要先对黑点排序。</p>
<p>为什么是对的呢？</p>
<p>虽然 <span class="math inline">\(g\)</span>
的设计是假定无障碍，走黑点的方案数也被统计了，但是 <span
class="math inline">\(f\)</span> 钦定了必走 <span
class="math inline">\(i\)</span>
，且前面的黑点都未被走过，所以说后面的和式中每一种方案都是不能放在 <span
class="math inline">\(f[i]\)</span> 内的，且不重复。</p>
<p>我们只需要只走最后一个点的方案，这样做是不重不漏的。</p>
<p>题目要求走到 <span class="math inline">\((h,w)\)</span>
的方案数，添加上 <span class="math inline">\((h,w)\)</span>
为黑点就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2005</span>)</span>,<span class="title">V</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pnt</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line">ll f[N];</span><br><span class="line">ll fac[V],ifac[V];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(h,w,n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].x,a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    a[++n].x=h;</span><br><span class="line">    a[n].y=w;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,[](Pnt u,Pnt v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u.x==v.x)<span class="keyword">return</span> u.y&lt;v.y;</span><br><span class="line">        <span class="keyword">return</span> u.x&lt;v.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">C</span>(a[i].x+a[i].y<span class="number">-2</span>,a[i].x<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">re</span>(j,i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].x&lt;a[j].x||a[i].y&lt;a[j].y)<span class="keyword">continue</span>;</span><br><span class="line">            f[i]=(f[i]-f[j]*<span class="built_in">C</span>(a[i].x-a[j].x+a[i].y-a[j].y,a[i].x-a[j].x)%Mod+Mod)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF600E</title>
    <url>/2023/12/02/CF600E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF600E">Lomsat
gelral</a></p>
<span id="more"></span>
<p>可以当做树上启发式合并的板子。</p>
<p>树上启发式合并的核心思想其实就是信息的多次利用，对重儿子的特殊操作保证了时间复杂度的正确性。</p>
<p>树上启发式合并的题当然要先想暴力。</p>
<p>暴力很好做，对每个颜色记个数，维护当前的众数和众数编号和即可。</p>
<p>树上启发式合并只是优化了这个过程，代码其实差不多就是板子了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> n,c[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],siz[N],hson[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">predfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[u]=f,dep[u]=dep[f]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==f)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">predfs</span>(v,u);</span><br><span class="line">    siz[u]+=siz[v];</span><br><span class="line">    <span class="keyword">if</span>(siz[v]&gt;siz[hson[u]])&#123;</span><br><span class="line">      hson[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cannot,cnt[N],resmx;</span><br><span class="line">ll nowans,ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  cnt[c[u]]+=k;</span><br><span class="line">  <span class="keyword">if</span>(cnt[c[u]]&gt;resmx)&#123;</span><br><span class="line">    resmx=cnt[c[u]];</span><br><span class="line">    nowans=c[u];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[c[u]]==resmx)&#123;</span><br><span class="line">    nowans+=c[u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==cannot)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">update</span>(v,k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">  <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==hson[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">solve</span>(v,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hson[u])<span class="built_in">solve</span>(hson[u],<span class="number">1</span>),cannot=hson[u];</span><br><span class="line">  <span class="built_in">update</span>(u,<span class="number">1</span>);</span><br><span class="line">  ans[u]=nowans,cannot=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">update</span>(u,<span class="number">-1</span>);</span><br><span class="line">    nowans=resmx=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">read</span>(c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">read</span>(u,v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">    G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">predfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树上启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF678E</title>
    <url>/2023/12/02/CF678E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF678E">Another Sith
Tournament</a></p>
<span id="more"></span>
<p>重点在于倒着做。</p>
<p>看到 <span class="math inline">\(n\le 18\)</span>，显然是要状压。</p>
<p>如果直接模拟题意，设 <span
class="math inline">\(f[s][\cdots]\)</span> 为当前还剩 <span
class="math inline">\(s\)</span> 内的骑士活着（外加一些状态）
的成功概率，其实并不好做（当然也能写）。</p>
<p>考虑一种“倒着做”的思想，设 <span class="math inline">\(f[s]\)</span>
为：最开始有 <span class="math inline">\(s\)</span>
内的人参加决斗，<span class="math inline">\(1\)</span>
号的最大胜利概率。</p>
<p>就有一个非常简单的式子：</p>
<p><span class="math display">\[
\begin{aligned}
f[s]=\max\limits_{i,j\in s}f[s/i]\times a[j][i]+f[s/j]\times a[i][j]
\end{aligned}
\]</span></p>
<p>初始 <span class="math inline">\(f[\{1\}]=1\)</span>。</p>
<p>原理很显然，想转移到 <span class="math inline">\(f[s]\)</span> ，要么
<span class="math inline">\(i\)</span> 赢了 <span
class="math inline">\(j\)</span>，要么 <span
class="math inline">\(j\)</span> 赢了 <span
class="math inline">\(i\)</span>
，分别乘上概率即可，不需要考虑其他的繁杂，状态设计保证了正确性。</p>
<p>时间复杂度 <span class="math inline">\(O(2^n\times
n^2)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N],f[(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">2</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s]=<span class="built_in">max</span>(f[s],f[s^(<span class="number">1</span>&lt;&lt;j)]*a[i][j]+f[s^(<span class="number">1</span>&lt;&lt;i)]*a[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF698C</title>
    <url>/2023/12/01/CF698C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF698C">LRU</a></p>
<span id="more"></span>
<p>题面看起来有点难写。</p>
<p>看到 <span class="math inline">\(n,k\le 20\)</span>，向状压考虑。</p>
<p>设 <span class="math inline">\(f[s]\)</span> 为最终队列内有 <span
class="math inline">\(s\)</span> 中物品的概率。</p>
<p>可以分个类：</p>
<ol type="1">
<li><p>队列最终被装满</p></li>
<li><p>队列最终未满。</p></li>
</ol>
<p>极大的操作次数和良心的样例#4给了我们提示：最终答案可以忽略队列未满的情况。</p>
<p>也就是说 不断的选同一个物品，导致最后队列没满
的概率可以忽略，因为操作次数实在是太多了。</p>
<p>只需要对第一种情况<code>DP</code>了。</p>
<p><span class="math inline">\(f\)</span>
的状态设计改为第一次状态为的概率。</p>
<p>设 <span class="math inline">\(g[s]=\sum_{i\in s}p[i]\)</span></p>
<p><span
class="math inline">\(f[s\cup\{u\}]=f[s]\times\sum\limits_{i=0}^{\infty}p[u]g[s]^i\)</span></p>
<p>注：<span class="math inline">\(u\not\in s，p[u]\not=
0\)</span>。</p>
<p>等号其实应该为加等于，为了美观后文都是等号。</p>
<p>意义是：现在就选了 <span
class="math inline">\(u\)</span>，先选了一次队列内的又选 <span
class="math inline">\(u\)</span> ，先选了两次队列内的又选 <span
class="math inline">\(u\)</span>……</p>
<p>注意，这里 <span class="math inline">\(|s|&lt;
k\)</span>，也就是说<strong>不需要考虑弹出</strong>的情况，队列满了之后就不再转移了。</p>
<p>为什么设成第一次状态为 <span
class="math inline">\(s\)</span>，不考虑弹出，是对的呢？</p>
<p>对于选数的序列，队列内的元素构成了整个序列上的一个长为的滑动窗口，在概率不变的随机序列上的滑动窗口。</p>
<p>因为操作次数过多，所以有重复元素不<code>push</code>不会对上述造成影响。</p>
<p>无论窗口放在哪里，对应状态的概率都应该不变，所以我们不如放在最开头。</p>
<p>式子显然不能到此为止。</p>
<p><span class="math display">\[
\begin{aligned}
f[s\cup\{u\}]&amp;=f[s]\times\sum\limits_{i=0}^{\infty}p[u]g[s]^i\\
&amp;=f[s]\times p[u]\sum\limits_{i=0}^{\infty}g[s]^i\\
&amp;=f[s]\times p[u]\times \dfrac{1}{1-g[s]}
\end{aligned}
\]</span></p>
<p>现在就可以转移了。</p>
<p>刷表法，代码中 <span class="math inline">\(\frac{1}{1-g[s]}\)</span>
是滞后乘上的。</p>
<p>有个小问题：要特判 <span
class="math inline">\(\sum\limits_{i=1}^n[p[i]&gt;0]&lt;k\)</span>
的情况，也就是说不可能放满，这样只要有概率就一定会存在于最终队列。</p>
<p>总结：
对于操作次数极大的题，忽略小概率事件，考虑整个状态序列上是否有“一般性”，不太好描述，大概就像是上文中：窗口在最后和最前面是一样的，因为概率一直相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">25</span>)</span>,<span class="title">vN</span><span class="params">(<span class="number">1.1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">double</span> p[N],f[vN],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">        cnt+=(p[i]&gt;eps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;k)&#123;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]&lt;=eps)cout&lt;&lt;<span class="string">&quot;0.0 &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;1.0 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cnt=__builtin_popcount(s);</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">            <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)ans[i]+=f[s];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)sum+=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        f[s]/=(<span class="number">1</span>-sum);</span><br><span class="line">        <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(~s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s|(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]+=f[s]*p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF833B</title>
    <url>/2023/12/01/CF833B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF833B">The Bakery</a></p>
<span id="more"></span>
<p>先考虑朴素<code>DP</code></p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数分成 <span
class="math inline">\(j\)</span> 块的最大价值，<span
class="math inline">\(w\)</span> 为区间的价值。</p>
<p><span class="math display">\[
f[i][j]=\max_{k=1}^if[k][j-1]+w(k+1,i)
\]</span></p>
<p>时间复杂度 <span
class="math inline">\(O(n^2k)\)</span>，不能接受。</p>
<p>发现我们枚举到第一维了，所以调换一下状态，便于优化。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为前 <span
class="math inline">\(j\)</span> 个数分成 <span
class="math inline">\(i\)</span> 块。</p>
<p><span class="math display">\[
f[i][j]=\max_{k=1}^jf[i-1][k]+w(k+1,j)
\]</span></p>
<p>后面的 <span class="math inline">\(\max\)</span>
都在同一行内，可以用数据结构优化。</p>
<p>如何求出 <span
class="math inline">\(w\)</span>？我们可以“在线”做。</p>
<p>因为 <span class="math inline">\(k\le j\)</span>，所以枚举到 <span
class="math inline">\(j\)</span> 的时候，<span
class="math inline">\(w\)</span> 能用到的右边界就是 <span
class="math inline">\(j\)</span>。</p>
<p>所以转移时动态贡献答案是可行的。</p>
<p>每次向右走一格（<span
class="math inline">\(j+1\)</span>），对于每一位 <span
class="math inline">\(f[i-1][k]\)</span>，加上新的 <span
class="math inline">\(j\)</span> 造成的贡献。</p>
<p>这个可以预处理出每个数前第一个相等的数的位置 <span
class="math inline">\(las[i]\)</span> 来做。</p>
<p>具体的，对 <span class="math inline">\([las[i]+1,1]\)</span> 区间
<span class="math inline">\(+1\)</span>，每次查询 <span
class="math inline">\([1,j]\)</span> 的最大值。</p>
<p>显然可以使用线段树维护，对于每一个 <span
class="math inline">\(i\)</span> 都清空一遍线段树即可。</p>
<p>时间复杂度 <span class="math inline">\(O(nk\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">35005</span>)</span>,<span class="title">K</span><span class="params">(<span class="number">55</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">int</span> f[K][N];</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mx,lz;</span><br><span class="line">  &#125;t[N*<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].mx=<span class="built_in">max</span>(t[<span class="built_in">ls</span>(rt)].mx,t[<span class="built_in">rs</span>(rt)].mx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    t[rt].mx+=v;</span><br><span class="line">    t[rt].lz+=v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    t[rt].lz=t[rt].mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">      t[rt].mx=f[now<span class="number">-1</span>][l<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">    t[rt].lz=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">      <span class="built_in">update</span>(rt,<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mx;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> las[N],pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n,m);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">    las[i]=pos[a[i]];</span><br><span class="line">    pos[a[i]]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">    now=i;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">      t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,las[j]+<span class="number">1</span>,j);</span><br><span class="line">      f[i][j]=t.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(f[m][n],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF886E</title>
    <url>/2023/12/01/CF886E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF886E">Maximum
Element</a></p>
<span id="more"></span>
<p>设 <span class="math inline">\(f_i\)</span> 为 <span
class="math inline">\(i\)</span> 的排列中程序运行不会出错的方案数
也就是<span class="math inline">\(i\in [i+k+1,i]\)</span>。</p>
<p><span class="math inline">\(f_i\)</span> 可以被 <span
class="math inline">\(j\in[i-k,i-1]\)</span> 转移到，除去最大值 <span
class="math inline">\(i\)</span> 外 剩余 $i-1 $个中 有 <span
class="math inline">\(i-j\)</span> 个为自由的</p>
<p>自由位置造成的贡献是 <span
class="math inline">\(A_{i-j}^{i-1}\)</span></p>
<p>然后需要一些前缀和优化复杂度。</p>
<p>最后要容斥一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,f[N],s[N],fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*(Mod-Mod/i)*ifac[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)ifac[i]=<span class="number">1ll</span>*ifac[i<span class="number">-1</span>]*ifac[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  io&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1e6</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=k)f[i]=fac[i];</span><br><span class="line">        <span class="keyword">else</span> f[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*(s[i<span class="number">-1</span>]-s[i-k<span class="number">-1</span>]+Mod)%Mod;</span><br><span class="line">        s[i]=(s[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*ifac[i]%Mod)%Mod;</span><br><span class="line">  &#125;</span><br><span class="line">    io&lt;&lt;(fac[n]<span class="number">-1ll</span>*fac[n<span class="number">-1</span>]*(s[n<span class="number">-1</span>]+<span class="number">1</span>)%Mod+Mod)%Mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CF893F</title>
    <url>/2023/12/01/CF893F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF893F">Subtree Minimum
Query</a></p>
<span id="more"></span>
<p>一个找性质DS题。</p>
<p>题意：有根有点权的树，给定 <span
class="math inline">\(u,k\)</span>，求以 <span
class="math inline">\(u\)</span> 为根子树中深度在 <span
class="math inline">\([dep[u],dep[u]+k]\)</span>
内的点的点权最小值，强制在线。</p>
<p>首先可以想到一个比较无脑的做法：用树套树，大树维护dfs序，小树维护深度，也就是在线的二维数点写法。</p>
<p>注意到询问次数 <span class="math inline">\(10^6\)</span>，<span
class="math inline">\(O(m\log^2 n)\)</span>
的树套树很难通过，需要指令集大力卡常。</p>
<p>我们将树上问题转化为二维矩形问题的时候，忽略了点和深度的关联。</p>
<p>在dfs序上查找的 <span
class="math inline">\([id[u],id[u]+siz[u]-1]\)</span>
这个区间，对深度有性质：内部的点深度均 <span class="math inline">\(\ge
dep[u]\)</span>。</p>
<p>所以就可以直接“忽略”点的深度 <span
class="math inline">\(&lt;dep[u]\)</span> 的限制，这样的点在以
为根子树区间内根本不存在。</p>
<p>所以说转化的时候要动脑子，看看有没有扔了的性质，不要写DS写魔怔了。</p>
<p>用主席树，深度为时间轴，时间轴上每棵线段树维护dfs序。</p>
<p>总的来说，主席树是深度上前缀最小值的线段树序列。</p>
<p>查询直接查第 <span class="math inline">\(dep[u]+k\)</span>
棵树的对应区间即可，查到所有可能出现的值都是深度在 <span
class="math inline">\([dep[u],dep[u]+k]\)</span> 之间的。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,rt,a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> dep[N],idx[N],siz[N],dfn[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[idx[u]=++dfncnt]=u;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>],mn;</span><br><span class="line">        <span class="built_in">Seg</span>()&#123;mn=inf;&#125;</span><br><span class="line">    &#125;t[N*<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> ncnt,rot[N];</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> rot[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt||rt==old)rt=++ncnt;</span><br><span class="line">        t[rt]=t[old];</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].mn=v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),<span class="built_in">ls</span>(old),l,mid,p,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),<span class="built_in">rs</span>(old),mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">        t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].mn;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,rt);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,rt);</span><br><span class="line">    <span class="built_in">re</span>(i,n)p[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> dep[x]&lt;dep[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        t.<span class="built_in">insert</span>(t[dep[p[i]]],t[dep[p[i<span class="number">-1</span>]]],<span class="number">1</span>,n,idx[p[i]],a[p[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,k);</span><br><span class="line">        u=(u+ans)%n+<span class="number">1</span>;</span><br><span class="line">        k=(k+ans)%n;</span><br><span class="line">        ans=t.<span class="built_in">query</span>(t[<span class="built_in">min</span>(dep[u]+k,dep[p[n]])],<span class="number">1</span>,n,idx[u],idx[u]+siz[u]<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>CF911G</title>
    <url>/2023/12/01/CF911G/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF911G">Mass Change
Queries</a></p>
<span id="more"></span>
<p>首先能想到线段树暴力打100个tag的做法。</p>
<p>但时间复杂度不够优秀。</p>
<p>考虑另一种方式：开100棵线段树。</p>
<p>第 <span class="math inline">\(i\)</span> 棵线段树维护数字 <span
class="math inline">\(i\)</span> 所在位置（区间）。</p>
<p>感性理解一下，对于其中的一棵树，我们要维护一个像是：不带路径压缩的并查集结构。</p>
<p>区别在于：每个节点代表是一个区间，区间内都是这棵树所代表的数。</p>
<p>如果是并查集，可以直接合并，线段树当然就要写线段树合并了。</p>
<p>当然，线段树内不需要维护任何信息，因为树的编号 <span
class="math inline">\([1,100]\)</span> 和节点区间就是需要的信息。</p>
<p>用动态开点写一写即可。</p>
<p>时间复杂度大概是 <span class="math inline">\(O(m\log
n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,ncnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> root[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!u||!v)<span class="keyword">return</span> u|v;</span><br><span class="line">  <span class="built_in">ls</span>(u)=<span class="built_in">merge</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v));</span><br><span class="line">  <span class="built_in">rs</span>(u)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v));</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!rt)rt=++ncnt;</span><br><span class="line">  <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">insert</span>(<span class="built_in">ls</span>(rt),l,mid,id);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span>&amp; v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!u)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">    v=<span class="built_in">merge</span>(u,v),u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!v)v=++ncnt;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">work</span>(<span class="built_in">ls</span>(u),<span class="built_in">ls</span>(v),l,mid,ml,mr);</span><br><span class="line">  <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">work</span>(<span class="built_in">rs</span>(u),<span class="built_in">rs</span>(v),mid+<span class="number">1</span>,r,ml,mr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getAns</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    ans[l]=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">getAns</span>(<span class="built_in">ls</span>(rt),l,mid,c);</span><br><span class="line">  <span class="built_in">getAns</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">insert</span>(root[x],<span class="number">1</span>,n,i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;	</span><br><span class="line">        <span class="built_in">read</span>(l,r,x,y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;	</span><br><span class="line">    <span class="built_in">work</span>(root[x],root[y],<span class="number">1</span>,n,l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">re</span>(i,<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">getAns</span>(root[i],<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF954F</title>
    <url>/2023/12/01/CF954F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF954F">Runner's
Problem</a></p>
<span id="more"></span>
<p>题目看起来就非常的<code>DP</code>。</p>
<p>设 <span class="math inline">\(f[i][j]\)</span> 为走到 <span
class="math inline">\((j,i)\)</span> 的方案数。</p>
<p>在没有障碍的前提下，可以直接转移： <span class="math display">\[
\begin{aligned}
f[i][1]=f[i-1][1]+f[i-1][2]
f[i][2]=f[i-1][1]+f[i-1][2]+f[i-1][3];
f[i][3]=f[i-1][2]+f[i-1][3]
\end{aligned}
\]</span> 复杂度为 <span
class="math inline">\(O(m)\)</span>，不太行。</p>
<p>线性递推，考虑矩阵加速。</p>
<p>容易构造一个矩阵：</p>
<p><span class="math display">\[
\begin{bmatrix}1&amp;1&amp;0\\1&amp;1&amp;1\\0&amp;1&amp;1\end{bmatrix}\times
\begin{bmatrix}f[n-1][1]\\f[n-1][2]\\f[n-1][3]\end{bmatrix}=\begin{bmatrix}f[n][1]\\f[n][2]\\f[n][3]\end{bmatrix}
\]</span></p>
<p>但我们要考虑障碍的处理。</p>
<p>其实也很简单，发现障碍区间个数为 <span
class="math inline">\(10^4\)</span>。所以可以直接将整个地图划分为若干个有相同障碍状态的段。</p>
<p>分段用不同的转移矩阵做快速幂就好了。（哪一行有障碍，就在转移矩阵中置
<span class="math inline">\(0\)</span>
哪一行），判断障碍需要离散化之后用差分前缀和做区间 <span
class="math inline">\(+1\)</span> 的标记。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n+27n\log
m)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) a[i][j] = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) a[i][j] = (i == j); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">origin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">rep</span>(k, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c.a[i][j] += a[i][k] * b.a[k][j] % Mod;</span><br><span class="line">            c.a[i][j] %= Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mat <span class="title">qpow</span><span class="params">(mat a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat res;</span><br><span class="line">    res.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line">ll m, bas[N], sum[<span class="number">3</span>][N];</span><br><span class="line"><span class="type">int</span> l[N], r[N], op[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op[i], l[i], r[i]);</span><br><span class="line">        op[i]--;</span><br><span class="line">        bas[++cnt] = l[i] - <span class="number">1</span>;</span><br><span class="line">        bas[++cnt] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bas[++cnt] = <span class="number">1</span>;</span><br><span class="line">    bas[++cnt] = m;</span><br><span class="line">    <span class="built_in">sort</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>) - bas - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = <span class="built_in">lower_bound</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>, l[i]) - bas;</span><br><span class="line">        r[i] = <span class="built_in">lower_bound</span>(bas + <span class="number">1</span>, bas + cnt + <span class="number">1</span>, r[i]) - bas;</span><br><span class="line">        sum[op[i]][l[i]]++;</span><br><span class="line">        sum[op[i]][r[i] + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">re</span>(i, cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[j][i] += sum[j][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    mat ans, t;</span><br><span class="line">    ans.<span class="built_in">reset</span>();</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">origin</span>();</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[j][i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.a[j][<span class="number">0</span>] = t.a[j][<span class="number">1</span>] = t.a[j][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">qpow</span>(t, bas[i] - bas[i - <span class="number">1</span>]);</span><br><span class="line">        ans = t * ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans.a[<span class="number">1</span>][<span class="number">0</span>], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P1350</title>
    <url>/2023/12/01/P1350/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1350">P1350
车的放置</a></p>
<span id="more"></span>
<p>首先 <span class="math inline">\(n\times n\)</span> 的正方形中放
<span class="math inline">\(n\)</span> 个的方案显然是 <span
class="math inline">\(n!\)</span>。</p>
<p>设 <span class="math inline">\(f(n,m,k)\)</span> 为的 <span
class="math inline">\(n\times m\)</span> 的矩形中选 <span
class="math inline">\(k\)</span> 个的方案：</p>
<p><span class="math inline">\(f(n,m,k)=\binom{n}{k}\binom{m}{k}\times
k!\)</span>。</p>
<p>在 <span class="math inline">\(n\)</span> 行 <span
class="math inline">\(m\)</span> 列中选 <span
class="math inline">\(k\)</span> 行<span
class="math inline">\(k\)</span> 列，然后放 <span
class="math inline">\(k\)</span> 个。</p>
<p>发现题目中这个图形有性质：如果划分为两个矩形，那么有一维将不再相互影响。</p>
<p>可以划分为上 <span class="math inline">\(a\times b\)</span> 和下
<span class="math inline">\((a+c)\times d\)</span>。</p>
<p>枚举在上面放了 <span class="math inline">\(k\)</span> 个中的 <span
class="math inline">\(i\)</span> 个。</p>
<p>答案为 <span class="math inline">\(\sum\limits_{i=0}^kf(a,b,i)\times
f(a+c-i,d,k-i)\)</span>。</p>
<p>有 <code>DP</code> 写法。设 <span
class="math inline">\(f[i][j]\)</span> 为 前 <span
class="math inline">\(i\)</span> 列放 <span
class="math inline">\(j\)</span> 个，<span
class="math inline">\(h[i]\)</span> 为第 <span
class="math inline">\(i\)</span> 列的高度。</p>
<p><span class="math inline">\(f[i][j]=f[i-1][j]+f[i-1][j-1]\times
(h[i]-j+1)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e3</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">1e5</span>+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a,b,c,d,k;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=inv[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)inv[i]=inv[i<span class="number">-1</span>]*inv[i]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[m]%Mod*inv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n||k&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n,k)*<span class="built_in">C</span>(m,k)%Mod*fac[k]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2e3</span>);</span><br><span class="line">    <span class="built_in">read</span>(a,b,c,d,k);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">calc</span>(a,b,i)*<span class="built_in">calc</span>(a+c-i,d,k-i)%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P2034</title>
    <url>/2023/12/01/P2034/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2034">P2034
选择数字</a></p>
<span id="more"></span>
<p>肯定是DP没跑了。</p>
<p>暴力 <span class="math inline">\(O(n^2)\)</span>
的DP多种多样，显然需要一些优化。</p>
<p>这种连续 <span class="math inline">\(k\)</span>
个的限制很像单调队列。</p>
<p>这种看起来像是需要单调队列优化的题，要把状态的转移向
“对前面一段枚举，找<span
class="math inline">\(\max\)</span>”的形式去靠近。</p>
<p>设 <span class="math inline">\(f[i][0/1]\)</span> 为前个数，第 <span
class="math inline">\(i\)</span> 个没选或者选了的最优答案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][0]=\max(f[i-1][0],f[i-1][1])\\
&amp;f[i][1]=\max_{j=i-k}^{i-1}f[j][0]+\sum_{t=j+1}^i a[t]
\end{aligned}
\]</span></p>
<p><span class="math inline">\(f[i][0]\)</span> 可以直接转移。</p>
<p>将 <span class="math inline">\(f[i][1]\)</span>
的转移改成的前缀和数组的差分形式：</p>
<p><span class="math display">\[
\begin{aligned}
f[i][1]&amp;=\max_{j=i-k}^{i-1}f[j][0]+s[i]-s[j]\\
&amp;=s[i]+\max_{j=i-k}^{i-1}f[j][0]-s[j]
\end{aligned}
\]</span></p>
<p>对后面的 <span class="math inline">\(\max\)</span>
用单调队列优化。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>单调队列最好先<code>push_back</code>一个 <span
class="math inline">\(0\)</span> 进去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">struct</span> <span class="title class_">Deque</span>&#123;</span><br><span class="line">    T q[N];</span><br><span class="line">    <span class="type">int</span> frt,bak;</span><br><span class="line">    <span class="built_in">Deque</span>()&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;q[<span class="number">1</span>]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[frt];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[bak];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bak-frt+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;frt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;bak--;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;q[++bak]=x;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (bak-frt+<span class="number">1</span>)&gt;<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,k,a[N];</span><br><span class="line">ll f[N][<span class="number">2</span>],sum[N];</span><br><span class="line">Deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;i-k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        f[i][<span class="number">1</span>]=sum[i]+f[q.<span class="built_in">front</span>()][<span class="number">0</span>]-sum[q.<span class="built_in">front</span>()];</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;f[q.<span class="built_in">back</span>()][<span class="number">0</span>]-sum[q.<span class="built_in">back</span>()]&lt;f[i][<span class="number">0</span>]-sum[i])&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2467</title>
    <url>/2023/12/02/P2467/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2467">P2467 [SDOI2010]
地精部落</a></p>
<span id="more"></span>
<p>实际上是让我们数阶的交替排列数</p>
<p>OEIS: <a href="https://oeis.org/A001250">A001250 - OEIS</a></p>
<p>设计 <code>DP</code>。</p>
<p>首先，发现阶山峰山谷状态只和第一个波谷的状态有关。</p>
<p>记 <span class="math inline">\(f[i][0/1]\)</span>：长度为 <span
class="math inline">\(i\)</span> 的排列，第一个是山峰/山谷的方案数。</p>
<p>先不管接口处的山峰山谷方案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">        f[i]+=f[j]*f[i<span class="number">-1</span>-j]*C[i<span class="number">-1</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(i\)</span> 是长度，<span
class="math inline">\(j\)</span> 是枚举到的当前最大值位置，前面放长为
<span class="math inline">\(j\)</span>，后面长为 <span
class="math inline">\(i-1-j\)</span> ，加上最大值，拼成长度 <span
class="math inline">\(i\)</span> 。（组合数是选 <span
class="math inline">\(j\)</span>
个放前面，当然后面不用乘组合数，已经被确定了）</p>
<p>当然 这样并没有考虑两段和最大值之间接口处的问题，可能出现不合法。</p>
<p>而 <span class="math inline">\(f[i][0/1]\)</span>
的状态显然可以推出最后一位的状态，所以我们可以直接通过 <span
class="math inline">\(f[i][0/1]\)</span> 做转移。</p>
<p>当最大的数放在偶数位后时，因为最大的数前的一定是山谷，所以是“峰-谷-峰-谷-最大值”，所以前面的山脉的开头就一定是山峰，后面的山脉开头一定要是山谷（如果原来就是山峰，是非法的），所以就可以得到一个正确的转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)f[i][<span class="number">1</span>]+=f[j][<span class="number">1</span>]*f[i<span class="number">-1</span>-j][<span class="number">0</span>]*C[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>
<p>当最大的数放在奇数位后时，同理，是"谷-峰-谷-最大值"，前面的开头是山谷，后面的开头是山谷。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(j%<span class="number">2</span>)f[i][<span class="number">0</span>]+=f[j][<span class="number">0</span>]*f[i<span class="number">-1</span>-j][<span class="number">0</span>]*C[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>
<p>考虑到波峰和波谷有天然的对称性，所以其实可以只求一个的值，最后乘二。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>组合数开<code>long long</code>会爆空间，内存如果再紧一些需要滚动数组求组合数（同一层外层循环都是
<span class="math inline">\(C[i-1][x]\)</span>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">4205</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,i)&#123;</span><br><span class="line">            C[i][j]=(<span class="number">1ll</span>*C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">2</span>)&#123;</span><br><span class="line">                f[i]+=C[i<span class="number">-1</span>][j]*f[j]%p*f[i-j<span class="number">-1</span>]%p;</span><br><span class="line">                f[i]%=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n]*<span class="number">2</span>%p,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P2839</title>
    <url>/2023/12/02/P2839/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2839">P2839 [国家集训队]
middle</a></p>
<span id="more"></span>
<p>中位数相关。</p>
<p>设有一数列 <span class="math inline">\(a\)</span>，如果将 <span
class="math inline">\(a\)</span> 大于等于 <span
class="math inline">\(x\)</span> 的数改为 <span
class="math inline">\(1\)</span>，否则改为 <span
class="math inline">\(-1\)</span>，那么 <span class="math inline">\(\sum
a\ge 0\)</span> 和 中位数 <span class="math inline">\(\ge x\)</span>
是互为充要条件的。</p>
<p>显然具有单调性，对中位数二分。</p>
<p>对于某个 <span class="math inline">\(x\)</span>
来说，我们取出来的数当然 <span class="math inline">\(1\)</span>
越多越好。</p>
<p>现在的问题是找一个符合题意的区间，区间内 <span
class="math inline">\(1\)</span>，<span
class="math inline">\(-1\)</span> 之和最大。</p>
<p>对值域建主席树，第 <span class="math inline">\(i\)</span>
棵树需要考虑的信息为：第 <span class="math inline">\(i-1\)</span> 棵和
<span class="math inline">\(a\)</span> 中第 <span
class="math inline">\(i\)</span>
小的数，每次只会更改一位，保证了复杂度。</p>
<p>主席树中第 <span class="math inline">\(x\)</span>
棵线段树维护：当前二分到 <span
class="math inline">\(x\)</span>，数组改为 <span
class="math inline">\(1\)</span> 或 <span
class="math inline">\(-1\)</span>
形式下，下标上每个区间的前缀和后缀和最大值 和 区间和。</p>
<p>因为在 <span class="math inline">\([a,b]\)</span> 和 <span
class="math inline">\([c,d]\)</span>
段要取后缀与前缀，中间的部分必须被取到，是区间 <span
class="math inline">\([b,c]\)</span>（如果两区间不交）。</p>
<p>值域过大，将 <span class="math inline">\(a[i]\)</span> 重定义为：第
<span class="math inline">\(i\)</span> 小的数在 <span
class="math inline">\(a\)</span> 中位置 即可。</p>
<p>注意不能直接离散化，重复的数要当做不同来处理。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N],q,id[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dat</span>&#123;</span><br><span class="line">    <span class="type">int</span> pre,suf,sum;</span><br><span class="line">    <span class="built_in">Dat</span>()&#123;pre=suf=-inf,sum=<span class="number">0</span>;&#125;</span><br><span class="line">    Dat <span class="keyword">operator</span>+(<span class="type">const</span> Dat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        Dat c;</span><br><span class="line">        c.pre=<span class="built_in">max</span>(pre,sum+b.pre);</span><br><span class="line">        c.suf=<span class="built_in">max</span>(b.suf,suf+b.sum);</span><br><span class="line">        c.sum=sum+b.sum;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    Dat v;</span><br><span class="line">&#125;t[N*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> ncnt,rot[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    rt=++ncnt;</span><br><span class="line">    t[rt].v.pre=t[rt].v.suf=t[rt].v.sum=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; rt,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    rt=++ncnt;</span><br><span class="line">    t[rt]=t[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        t[rt].v.sum=t[rt].v.pre=t[rt].v.suf=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),<span class="built_in">ls</span>(old),l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),<span class="built_in">rs</span>(old),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    t[rt].v=t[<span class="built_in">ls</span>(rt)].v+t[<span class="built_in">rs</span>(rt)].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dat <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[rt].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr)+<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> qr[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr[<span class="number">1</span>]+<span class="number">1</span>&lt;=qr[<span class="number">2</span>]<span class="number">-1</span>)&#123;</span><br><span class="line">        res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">1</span>]+<span class="number">1</span>,qr[<span class="number">2</span>]<span class="number">-1</span>).sum;</span><br><span class="line">    &#125;</span><br><span class="line">    res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">0</span>],qr[<span class="number">1</span>]).suf;</span><br><span class="line">    res+=<span class="built_in">query</span>(rot[x],<span class="number">1</span>,n,qr[<span class="number">2</span>],qr[<span class="number">3</span>]).pre;</span><br><span class="line">    <span class="keyword">return</span> res&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        id[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[x]&lt;a[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">build</span>(rot[<span class="number">1</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(rot[i],rot[i<span class="number">-1</span>],<span class="number">1</span>,n,id[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(qr[i]);</span><br><span class="line">            qr[i]=(qr[i]+ans)%n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(qr,qr+<span class="number">4</span>);</span><br><span class="line">        l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                ans=a[id[mid]];</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3175</title>
    <url>/2023/12/02/P3175/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3175">P3175 [HAOI2015]
按位或</a></p>
<span id="more"></span>
<p>题目涉及“第一次到达某个状态”，可以尝试<code>min-max</code>容斥。</p>
<p>首先对题目做转化：把所有二进制码看做集合。</p>
<p>有一个较为经典的想法：在组成集合 <span
class="math inline">\(S\)</span> 的过程中，第一个被放入 <span
class="math inline">\(S\)</span> 的元素的选中时间为 <span
class="math inline">\(min(S)\)</span>，最后一个被放入的元素的选中时间为
<span
class="math inline">\(max(S)\)</span>（这里不是实际最值，是时间戳的最值，这样写只是好看）</p>
<p>这里 <span class="math inline">\(max\)</span>
就是第一次到达某状态时间。</p>
<p>有<code>min-max</code>容斥的式子：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T)\\
&amp;E(max(S))=\sum_{T\subseteq S}(-1)^{|T|+1}E(min(T))
\end{aligned}
\]</span></p>
<p>当然，期望意义也成立，这是min-max容斥很好的性质。</p>
<p>显然，答案为 <span class="math inline">\(E(max(U))\)</span></p>
<p>现在考虑如何去求 <span class="math inline">\(E(min(S))\)</span>。</p>
<p>发现 <span class="math inline">\(E(min(S))\)</span> 就是和 <span
class="math inline">\(S\)</span> 有交的集合第一次被选中的期望时间。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;E(min(S))=\frac{1}{\sum_{T\cap S\ne \varnothing}p[T]}
\end{aligned}
\]</span></p>
<p>期望是概率的倒数。</p>
<p>但我们比较难去对于 <span class="math inline">\(2^n\)</span>
种集合的每一种去求一遍有交集合的概率和。</p>
<p>正难则反，考虑去求他没有交集的概率和，用 <span
class="math inline">\(1\)</span> 减去它就是上面的答案了（原因显然）</p>
<p>问题也就转化成：补集的每一个子集的概率和。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;E(min(S))=\frac{1}{1-\sum_{T\subseteq\complement_US}p[T]}
\end{aligned}
\]</span></p>
<p>后面那个和式的形式非常经典，可以做一遍FWT的或卷积，或者用高维前缀和（子集和DP）。</p>
<p>求出 <span class="math inline">\(E(min(S))\)</span>
后再套进最上面的容斥式子，就是答案。</p>
<p>时间复杂度 <span
class="math inline">\(O(n2^n)\)</span>，可以通过。</p>
<p>代码里两种做子集和的方式都写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">orFWT</span><span class="params">(<span class="type">double</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,r=i&lt;&lt;<span class="number">1</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j+=r)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">                A[i+j+k]+=A[j+k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SoSDP</span><span class="params">(<span class="type">double</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                A[j]+=A[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// orFWT(f);</span></span><br><span class="line">    <span class="built_in">SoSDP</span>(f);</span><br><span class="line">    <span class="type">int</span> cs=<span class="number">0</span>,op=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(s,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line">        cs=((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^s;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>-f[cs]&lt;eps)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;INF\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        op=(__builtin_popcount(s)&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        ans+=<span class="number">1</span>/(<span class="number">1</span>-f[cs])*op;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
        <tag>子集和DP</tag>
        <tag>概率与期望</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P3403</title>
    <url>/2023/12/02/P3403/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3403">P3403 跳楼机</a></p>
<span id="more"></span>
<p>这是同余最短路的经典问题。</p>
<p><span class="math inline">\(n\)</span>
很大，考虑可以到达的楼层的分布规律。</p>
<p>可以发现，如果我们能到第 <span class="math inline">\(n\)</span>
层，也一定能到 <span class="math inline">\(n+x\)</span> 层（<span
class="math inline">\(y,z\)</span> 同理）。</p>
<p>也就是说 我们只需要判断 <span class="math inline">\(x\)</span>
的同余类中是否能走到即可。</p>
<p>如何判断呢？</p>
<p>让 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(i+y\mod x\)</span>，<span
class="math inline">\(i+z \mod x\)</span> 连边，边权分别为 <span
class="math inline">\(y,z\)</span> 和。</p>
<p>跑最短路，只要最短路小于等于 <span
class="math inline">\(h\)</span>，我们就可以在全程高度不超过 <span
class="math inline">\(h\)</span> 的前提下到达某个同余类。</p>
<p>显然，同余最短路可以拓展到 <span class="math inline">\(m\)</span>
种上升方式，设每次爬升高度的值域为 <span
class="math inline">\(v\)</span>，复杂度为 <span
class="math inline">\(O(vm\log v)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> h,x,y,z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">  <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  e[++ecnt].to=v;</span><br><span class="line">  e[ecnt].w=w;</span><br><span class="line">  e[ecnt].nxt=head[u];</span><br><span class="line">  head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mkp</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    u=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">      v=e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mkp</span>(dis[v],v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  CIOO;</span><br><span class="line">  cin&gt;&gt;h&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">  h--;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">ae</span>(i,(i+y)%x,y);</span><br><span class="line">    <span class="built_in">ae</span>(i,(i+z)%x,z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dij</span>();</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i]&lt;=h)&#123;</span><br><span class="line">      ans+=(h-dis[i])/x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P3604</title>
    <url>/2023/12/02/P3604/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3604">P3604
美好的每一天</a></p>
<span id="more"></span>
<p>只有简单区间询问 和 不太好求的答案，想到莫队。</p>
<p>显然，能构成一个回文串的区间，内部一定至多有一种字符有奇数个。</p>
<p>发现字符集很小（26），而且我们只关注奇偶性：考虑状压。</p>
<p>可以预处理出每个 <span class="math inline">\([1,i]\)</span>
前缀内每个字符的奇偶性状态。</p>
<p>因为奇偶性的状态等价于异或，对异或前缀和 <span
class="math inline">\(s\)</span> 直接差分即可查询区间信息。</p>
<p>思考什么样的区间异或值可以对答案产生贡献：至多有一个位置为1。</p>
<p>问题转化为：区间 <span class="math inline">\([l,r]\)</span> 内有多少
<span class="math inline">\((x,y)\)</span>，使得 <span
class="math inline">\(s_y\oplus s_{x-1}\)</span> 至多只有一位为1（<span
class="math inline">\(x\le y\)</span>）。</p>
<p>现在可以莫队了。</p>
<p>加入/删除一个位置 <span
class="math inline">\(x\)</span>，考虑其他位置和这个位置匹配成 <span
class="math inline">\((x,y)\)</span>
能产生多少贡献，也就是看有多少个满足至多只有一位为1（复读）。</p>
<p>算答案很简单，要么 <span
class="math inline">\(s_x=s_y\)</span>，要么就枚举为 <span
class="math inline">\(1\)</span> 的是哪一位。</p>
<p>时间复杂度 <span
class="math inline">\(O(26n\sqrt{n})\)</span>，莫队不要忘了
先算后加，先删后算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">6e4</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,B,a[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> qry&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l/B==b.l/B)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((l/B)&amp;<span class="number">1</span>)?r&lt;b.r:r&gt;b.r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l&lt;b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line">ll nowans,ans[N];</span><br><span class="line"><span class="type">int</span> cnt[(<span class="number">1</span>&lt;&lt;<span class="number">26</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    nowans+=cnt[a[x]];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        nowans+=cnt[a[x]^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">    nowans-=cnt[a[x]];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        nowans-=cnt[a[x]^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    B=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    cin&gt;&gt;(str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        a[i]=(<span class="number">1</span>&lt;&lt;(str[i]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        a[i]^=a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        q[i]=(qry)&#123;l,r,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l<span class="number">-1</span>)<span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l<span class="number">-1</span>)<span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r)<span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r)<span class="built_in">add</span>(++r);</span><br><span class="line">        ans[q[i].id]=nowans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>P3964</title>
    <url>/2023/12/02/P3964/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3964">P3964 [TJOI2013]
松鼠聚会</a></p>
<span id="more"></span>
<p>是一个小trick。</p>
<p>观察题目，两点距离的定义其实是 切比雪夫距离，也叫棋盘距离。</p>
<p>考虑暴力怎么做：枚举 <span class="math inline">\(j\)</span>，求 <span
class="math inline">\(\min\sum_{i=1}^ndis((x_i,y_i),(x_j,y_j))\)</span>。</p>
<p>枚举 <span class="math inline">\(j\)</span>
很难优化，考虑优化求和。</p>
<p>切比雪夫距离很难快速求和，但可以转化为 曼哈顿距离。</p>
<blockquote>
<p>曼哈顿坐标系是通过切比雪夫坐标系旋转 <span
class="math inline">\(45\degree\)</span>
后，缩小到原来的一半得到的。</p>
</blockquote>
<blockquote>
<p>将一个点 <span class="math inline">\((x,y)\)</span> 的坐标转化为
<span class="math inline">\((x+y,x-y)\)</span>
后，原坐标系中曼哈顿距离等于新坐标系中切比雪夫距离。</p>
</blockquote>
<blockquote>
<p>将一个点 <span class="math inline">\((x,y)\)</span> 的坐标转化为
<span class="math inline">\((\frac{x+y}{2},\frac{x-y}{2})\)</span>
后，原坐标系中切比雪夫距离等于新坐标系中曼哈顿距离。</p>
</blockquote>
<p>我们可以将 <span class="math inline">\((x,y)\)</span> 都转为 <span
class="math inline">\((\frac{x+y}{2},\frac{x-y}{2})\)</span>，但是小数容易有精度误差，所以可以转为
<span class="math inline">\((x+y,x-y)\)</span> 后再对距离之和除 <span
class="math inline">\(2\)</span>。</p>
<p>对曼哈顿距离的求和是很好做的。</p>
<p>拆绝对值就完事了。</p>
<p>拆出来 <span
class="math inline">\(\sum\limits_{i=1}^n|x_i-x_j|+\sum\limits_{i=1}^n|y_i-y_j|\)</span></p>
<p>将 <span class="math inline">\(x,y\)</span> 排序，二分找到分界点
<span class="math inline">\(p_x,p_y\)</span>。</p>
<p>式子变成 <span class="math inline">\(\sum\limits_{i=1}^{p_x}
x_j-x_i+\sum\limits_{i=p_x+1}^nx_i-x_j\)</span>，<span
class="math inline">\(y\)</span> 同理。</p>
<p>对排序后的数组求前缀和 <span
class="math inline">\(sx,sy\)</span>。</p>
<p>上面的和式转化为 <span class="math inline">\(x_j\times
p_x-sx_{p_x}+sx_n-sx_{p_x}-x_j\times(n-p_x)\)</span>，<span
class="math inline">\(y\)</span> 同理。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,x[N],y[N],bax[N],bay[N];</span><br><span class="line">ll sumx[N],sumy[N];</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rx=<span class="built_in">lower_bound</span>(bax+<span class="number">1</span>,bax+n+<span class="number">1</span>,x[i])-bax;</span><br><span class="line">    <span class="type">int</span> ry=<span class="built_in">lower_bound</span>(bay+<span class="number">1</span>,bay+n+<span class="number">1</span>,y[i])-bay;</span><br><span class="line">    <span class="keyword">return</span> rx*<span class="number">1ll</span>*x[i]-sumx[rx]-(n-rx)*<span class="number">1ll</span>*x[i]+sumx[n]-sumx[rx]+</span><br><span class="line">        ry*<span class="number">1ll</span>*y[i]-sumy[ry]-(n-ry)*<span class="number">1ll</span>*y[i]+sumy[n]-sumy[ry];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> xi=<span class="number">0</span>,yi=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(xi,yi);</span><br><span class="line">        x[i]=bax[i]=xi+yi;</span><br><span class="line">        y[i]=bay[i]=xi-yi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(bax+<span class="number">1</span>,bax+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        sumx[i]=sumx[i<span class="number">-1</span>]+bax[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(bay+<span class="number">1</span>,bay+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        sumy[i]=sumy[i<span class="number">-1</span>]+bay[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">calc</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    ans/=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>距离相关</tag>
      </tags>
  </entry>
  <entry>
    <title>P4151</title>
    <url>/2023/12/02/P4151/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4151">P4151 [WC2011]
最大XOR和路径</a></p>
<span id="more"></span>
<p>题意非常简明：求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最大异或路径和。</p>
<p>很重要的一点：这是个联通无向图。</p>
<p>发现我们从 <span class="math inline">\(1\)</span> 走到 <span
class="math inline">\(n\)</span> 的路径可以看做：走了一条 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
单向的路径，然后在单向路径上多次进行：向外走到某个环，在环上绕一圈再原路返回。</p>
<p>我们只关心对异或和有贡献的部分，发现有贡献的只有经过一次的边——也就是那些环和中间这条路径。</p>
<p>问题被极大的简化。</p>
<p>我们在树上找到所有简单环（只有一条返祖边），用异或和差分出每个环的权值，塞到线性基里。</p>
<p>注：可以发现，多条返祖边之间各种连接的“复杂环”都能通过这些简单环异或得到。</p>
<p>环的部分解决了：用线性基求最大异或子集和。</p>
<p>问题在于，中间的单向路径怎么选。</p>
<p>有一个很巧妙的想法：中间这条路径其实并不重要。</p>
<p>因为所有单向路径的起点和终点都是和，也就是说，可以用任意两个合法的路径拼成一个环。</p>
<p>而所有的环我们都塞到线性基里了，任意一个路径都可以通过异或某一个大环得到另一个合法路径。所以任选一个路径即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log
D)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e4</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span>,<span class="title">lgD</span><span class="params">(<span class="number">70</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">ll path[N];</span><br><span class="line">ll num[lgD];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">63</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!num[i])&#123;</span><br><span class="line">                num[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x^=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getMax</span><span class="params">(ll num0)</span></span>&#123;</span><br><span class="line">    ll res=num0;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">63</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,res^num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll now)</span></span>&#123;</span><br><span class="line">    path[u]=now,vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,now^e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">insert</span>(now^path[v]^e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    ll w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="built_in">getMax</span>(path[n]);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>P4211</title>
    <url>/2023/12/02/P4211/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4211">P4211 [LNOI2014]
LCA</a></p>
<span id="more"></span>
<p>题目求：<span
class="math inline">\(\sum\limits_{i=l}^rdep[lca(i,z)]\)</span>。</p>
<p>首先发现：没有强制在线，<span class="math inline">\([l,r]\)</span>
内的点在树上分布没有规律，尝试在点编号上前缀和-差分，但 <span
class="math inline">\(z\)</span> 的问题没有解决。</p>
<p>如果只是一个二维的问题 <span
class="math inline">\(f(l,r)\)</span>，可以转为 <span
class="math inline">\(F(r)-F(l-1)\)</span>
在一维内快速解决，但是问题是三维的。</p>
<p>前两维依然做前缀和-差分，第三维扔进<code>DS</code>。用数据结构的每一个“位置”对应当前前缀
<span class="math inline">\(pos\)</span> 的每一个 <span
class="math inline">\(z\)</span>，快速对每个 <span
class="math inline">\(z\)</span> 做 <span
class="math inline">\(F(pos-1,z)\)</span> 到 <span
class="math inline">\(F(pos,z)\)</span> 的转移。</p>
<p>显然要满足：在 <span class="math inline">\(pos\)</span>
这一维上修改，在 <span class="math inline">\(z\)</span> 上需要查询。</p>
<p>不太好直接做啊。</p>
<p>转化问题，考虑一种“拆贡献”：把 <span
class="math inline">\(dep[i]\)</span> 拆了。转化成 <span
class="math inline">\(i\)</span> 到根的点做点权 <span
class="math inline">\(+1\)</span>（废话）</p>
<p>问题转化为在 <span class="math inline">\(z\)</span> 到根的路径上
<span class="math inline">\(+1\)</span>，求 <span
class="math inline">\(i\)</span> 到根的权值和之和，<span
class="math inline">\(i\in[l,r]\)</span></p>
<p>再做一步转化，进一步发现，这个问题和另一个问题等价：<span
class="math inline">\(l\)</span> 到 <span
class="math inline">\(r\)</span> 的每一个点，到根的路径上 <span
class="math inline">\(+1\)</span>，求 <span
class="math inline">\(z\)</span> 到根的权值和。</p>
<p>现在终于得到了好做的东西，满足了快速转移 <span
class="math inline">\(F\)</span> 的条件。</p>
<p>把询问全部离线，在 <span class="math inline">\(r\)</span>
上放一个正标记 <span class="math inline">\(z\)</span>，<span
class="math inline">\(l-1\)</span> 上放一个负标记 <span
class="math inline">\(z\)</span>（差分），用线段树+树剖维护当前的 <span
class="math inline">\(pos\)</span>，每个 <span
class="math inline">\(z\)</span> 的状态 <span
class="math inline">\(F(pos,z)\)</span>。</p>
<p>每次对 <span class="math inline">\(pos\)</span> 到根上路径全部 <span
class="math inline">\(+1\)</span>，相当于做了 <span
class="math inline">\(\forall z,F(pos-1,z)\to F(pos,z)\)</span>
，扫到标记就给对应的询问加上正或负的贡献。</p>
<p>非常的好做啊。</p>
<p>总时间复杂度 <span class="math inline">\(O((n+q)\log^2
n)\)</span>，可以通过。</p>
<p>在数据结构部分还有优化空间：只有链修改，全局平衡二叉树可以做到小常数的
<span class="math inline">\(O((n+q)\log
n)\)</span>，非常牛啊，摆了不想写。</p>
<p>点编号从 <span class="math inline">\(0\)</span> 开始，代码里都加了
<span class="math inline">\(1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e4</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">201314</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N],hson[N],top[N],idx[N],dfn[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[hson[u]]&lt;siz[v])&#123;</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp,idx[u]=++dfncnt;</span><br><span class="line">    dfn[dfncnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(hson[u]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],tp);</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==hson[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCP</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum,lz,len;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].sum=t[<span class="built_in">ls</span>(rt)].sum+t[<span class="built_in">rs</span>(rt)].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].len=r-l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        t[rt].sum+=v*t[rt].len;</span><br><span class="line">        t[rt].lz+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[rt].lz)&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">            <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">            t[rt].lz=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(rt,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,v);</span><br><span class="line">        <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,v);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> t[rt].sum;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt);</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid)res+=<span class="built_in">query</span>(<span class="built_in">ls</span>(rt),l,mid,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid)res+=<span class="built_in">query</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modPath</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[u],val);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qryPath</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            res+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,idx[top[u]],idx[u]);</span><br><span class="line">            u=fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> ans[N],ask[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; L[N],R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(fa[i]);</span><br><span class="line">        fa[i]++;</span><br><span class="line">        <span class="built_in">ae</span>(fa[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l,r,ask[i]);</span><br><span class="line">        L[l].<span class="built_in">pb</span>(i);</span><br><span class="line">        R[r+<span class="number">1</span>].<span class="built_in">pb</span>(i);</span><br><span class="line">        ask[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        t.<span class="built_in">modPath</span>(i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">each</span>(j,L[i])&#123;</span><br><span class="line">            ans[j]-=t.<span class="built_in">qryPath</span>(ask[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">each</span>(j,R[i])&#123;</span><br><span class="line">            ans[j]+=t.<span class="built_in">qryPath</span>(ask[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">write</span>((ans[i]%Mod+Mod)%Mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>重链剖分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>P4309</title>
    <url>/2023/12/02/P4309/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4309">P4309 [TJOI2013]
最长上升子序列</a></p>
<span id="more"></span>
<p>先考虑暴力<code>DP</code>的转移。</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为前 <span
class="math inline">\(i\)</span> 个数的<code>LIS</code>长度。</p>
<p>先把后面的 <span class="math inline">\(f\)</span>
数组整体后移一位；因为插入的数是从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
的，所以新加入的数一定可以让前面的<code>LIS</code>长度 <span
class="math inline">\(+1\)</span>。</p>
<p>设插入的位置为 <span class="math inline">\(i\)</span>：</p>
<ol type="1">
<li>将 <span class="math inline">\(f[i]\)</span> 到 <span
class="math inline">\(f[n]\)</span> 全部后移一位，空出 <span
class="math inline">\(f[i]\)</span>。</li>
<li><span
class="math inline">\(f[i]=\max\limits_{j=1}^if[j]+1\)</span></li>
</ol>
<p>时间复杂度 <span
class="math inline">\(O(n^2)\)</span>，不可接受。</p>
<p>发现两种操作均可以用平衡树加速，做到单次操作 <span
class="math inline">\(O(\log n)\)</span>。</p>
<p>具体一点（均使用<code>FHQ-Treap</code>）：</p>
<p>操作 <span class="math inline">\(1\)</span>
其实是插入了一个数，因为此题操作的下标和插入的值相同，所以不需要考虑顺序问题，<code>split</code>的时候直接找值就可以保证找到的是一个前缀。</p>
<p>操作只需要按 <span class="math inline">\(i\)</span>
做<code>split</code>，插入的新节点的 <span
class="math inline">\(f[i]\)</span> 为：左边子树维护好的最大值 <span
class="math inline">\(+1\)</span>。</p>
<p>每次查询输出全局最大即可。</p>
<p>总复杂度 <span class="math inline">\(O(n\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BT</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>], siz, wei;</span><br><span class="line">    <span class="type">int</span> val, mx;</span><br><span class="line">  &#125; t[N];</span><br><span class="line">  <span class="type">int</span> root, ncnt;</span><br><span class="line">  mt19937 rnd;</span><br><span class="line">  <span class="built_in">BT</span>() &#123;</span><br><span class="line">    root = ncnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ++ncnt;</span><br><span class="line">    <span class="built_in">ls</span>(ncnt) = <span class="built_in">rs</span>(ncnt) = <span class="number">0</span>;</span><br><span class="line">    t[ncnt].val = t[ncnt].mx = val, t[ncnt].siz = <span class="number">1</span>;</span><br><span class="line">    t[ncnt].wei = <span class="built_in">rnd</span>();</span><br><span class="line">    <span class="keyword">return</span> ncnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].mx = <span class="built_in">max</span>(&#123;t[rt].val, t[<span class="built_in">ls</span>(rt)].mx, t[<span class="built_in">rs</span>(rt)].mx&#125;);</span><br><span class="line">    t[rt].siz = t[<span class="built_in">ls</span>(rt)].siz + t[<span class="built_in">rs</span>(rt)].siz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> k, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) &#123;x = y = <span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= t[<span class="built_in">ls</span>(rt)].siz)y = rt, <span class="built_in">split</span>(<span class="built_in">ls</span>(rt), k, x, <span class="built_in">ls</span>(rt));</span><br><span class="line">    <span class="keyword">else</span> x = rt, <span class="built_in">split</span>(<span class="built_in">rs</span>(rt), k - t[<span class="built_in">ls</span>(rt)].siz - <span class="number">1</span>, <span class="built_in">rs</span>(rt), y);</span><br><span class="line">    <span class="built_in">update</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)<span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (t[x].wei &lt;= t[y].wei) &#123;</span><br><span class="line">      <span class="built_in">ls</span>(y) = <span class="built_in">merge</span>(x, <span class="built_in">ls</span>(y));</span><br><span class="line">      <span class="built_in">update</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">rs</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(x), y);</span><br><span class="line">      <span class="built_in">update</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">split</span>(root, pos, x, y);</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">newnode</span>(t[x].mx + <span class="number">1</span>);</span><br><span class="line">    root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x, z), y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t[root].mx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    bt.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="built_in">write</span>(bt.<span class="built_in">getAns</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4314</title>
    <url>/2023/12/02/P4314/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4314">P4314 CPU
监控</a></p>
<span id="more"></span>
<p>题面非常的线段树。</p>
<p>翻译一下：</p>
<ol type="1">
<li>询问区间最大值</li>
<li>询问区间历史最大值</li>
<li>区间加</li>
<li>区间推平</li>
</ol>
<p>我们把lazy tag看做一个区间被执行的操作序列。</p>
<p>那么pushdown操作就是把父节点的操作序列接在左右儿子的操作序列<strong>后面</strong></p>
<p>显然，在操作序列上，相邻的区间加 和
相邻的区间推平，都可以直接合并。</p>
<p>所以操作序列就形如：</p>
<p>加，推，加，推……</p>
<p>有一个较为容易的观察：区间推平后面的区间加，相当于移动了区间推平的“高度”。</p>
<p>那么两种操作也可以合并了。</p>
<p>pushdown应该先下传区间加的tag，因为区间加可以合并到区间推平上。</p>
<p>每次修改最大值的时候，历史最值对当前最值取即可。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log n)\)</span>。</p>
<p>代码做了很多封装，可读性上不如全部展开写，放在这里更多做模板（Ctrl+C）作用。</p>
<p>（尝试写了指针版线段树，感觉也挺好看的，和数组版本没有本质区别）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,q,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">    <span class="type">int</span> add,cov;</span><br><span class="line">    <span class="built_in">dat</span>(<span class="type">int</span> aa=<span class="number">0</span>,<span class="type">int</span> cc=-inf) &#123;add=aa;cov=cc;&#125;</span><br><span class="line">    dat <span class="keyword">operator</span> +(<span class="type">const</span> dat &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">dat</span>(<span class="built_in">max</span>(-inf,add+a.add),<span class="built_in">max</span>(a.cov,cov+a.add));&#125;</span><br><span class="line">    dat <span class="keyword">operator</span> *(<span class="type">const</span> dat &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">dat</span>(<span class="built_in">max</span>(add,a.add),<span class="built_in">max</span>(cov,a.cov));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,mx,hmx;</span><br><span class="line">    dat laz,hlaz;</span><br><span class="line">    SegT *son[<span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ls son[0]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rs son[1]</span></span><br><span class="line">    <span class="built_in">SegT</span>()&#123;</span><br><span class="line">        L=R=mx=hmx=<span class="number">0</span>;</span><br><span class="line">        laz=hlaz=<span class="built_in">dat</span>();</span><br><span class="line">        ls=rs=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(ls-&gt;mx,rs-&gt;mx);</span><br><span class="line">        hmx=<span class="built_in">max</span>(ls-&gt;hmx,rs-&gt;hmx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> dat&amp; now,<span class="type">const</span> dat&amp; his)</span></span>&#123;</span><br><span class="line">        hlaz=hlaz*(laz+his);</span><br><span class="line">        laz=laz+now;</span><br><span class="line">        hmx=<span class="built_in">max</span>(&#123;hmx,mx+his.add,his.cov&#125;);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx+now.add,now.cov);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ls-&gt;<span class="built_in">update</span>(laz,hlaz);</span><br><span class="line">        rs-&gt;<span class="built_in">update</span>(laz,hlaz);</span><br><span class="line">        laz=hlaz=<span class="built_in">dat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        L=l,R=r;</span><br><span class="line">        <span class="keyword">if</span>(L==R)&#123;mx=hmx=a[L];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (ls=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(L,mid);</span><br><span class="line">        (rs=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">        <span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">const</span> dat&amp; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R)&#123;<span class="built_in">update</span>(v,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="built_in">pushdown</span>();</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;mid)rs-&gt;<span class="built_in">modify</span>(l,r,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;=mid)ls-&gt;<span class="built_in">modify</span>(l,r,v);</span><br><span class="line">        <span class="keyword">else</span> ls-&gt;<span class="built_in">modify</span>(l,mid,v),rs-&gt;<span class="built_in">modify</span>(mid+<span class="number">1</span>,r,v);</span><br><span class="line">        <span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">bool</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R)&#123;<span class="keyword">return</span> op?hmx:mx;&#125;</span><br><span class="line">        <span class="built_in">pushdown</span>();</span><br><span class="line">        <span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;mid)<span class="keyword">return</span> rs-&gt;<span class="built_in">query</span>(l,r,op);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> ls-&gt;<span class="built_in">query</span>(l,r,op);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ls-&gt;<span class="built_in">query</span>(l,mid,op),rs-&gt;<span class="built_in">query</span>(mid+<span class="number">1</span>,r,op));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;*rt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    (rt=<span class="built_in">new</span>(SegT))-&gt;<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            rt-&gt;<span class="built_in">modify</span>(x,y,<span class="built_in">dat</span>(z,-inf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            rt-&gt;<span class="built_in">modify</span>(x,y,<span class="built_in">dat</span>(-inf,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;rt-&gt;<span class="built_in">query</span>(x,y,<span class="number">0</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;rt-&gt;<span class="built_in">query</span>(x,y,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4322</title>
    <url>/2023/12/02/P4322/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4322">P4322 [JSOI2016]
最佳团体</a></p>
<span id="more"></span>
<p>一眼盯真，鉴定为：分数规划。</p>
<p>先转化题目中选点的约束：选包含根（节点0）的某一个连通块，最大化 <span
class="math inline">\(\frac{\sum P_i}{\sum S_i}\)</span>。</p>
<p>这个选点的限制显然可以用树上背包。</p>
<p>设 <span class="math inline">\(f[u][i]\)</span> 为 <span
class="math inline">\(u\)</span> 子树内选 <span
class="math inline">\(i\)</span> 个点，最优答案。</p>
<p><span class="math inline">\(f[u][i]\)</span> 可以从 <span
class="math inline">\(f[u][i-j]+f[v][j]\)</span> 转移而来，<span
class="math inline">\(v\)</span> 为 <span
class="math inline">\(u\)</span> 的儿子。</p>
<p>01分数规划当然要二分答案。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\dfrac{\sum P_i}{\sum S_i}\ge mid\\
&amp;\sum P_i\ge \sum S_i\times mid\\
&amp;\sum P_i-S_i\times mid\ge 0
\end{aligned}
\]</span></p>
<p>以 <span class="math inline">\(P_i-S_i\times mid\)</span>
为点权，跑树上背包即可check。</p>
<p>时间复杂度为 <span class="math inline">\(O(n^2\log V)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-5</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2505</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> tar,n,s[N],p[N],r[N],fa[N];</span><br><span class="line"><span class="type">double</span> wei[N],f[N][N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=wei[u],siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="built_in">DP</span>(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="built_in">pe</span>(i,<span class="built_in">min</span>(siz[u],tar+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(siz[v],i<span class="number">-1</span>))&#123;</span><br><span class="line">                f[u][i]=<span class="built_in">max</span>(f[u][i],f[u][i-j]+f[v][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        wei[i]=p[i]-x*s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fill</span>(f[i],f[i]+tar+<span class="number">2</span>,<span class="number">-1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DP</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][tar+<span class="number">1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;tar&gt;&gt;n;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cin&gt;&gt;s[i]&gt;&gt;p[i]&gt;&gt;fa[i];</span><br><span class="line">        G[fa[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">10000</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;l&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>分数规划</tag>
        <tag>背包</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P4630</title>
    <url>/2023/12/02/P4630/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4630">P4630 [APIO2018]
铁人两项</a></p>
<span id="more"></span>
<p>圆方树基础应用。</p>
<p>观察题目，发现能对 <span class="math inline">\(s,f\)</span> 贡献的
<span class="math inline">\(c\)</span> 集合为：<span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(f\)</span> 所有简单路径的并。</p>
<p>无向图上要求路径上每个点最多走一次，想到点双。</p>
<p>因为将无向图中点双缩成点之后，图上是没有环的。</p>
<p>也就是说任意点双之间路径唯一，那么只有在 <span
class="math inline">\(s,f\)</span> 路径上的点双才能包含合法的 <span
class="math inline">\(c\)</span>。</p>
<p>设 <span class="math inline">\(s,f\)</span> 上点双的集合为 <span
class="math inline">\(D\)</span>。</p>
<p>对于其他点双，从 <span class="math inline">\(s,f\)</span>
路径上的某个点离开 <span class="math inline">\(D\)</span>，走到 <span
class="math inline">\(c,c\not\in D\)</span> 后，为了回到 <span
class="math inline">\(f\)</span>，一定还要再回到 <span
class="math inline">\(D\)</span> 中。</p>
<p>因为缩点后无环，所以只能原路返回——这会造成点的重复访问，不合法。</p>
<p>所以我们要求出 <span class="math inline">\(\sum(\sum_{i\in
D}size(i))-2\)</span>，<span class="math inline">\(s,f\)</span> 是减去的
<span class="math inline">\(2\)</span>。</p>
<p>将原图处理成圆方树，在树上算答案就好了。</p>
<p>关于圆方树性质：</p>
<ul>
<li>方点只会连圆点，圆点只会连方点</li>
<li>圆方树节点个数为 <span class="math inline">\(O(n)\)</span> 个。</li>
<li>若原图中有 <span class="math inline">\(k\)</span>
个连通块，圆方树就是 <span class="math inline">\(k\)</span>
棵树组成的森林。</li>
</ul>
<p>如何建树：原图中的点都是圆点，对每个点双新建一个方点，将点双内全部圆点连到方点上，删除原图全部的边。</p>
<p>现在建出圆方树，考虑对圆方树上点赋点权。</p>
<p>方点点权为这个点双的大小，圆点点权为 <span
class="math inline">\(-1\)</span>。</p>
<p>现在问题转化为：图上全部圆点点对路径上权值和之和（顺便也不用考虑
<span class="math inline">\(-2\)</span> 了，因为起止点都是圆点）。</p>
<p>可以拆贡献，对每个点在dfs过程中算出有多少对圆点点对会经过这个点，点权乘个数加到答案里即可。</p>
<p>当然也可以写换根DP，但是没啥必要。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],T[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],dfncnt,val[N];</span><br><span class="line"><span class="type">int</span> sta[N],tp,nid;</span><br><span class="line"><span class="type">int</span> subn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    subn++;</span><br><span class="line">    dfn[u]=low[u]=++dfncnt;</span><br><span class="line">    sta[++tp]=u;</span><br><span class="line">    val[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">each</span>(v,G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">                nid++;</span><br><span class="line">                T[nid].<span class="built_in">pb</span>(u),T[u].<span class="built_in">pb</span>(nid);</span><br><span class="line">                val[nid]++;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    T[nid].<span class="built_in">pb</span>(sta[tp]),T[sta[tp]].<span class="built_in">pb</span>(nid);</span><br><span class="line">                    val[nid]++;</span><br><span class="line">                &#125;<span class="keyword">while</span>(sta[tp--]!=v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=u&lt;=n;</span><br><span class="line">    <span class="built_in">each</span>(v,T[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        ans+=<span class="number">2ll</span>*siz[u]*siz[v]*val[u];</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="number">2ll</span>*siz[u]*(subn-siz[u])*val[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    nid=n;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            subn=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>双连通分量</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4886</title>
    <url>/2023/12/02/P4886/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4886">P4886 快递员</a></p>
<span id="more"></span>
<p>点分治思想的好题。</p>
<p>题意：给一棵带边权的树，树上 <span class="math inline">\(m\)</span>
个点对 <span class="math inline">\((u_i,v_i)\)</span>，求 <span
class="math inline">\(\min\limits_{c\in
tree}\max_{i=1}^mdis(u_i,c)+dis(v_i,c)\)</span>。</p>
<p>先找一些性质。</p>
<p>设当前要判断最优点是否为 <span
class="math inline">\(c\)</span>，以<span
class="math inline">\(c\)</span> 为根，<span
class="math inline">\(d_i\)</span> 为 <span
class="math inline">\(dis(u_i,c)+dis(v_i,c)\)</span>，<span
class="math inline">\(S=\{(u_i,v_i)|d_i=\max_{j=1}^m
d_j\}\)</span>。</p>
<p>如果有 <span class="math inline">\((u,v)\in S\)</span> 满足 <span
class="math inline">\(u,v\)</span> 分别位于 <span
class="math inline">\(c\)</span> 的两个子树内，简单分讨可得，<span
class="math inline">\(c\)</span> 无论向哪里移动，都不会使 <span
class="math inline">\((u,v)\)</span> 到 <span
class="math inline">\(c\)</span> 的距离（也就是答案）更小，所以 <span
class="math inline">\(c\)</span> 就是最优点。</p>
<p>进一步想，如果 <span class="math inline">\(S\)</span>
中的点对并不都在同一棵子树，那么无论 <span
class="math inline">\(c\)</span>
向哪个子树移动，都会使其他子树中的点对距离更大，答案变大，所以 <span
class="math inline">\(c\)</span> 就是最优点。</p>
<p>综上，只有所有 <span class="math inline">\((u,v)\in S\)</span>
都在同一棵子树（设为 <span class="math inline">\(tree(v)\)</span>）
中，才需要继续递归到 <span
class="math inline">\(tree(v)\)</span>，否则就可以<code>return</code>输出答案了。</p>
<p>直接模拟上述过程，复杂度最坏为 <span
class="math inline">\(O(nm)\)</span>，不可接受。</p>
<p>发现递归问题时，选的新点 <span class="math inline">\(c\)</span>
所在位置并不重要，只要在子树内就行。</p>
<p>可以利用点分治的思想，每次以 <span
class="math inline">\(tree(v)\)</span> 中的重心做新的 <span
class="math inline">\(c\)</span>，去计算答案，因为重心的重儿子<code>size</code><span
class="math inline">\(\le \frac{size(tree(v))}{2}\)</span>
，所以递归的深度不会超过 <span class="math inline">\(\log
n\)</span>，这是点分治的经典分析。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mxp[N],siz[N],vis[N],rt,all;</span><br><span class="line">pii qr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>,mxp[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getRot</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        mxp[u]=<span class="built_in">max</span>(mxp[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[u]=<span class="built_in">max</span>(mxp[u],all-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mxp[u]&lt;mxp[rt])rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    bel[u]=id;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        <span class="built_in">getDis</span>(v,u,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="type">int</span> buc[N],tp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>,dis[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        dis[v]=e[i].w;</span><br><span class="line">        <span class="built_in">getDis</span>(v,u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">    tp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[qr[i].fi]+dis[qr[i].se]&gt;mx)&#123;</span><br><span class="line">            tp=<span class="number">0</span>;buc[++tp]=i;</span><br><span class="line">            mx=dis[qr[i].fi]+dis[qr[i].se];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[qr[i].fi]+dis[qr[i].se]==mx)&#123;</span><br><span class="line">            buc[++tp]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,mx);</span><br><span class="line">    <span class="built_in">re</span>(i,tp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[qr[buc[i]].fi]!=bel[qr[buc[i]].se])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!id)id=bel[qr[buc[i]].fi];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(id!=bel[qr[buc[i]].fi])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mxp[rt=<span class="number">0</span>]=inf;</span><br><span class="line">    all=siz[id];</span><br><span class="line">    <span class="built_in">getRot</span>(id,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(u,v,w);</span><br><span class="line">        <span class="built_in">ae</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        qr[i]=<span class="built_in">mkp</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    all=n,mxp[rt=<span class="number">0</span>]=inf;</span><br><span class="line">    <span class="built_in">getRot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>点分治</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>P5304</title>
    <url>/2023/12/02/P5304/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5304">P5304
[GXOI/GZOI2019] 旅行者</a></p>
<span id="more"></span>
<p>此题有两种复杂度的做法，都写在下文。</p>
<h3 id="二进制分组">二进制分组</h3>
<p>这是一种稍暴力的做法。</p>
<p>考虑将 <span class="math inline">\(k\)</span> 个点分为 <span
class="math inline">\(A,B\)</span> 两组，点 <span
class="math inline">\(st\)</span> 向 <span
class="math inline">\(A\)</span> 中连单向边，<span
class="math inline">\(B\)</span> 中点向 <span
class="math inline">\(ed\)</span> 连单向边（边权均为 <span
class="math inline">\(0\)</span>），那么到的最短路就为 <span
class="math inline">\(A\)</span> 内点到 <span
class="math inline">\(B\)</span> 内点的某条最短路径。（原因显然）</p>
<p>那么我们可以按照关键点编号的每一个二进制位分组，一共分 <span
class="math inline">\(\log k\)</span>
次，每次做上述连边然后跑最短路，过程中取 <span
class="math inline">\(\min\)</span> 就是答案。</p>
<p>为什么是对的？假设最终答案是 <span class="math inline">\(u,v\)</span>
的最短路，<span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>
之间至少有一个二进制位不同，只要分别在不同的组内，答案就一定会被算到。</p>
<p>时间复杂度 <span class="math inline">\(O(Tm\log n\log
k)\)</span>，不放代码了。</p>
<h3 id="正反图染色">正反图染色</h3>
<p>设 <span class="math inline">\(dis_1[p]\)</span> 为关键点到 <span
class="math inline">\(p\)</span> 最短路，<span
class="math inline">\(dis_2[p]\)</span> 为 <span
class="math inline">\(p\)</span> 到关键点最短路。</p>
<p>答案似乎变得明了：</p>
<p><span class="math inline">\(\min(\min\limits_{(u,v,w)\in
E}dis_1[u]+dis_2[v]+w,\min\limits_{u\in
V}dis_1[u]+dis_2[u])\)</span></p>
<p>这真的是答案吗？</p>
<p>有点问题：如果 <span class="math inline">\(dis_1[u]\)</span> 和 <span
class="math inline">\(dis_2[v]\)</span>
取到的是到同一个关键点的最短路怎么办？</p>
<p>所以我们需要在跑最短路的时候，记录 <span
class="math inline">\(dis_1[u]\)</span> 和 <span
class="math inline">\(dis_2[u]\)</span> 对应的关键点编号，分别记为 <span
class="math inline">\(f[u]\)</span> 和 <span
class="math inline">\(g[u]\)</span>。</p>
<p>计算 <span class="math inline">\(\min\limits_{(u,v,w)\in
E}dis_1[u]+dis_2[v]+w\)</span> 的过程中，只对 <span
class="math inline">\(f[u]\ne g[v]\)</span> 的边取 <span
class="math inline">\(\min\)</span>。</p>
<p>计算 <span class="math inline">\(\min\limits_{u\in
V}dis_1[u]+dis_2[u]\)</span> 的过程中，只对 <span
class="math inline">\(f[u]\ne g[u]\)</span> 且不是关键点的点取 <span
class="math inline">\(\min\)</span>。</p>
<p>这为啥是对的？</p>
<p><del>没整理出像样的证明，看洛谷题解区吧</del></p>
<p>时间复杂度 <span class="math inline">\(O(Tm\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a[N],X[M],Y[M],W[M],col[<span class="number">2</span>][N],head[N],tot;</span><br><span class="line">ll dis[<span class="number">2</span>][N],ans;<span class="type">bool</span> vis[N],iscity[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,next,val;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll dis;<span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">node</span>(ll _dis=<span class="number">0</span>,<span class="type">int</span> _id=<span class="number">0</span>):<span class="built_in">dis</span>(_dis),<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].to=y;</span><br><span class="line">    e[tot].val=w;</span><br><span class="line">    e[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(ll *dis,<span class="type">int</span> *col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) dis[a[i]]=<span class="number">0</span>,col[a[i]]=a[i],pq.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>,a[i]));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=pq.<span class="built_in">top</span>().id;pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].val)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].val;</span><br><span class="line">                col[v]=col[u];</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">node</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="type">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y,w);</span><br><span class="line">        <span class="keyword">if</span>(x!=y) <span class="built_in">addedge</span>(x,y,w);</span><br><span class="line">        X[i]=x;Y[i]=y;W[i]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">read</span>(a[i]),iscity[a[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(dis[<span class="number">0</span>],col[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(X[i]!=Y[i]) <span class="built_in">addedge</span>(Y[i],X[i],W[i]);</span><br><span class="line">    <span class="built_in">Dijkstra</span>(dis[<span class="number">1</span>],col[<span class="number">1</span>]);</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=X[i];y=Y[i];w=W[i];</span><br><span class="line">        <span class="keyword">if</span>(col[<span class="number">0</span>][x]&amp;&amp;col[<span class="number">1</span>][y]&amp;&amp;col[<span class="number">0</span>][x]!=col[<span class="number">1</span>][y])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][x]+dis[<span class="number">1</span>][y]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!iscity[i]&amp;&amp;col[<span class="number">0</span>][i]&amp;&amp;col[<span class="number">0</span>][i]!=col[<span class="number">1</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=iscity[i]=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P6189</title>
    <url>/2023/12/02/P6189/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6189">P6189 [NOI Online #1
入门组] 跑步</a></p>
<span id="more"></span>
<p>此题是一道裸的拆分数问题，本质上也是 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(k\)</span> 均无标号的第二类斯特林数问题。</p>
<p>我们可以想到两个DP。</p>
<ol type="1">
<li>设 <span class="math inline">\(f[i][j]\)</span>：总和为 <span
class="math inline">\(i\)</span>，拆成的数不大于 <span
class="math inline">\(j\)</span> 的方案。</li>
<li>设 <span class="math inline">\(g[i][j]\)</span>：总和为 <span
class="math inline">\(i\)</span>，拆成了 <span
class="math inline">\(j\)</span> 个数的方案。</li>
</ol>
<p>他们的转移分别为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f[i][j]=f[i][j-1]+f[i-j][j]
&amp;g[i][j]=g[i-1][j-1]+g[i-j][j]
\end{aligned}
\]</span></p>
<p>第一种转移：<span class="math inline">\(\le j-1\)</span>
的方案加上至少有一个等于 <span class="math inline">\(j\)</span>
的方案。</p>
<p>第二种转移：前面的部分是拆出来一个 <span
class="math inline">\(1\)</span>；后面的意为把所有拆出来的数都加 <span
class="math inline">\(1\)</span>，总和也就从 <span
class="math inline">\(i-j\)</span> 变成 <span
class="math inline">\(i\)</span> 了。</p>
<p>两种DP的时间复杂度均为 <span
class="math inline">\(O(n^2)\)</span>，不能满足我们的要求。</p>
<p>但是可以两个一起用。</p>
<p>发现他们的状态设计很有趣：有一种根号分治的感觉。</p>
<p>且两种状态设计似乎分别是根号分治的两部分。</p>
<p>我们对于 <span class="math inline">\(f\)</span> 可以只转移拆出来的数
<span class="math inline">\(&lt;\sqrt{n}\)</span> 的部分，对于 <span
class="math inline">\(g\)</span> 只转移拆出来的数 <span
class="math inline">\(\ge \sqrt{n}\)</span> 的部分。</p>
<p>具体的，用 <span class="math inline">\(f\)</span> 求出 <span
class="math inline">\(j&lt;\sqrt{n}\)</span> 的方案，然后再改一改 <span
class="math inline">\(g\)</span> ，让他只转移 <span
class="math inline">\(\ge \sqrt{n}\)</span>
的数字，也就是第一维的“步长”为 <span
class="math inline">\(\sqrt{n}\)</span>即可。</p>
<p>最后用 <span class="math inline">\(f,g\)</span> 拼成一个 <span
class="math inline">\(n\)</span>：枚举 <span
class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span>
分成小块，<span class="math inline">\(n-i\)</span>
分成大块，两种方案相乘，再将所有 <span class="math inline">\(i\)</span>
的对应的方案相加即可。</p>
<p>由定义可得，<span class="math inline">\(f\)</span> 和 <span
class="math inline">\(g\)</span>
统计的两部分是互斥的，不会重复计数；同时正好可以覆盖 <span
class="math inline">\(n\)</span> 的全部方案。</p>
<p>总复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，可以通过。</p>
<p>另外一种做法是GF推五边形数定理递推式，比较抽象。</p>
<p>有一些链接：<a
href="https://www.luogu.com.cn/blog/StudyingFather/pentagonal-number-and-number-partitions">五边形数与整数拆分问题</a>，<a
href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86">费马多边形数定理</a>，<a
href="https://blog.csdn.net/visit_world/article/details/52734860">五边形数定理的一种证明</a>，内容没看懂，笔者太菜不写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span> + <span class="number">5</span>)</span>, <span class="title">sqN</span><span class="params">(<span class="number">320</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, p, B, S;</span><br><span class="line"><span class="type">int</span> f[N][sqN], g[N][sqN], X[N], Y[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, p);</span><br><span class="line">    B = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    S = n / B + <span class="number">1</span>; X[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, B - <span class="number">1</span>)f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(j, B - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p;</span><br><span class="line">            X[i] = f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span>; Y[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lim = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        lim = <span class="built_in">min</span>(S, i);</span><br><span class="line">        <span class="built_in">re</span>(j, lim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B)(g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j)(g[i][j] += g[i - j][j]) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        <span class="built_in">re</span>(j, S) &#123;</span><br><span class="line">            (Y[i] += g[i][j]) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        (ans += <span class="number">1ll</span> * X[i] * Y[n - i] % p) %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P6442</title>
    <url>/2023/12/02/P6442/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6442">P6442
[COCI2011-2012#6] KOŠARE</a></p>
<span id="more"></span>
<p>（大概）三倍经验：CF449D，CF165E</p>
<p>这是一道高维前缀和（子集和DP）+ 容斥的 模板。</p>
<p>简单的想法是设 <span class="math inline">\(f[i][s]\)</span> 表示前
<span class="math inline">\(i\)</span> 个箱子，出现过的种类构成的集合为
<span class="math inline">\(s\)</span>
的方案数，只需要转移选还是不选当前箱子。</p>
<p>时间复杂度 <span
class="math inline">\(O(n2^m)\)</span>，不能通过本题。</p>
<p>考虑容斥 设 <span class="math inline">\(f[s]\)</span> 为种类集合为
<span class="math inline">\(s\)</span> 子集的箱子数。</p>
<p>可以通过高维前缀和在的时间复杂度内求出。</p>
<p>如何计算答案呢？</p>
<p>设 <span class="math inline">\(g[s]\)</span> 为：集合 <span
class="math inline">\(s\)</span> 中种类都不选，其他随便选的方案；</p>
<p><span class="math inline">\(c\)</span> 为 <span
class="math inline">\(s\)</span> 对全部种类的补集。</p>
<p><span class="math inline">\(g[s]=2^{f[c]}-1\)</span>。</p>
<p>原因显然：补集内随便选非空子集都可以。</p>
<p>设 <span class="math inline">\(ans_s\)</span> 为 <span
class="math inline">\(s\)</span> 内种类全都被选的方案</p>
<p>有：<span class="math inline">\(ans_s=\sum\limits_{i\subseteq
s}(-1)^{ |i| }g[i]\)</span>。</p>
<p>关于上式：设 <span class="math inline">\(A_i\)</span> 为种类 <span
class="math inline">\(i\)</span> 被选了的方案。</p>
<p>有容斥经典式子：<span
class="math inline">\(\left|\bigcap\limits_{i\in
U}A_i\right|=\sum\limits_{s\subseteq U}(-1)^{ |s|
}\left|\bigcap\limits_{i\in s}\overline A_i\right|\)</span></p>
<p>复杂度 <span class="math inline">\(O(m2^m)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">1e9</span>+<span class="number">7</span>)</span>,<span class="title">N</span><span class="params">(<span class="number">1.1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,box[N];</span><br><span class="line">ll f[N],pw2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="built_in">re</span>(j,k)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            box[i]|=(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        f[box[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[s]+=f[s^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    pw2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)pw2[i]=pw2[i<span class="number">-1</span>]*<span class="number">2</span>%Mod;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ss=((<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)^i;</span><br><span class="line">        <span class="type">int</span> k=(__builtin_popcount(i)&amp;<span class="number">1</span>)?Mod<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        (ans+=k*<span class="number">1ll</span>*(pw2[f[ss]]<span class="number">-1</span>)%Mod)%=Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>子集和DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P6655</title>
    <url>/2023/12/02/P6655/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6655">P6655 [YsOI2020]
制高</a></p>
<span id="more"></span>
<p>直接数也能数，但是我写了期望相关。</p>
<p>我们可以求答案的期望，最后再乘上全部方案个数。</p>
<p>设制高点权值为 <span class="math inline">\(1\)</span>，否则为 <span
class="math inline">\(0\)</span>，<span
class="math inline">\(f[u]\)</span> 为点 <span
class="math inline">\(u\)</span> 的期望权值。</p>
<p>期望的线性性，有 <span
class="math inline">\(E(ans)=\sum\limits_{i=1}^nf[i]\)</span></p>
<p>考虑如何求 <span class="math inline">\(f[i]\)</span>。</p>
<p>式子非常直观：<span
class="math inline">\(f[i]=\dfrac{\sum_{j=l[i]}^{r[i]}f[j]\times
[h[i]\ge h[j]]}{(r[i]-l[i]+1)}\)</span></p>
<p>就是总权值除以总方案而已。</p>
<p>因为题目保证 <span class="math inline">\(1\le l[i]\le r[i]&lt;
i\)</span>，被贡献的部分都已经算完了，所以这样转移是正确的。</p>
<p>发现上面的和式是一个二维数点的形式，在主席树上在线做 或
按排序后树状数组离线做 均可。</p>
<p>最后通过期望算出答案：<span class="math inline">\(ans=E(ans)\times
\prod\limits_{i=1}^n(r[i]-l[i]+1)\)</span></p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>代码写的树状数组，比较简短。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span> + <span class="number">5</span>)</span>, <span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll c[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (x; x &lt;= n; x += <span class="built_in">lowbit</span>(x))c[x] = (c[x] + v) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (x; x; x -= <span class="built_in">lowbit</span>(x))res = (res + c[x]) % Mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ba;</span><br><span class="line"><span class="type">int</span> h[N], l[N], r[N], p[N];</span><br><span class="line">ll f[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n)inv[i] = (Mod - (Mod / i)) * inv[Mod % i] % Mod;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i], r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i, n)p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[x] == h[y])<span class="keyword">return</span> x &lt; y;</span><br><span class="line">        <span class="keyword">return</span> h[x] &lt; h[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">        j = p[i];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            f[j] = <span class="number">1</span>;</span><br><span class="line">            ba.<span class="built_in">add</span>(j, f[j]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[j] = (ba.<span class="built_in">ask</span>(r[j]) - ba.<span class="built_in">ask</span>(l[j] - <span class="number">1</span>) + Mod) * inv[r[j] - l[j] + <span class="number">1</span>] % Mod;</span><br><span class="line">        ba.<span class="built_in">add</span>(j, f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>, prod = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i, n)ans = (ans + f[i]) % Mod;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        prod = prod * (r[i] - l[i] + <span class="number">1</span>) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * prod % Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP的优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP优化</tag>
        <tag>概率与期望</tag>
        <tag>主席树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P6864</title>
    <url>/2023/12/02/P6864/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6864">P6864 [RC-03]
记忆</a></p>
<span id="more"></span>
<p>（NFLS 23-11-02 div2C）</p>
<p>先找前两种操作的性质。</p>
<p>发现在当前串后面加上一个 <span
class="math inline">\(()\)</span>，可以使答案增加最外层括号块个数，然后最外层括号块个数
<span class="math inline">\(+1\)</span>。</p>
<p>而将整个串包起来，可以使整个串变成一个括号块。</p>
<p>忽略撤销操作的前提下，
对答案的贡献序列形如：<code>1+2+3+4+1+1+2+3+4+5+1+2</code></p>
<p>（变成 <span class="math inline">\(1\)</span>
时就是操作二，线性增长时就是操作一）</p>
<p>发现撤销操作本质上是单点改操作序列。</p>
<p>为了保证复杂度显然需要数据结构维护，直接维护贡献序列并不好做。</p>
<p>我们可以把操作序列看成一个递推过程，这个过程可以通过矩阵加速。</p>
<p>设当前答案为 <span
class="math inline">\(f\)</span>（也就是贡献序列的一个前缀和），前缀的最后一个加数为
<span class="math inline">\(g\)</span> ，容易得到：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\begin{bmatrix}f&amp;g&amp;1\end{bmatrix}\times
\begin{bmatrix}1&amp;0&amp;0\\1&amp;1&amp;0\\1&amp;1&amp;1\end{bmatrix}=\begin{bmatrix}f+g+1&amp;g+1&amp;1\end{bmatrix}\\
&amp;\begin{bmatrix}f&amp;g&amp;1\end{bmatrix}\times
\begin{bmatrix}1&amp;0&amp;0\\0&amp;0&amp;0\\1&amp;1&amp;1\end{bmatrix}=\begin{bmatrix}f+1&amp;1&amp;1\end{bmatrix}
\end{aligned}
\]</span></p>
<p>这两种转移矩阵分别对应操作一和操作二。</p>
<p>将所有操作的转移矩阵挂在线段树上维护乘法即可。</p>
<p>撤销时可能会出现撤销了撤销操作，可以写类似于并查集的东西（路径压缩之类）</p>
<p>删除矩阵时只需要将对应位置改为单位矩阵即可。</p>
<p>时间复杂度 <span class="math inline">\(O(q\times 27\log
n)\)</span>，因为都是下三角矩阵，所以实现的好一点可以少点常数，但我摆了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123;</span><br><span class="line">    ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        a[<span class="number">2</span>][<span class="number">0</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">2</span>]=a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        mat c;c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            c.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> mat&amp; b)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]!=b.a[i][j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mat a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        mat val;</span><br><span class="line">    &#125;t[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        t[rt].val=t[<span class="built_in">ls</span>(rt)].val*t[<span class="built_in">rs</span>(rt)].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        t[rt].val.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            t[rt].val=a[pos];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> x[N],op[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    mat ans,op1,op2;</span><br><span class="line">    op1.<span class="built_in">set1</span>();</span><br><span class="line">    op2.<span class="built_in">set2</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)a[i].<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op[i]);</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            a[i]=op1;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">2</span>)&#123;</span><br><span class="line">            a[i]=op2;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x[i]);</span><br><span class="line">            <span class="keyword">if</span>(op[x[i]]==<span class="number">3</span>)&#123;</span><br><span class="line">                x[i]=x[x[i]];</span><br><span class="line">                <span class="keyword">if</span>(op[x[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[x[i]]==op1)a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">                    <span class="keyword">else</span> a[x[i]]=op1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[x[i]]==op2)a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">                    <span class="keyword">else</span> a[x[i]]=op2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a[x[i]].<span class="built_in">init</span>();</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">reset</span>();</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>]=ans.a[<span class="number">0</span>][<span class="number">1</span>]=ans.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        ans=ans*t.t[<span class="number">1</span>].val;</span><br><span class="line">        <span class="built_in">write</span>(ans.a[<span class="number">0</span>][<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P7322</title>
    <url>/2023/12/02/P7322/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7322">P7322
「PMOI-4」排列变换</a></p>
<span id="more"></span>
<p>求 <span
class="math inline">\(\sum\limits_pw(f(p))\)</span>，考虑拆贡献。</p>
<p>因为是排列，所以出现过的最大值被取代之后 不会再出现第二次</p>
<p>所以可以将 <span class="math inline">\(w(a)\)</span> 转化为 <span
class="math inline">\(a\)</span> 内元素变动次数 <span
class="math inline">\(+1\)</span>（后文先暂时忽略这个 <span
class="math inline">\(+1\)</span> ）</p>
<p>那么什么时候当前窗口最大值产生变动呢？</p>
<p>最大值被弹出：</p>
<p><span
class="math inline">\(\sum\limits_{i=k}^nA_{i-1}^{k-1}(n-k)(n-k)!\)</span></p>
<p><span class="math inline">\(i\)</span> 为枚举到弹出的最大值，<span
class="math inline">\(A_{i-1}^{k-1}\)</span>为小于 <span
class="math inline">\(i\)</span> 的值域中随便选 <span
class="math inline">\(k-1\)</span> 个数，放在窗口内的排列数。</p>
<p><span class="math inline">\(n-k\)</span> 为窗口有 <span
class="math inline">\(n-k\)</span> 个位置个数，<span
class="math inline">\((n-k)!\)</span>为窗口外其他元素随意排列。</p>
<p>加入的是最大值的方案数同理，会发现和上式一样（两种操作是对称的）</p>
<p>但这里需要去重：可能会出现弹出旧最大值之后放入的数为新最大值，而这样的情况会被数两次。</p>
<p>钦定加入的数大于弹出的数，去掉的部分为：</p>
<p><span
class="math inline">\(\sum\limits_{i=k+1}^n\dbinom{i-1}{k}(k-1)!(n-k)(n-k+1)!\)</span></p>
<p><span class="math inline">\(i\)</span> 为加入的数，当前需要考虑 <span
class="math inline">\(k+1\)</span> 个数。</p>
<p>组合数为小于值域内选 <span class="math inline">\(k\)</span>
个数。<span
class="math inline">\((k-1)!\)</span>为除了加入弹出的两个最大值之外的数的全排列，<span
class="math inline">\(n-k\)</span> 为窗口位置，<span
class="math inline">\((n-k+1)!\)</span> 为窗口外元素全排列。</p>
<p>弹出大于加入同理。所以要去掉上式 <span class="math inline">\(\times
2\)</span></p>
<p>最后不要忘了在前文忽略掉的 <span
class="math inline">\(+1\)</span>，每个排列都会贡献至少 <span
class="math inline">\(1\)</span> ，所以应加上 <span
class="math inline">\(n!\)</span></p>
<p>注：排列的计数，要学会钦定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e5</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%Mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>)fac[i]=ifac[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n],Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">pe</span>(i,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">5e5</span>);</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,k,n)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(i<span class="number">-1</span>,k<span class="number">-1</span>))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*<span class="number">2ll</span>*fac[n-k]%Mod*(n-k)%Mod*fac[k<span class="number">-1</span>]%Mod;</span><br><span class="line">    <span class="type">int</span> del=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,k+<span class="number">1</span>,n)&#123;</span><br><span class="line">        del=(del+<span class="built_in">C</span>(i<span class="number">-1</span>,k))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    del=del*<span class="number">2ll</span>*fac[n-k<span class="number">-1</span>]%Mod*(n-k)%Mod*fac[k<span class="number">-1</span>]%Mod;</span><br><span class="line">    ans=(ans+fac[n])%Mod;</span><br><span class="line">    ans=(<span class="number">1ll</span>*ans-del+Mod)%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P7834</title>
    <url>/2023/12/02/P7834/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7834">P7834 [ONTAK2010]
Peaks 加强版</a></p>
<span id="more"></span>
<p>二合一题，重点在重构树上。</p>
<p>需要先了解 <strong>Kruskal重构树</strong> 的概念。</p>
<p>建树方式：跑Kruskal，将两个并查集合并的时候，新建一个点与两个并查集的<code>fa</code>连边，新点的点权为当前边的边权，并将这个新点作为合并后并查集的<code>fa</code>。</p>
<p>性质：</p>
<ul>
<li>重构树的叶子节点是原图中所有点，其余的每个点都是原图中的部分边。</li>
<li>如果是最小生成树，那么重构树满足 <span class="math inline">\(\forall
v\in subtree(u),w[v]\le w[u]\)</span>，最大生成树为 <span
class="math inline">\(\forall v\in subtree(u),w[v]\ge
w[u]\)</span>。</li>
<li>如果是最小生成树，重构树上两个叶子节点 <span
class="math inline">\(u,v\)</span> 的 <span
class="math inline">\(lca\)</span> 的权值代表原图中 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>
所有路径上最大边权的最小值，最大生成树就是最小边权最大值。</li>
<li>如果原图是连通图且有 <span class="math inline">\(V\)</span>
个点，重构树会有 <span class="math inline">\(2V-1\)</span> 个点。</li>
</ul>
<p>此题要用到性质二，三。</p>
<p>在最小生成树的重构树上，由性质二得，如果 <span
class="math inline">\(w[u]\le x\)</span>，那么以 <span
class="math inline">\(u\)</span> 为根的子树内节点权值也都 <span
class="math inline">\(\le x\)</span>，都可以走。</p>
<p>找 <span class="math inline">\(u\)</span> 到根的链上深度最浅的 <span
class="math inline">\(i\)</span> 满足 <span
class="math inline">\(w[i]\le x\)</span>
，用树上倍增优化跳父亲过程即可。</p>
<p>现在问题变为找一个子树的所有叶子节点内的第 <span
class="math inline">\(k\)</span> 大权值，主席树直接做，板子。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, ls, rs;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="type">int</span> ntot, T[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = ++ntot;</span><br><span class="line">    tr[i].l = l;</span><br><span class="line">    tr[i].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[i].ls = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tr[i].rs = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = ++ntot;</span><br><span class="line">    tr[i] = tr[pre];</span><br><span class="line">    tr[i].sum++;</span><br><span class="line">    <span class="keyword">if</span> (tr[i].l == tr[i].r)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="type">int</span> mid = tr[i].l + tr[i].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        tr[i].ls = <span class="built_in">upd</span>(tr[pre].ls, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tr[i].rs = <span class="built_in">upd</span>(tr[pre].rs, x);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[L].l == tr[L].r)</span><br><span class="line">        <span class="keyword">return</span> tr[L].l;</span><br><span class="line">    <span class="type">int</span> dif = tr[tr[R].ls].sum - tr[tr[L].ls].sum;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= dif)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tr[L].ls, tr[R].ls, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tr[L].rs, tr[R].rs, k - dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, w;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">read</span>(x, y, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[N];</span><br><span class="line"><span class="type">int</span> to[N], head[N], nxt[N], edgec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++edgec] = v;</span><br><span class="line">    nxt[edgec] = head[u];</span><br><span class="line">    head[u] = edgec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N], h[N], lsh[N], val[N], num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]); &#125;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], lb[N], rb[N], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = fat;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    lb[x] = tot;</span><br><span class="line">    <span class="keyword">if</span> (head[x] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lb[x] = tot;</span><br><span class="line">        rb[x] = ++tot;</span><br><span class="line">        T[tot] = <span class="built_in">upd</span>(T[tot - <span class="number">1</span>], <span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + num, h[x]) - lsh);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = nxt[i])</span><br><span class="line">        <span class="built_in">dfs</span>(to[i], x);</span><br><span class="line">    rb[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">read</span>(n, m, q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]), lsh[i] = h[i];</span><br><span class="line">    <span class="built_in">sort</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + n);</span><br><span class="line">    num = <span class="built_in">unique</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + n) - lsh - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        E[i].<span class="built_in">input</span>();</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(E[i].x), fy = <span class="built_in">find</span>(E[i].y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = f[fy] = ++cnt;</span><br><span class="line">        <span class="built_in">add</span>(cnt, fx);</span><br><span class="line">        <span class="built_in">add</span>(cnt, fy);</span><br><span class="line">        val[cnt] = E[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    T[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, num);</span><br><span class="line">    <span class="built_in">dfs</span>(cnt, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= q; _++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, x, k;</span><br><span class="line">        <span class="built_in">read</span>(v, x, k);</span><br><span class="line">        v = (v ^ lastans) % n + <span class="number">1</span>;</span><br><span class="line">        k = (k ^ lastans) % n + <span class="number">1</span>;</span><br><span class="line">        x = x ^ lastans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (fa[v][i] &amp;&amp; val[fa[v][i]] &lt;= x)</span><br><span class="line">                v = fa[v][i];</span><br><span class="line">        <span class="type">int</span> l = lb[v], r = rb[v];</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; k)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(lastans = lsh[<span class="built_in">query</span>(T[l], T[r], r - l - k + <span class="number">1</span>)], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Kruskal重构树</tag>
        <tag>主席树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P7990</title>
    <url>/2023/12/02/P7990/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7990">P7990 [USACO21DEC]
Closest Cow Wins S</a></p>
<span id="more"></span>
<p>显然是一个贪心题。</p>
<p>考虑怎么贪。</p>
<p>发现Nhoj的牛将这些草地划分成了若干个草地段。</p>
<p>观察性质，发现在一个草地段内，John最多只需要放两个牛。</p>
<p>因为我们只需要将两端放上牛，这一整段草地，最近的牛就都是John的了。</p>
<p>也就是说，放两个牛就可以全部占领这一段。</p>
<p>我们现在只需要求出每一个段放一个牛的贡献即可。</p>
<p>可以发现，一个牛可以占领草地的一个区间，我们只需要用双指针扫一遍当前草地段的每一个合法区间，取贡献最大值即可。</p>
<p>具体的说，设当前段，左边Nhoj的牛在 <span
class="math inline">\(l\)</span>，右边Nhoj的牛在 <span
class="math inline">\(r\)</span>，John的牛在 <span
class="math inline">\(p\)</span>，会发现能贡献答案的区间的两端分别是是线段
<span class="math inline">\(lp\)</span> 和线段 <span
class="math inline">\(pr\)</span> 的中点，也就是 <span
class="math inline">\((\frac{l+p}{2},\frac{p+r}{2})\)</span>，因为距离相等算Nhoj的，所以是开区间。</p>
<p>将每一段放一个牛的贡献塞进优先队列，如果当前用了一个牛的方案，再将对应段内两个牛与一个牛的贡献之差塞进去就好了。</p>
<p>其实上面这种贪心的正确性需要条件：设一个牛贡献为 <span
class="math inline">\(A\)</span>，两个牛的贡献为 <span
class="math inline">\(B\)</span>，有 <span class="math inline">\(B-A\le
A\)</span>。如果不满足，有可能出现选一个会不优，所以本应被放进队列的
选两个的情况，没有被放进队列。</p>
<p>为什么有这个不等式？</p>
<p>我们设 <span class="math inline">\(sum(l,r)\)</span> 是区间 <span
class="math inline">\((l,r)\)</span> 的草地贡献和。</p>
<p>根据上面那个贡献区间可知，<span class="math inline">\(A\ge
sum(l,\frac{l+r}{2}),A\ge sum(\frac{l+r}{2},r)\)</span>，那么有 <span
class="math inline">\(2A\ge
sum(l,\frac{l+r}{2})+sum(\frac{l+r}{2},r)=sum(l,r)=B\)</span></p>
<p>移项后也就是 <span class="math inline">\(B-A\le A\)</span> 了。</p>
<p>注：代码中deque对美味值没有单调性，只是这样写双指针比较顺手。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Deque</span>&#123;</span><br><span class="line">    T q[N];</span><br><span class="line">    <span class="type">int</span> frt,bak;</span><br><span class="line">    <span class="built_in">Deque</span>()&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;frt=<span class="number">1</span>,bak=<span class="number">0</span>;q[<span class="number">1</span>]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[frt];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q[bak];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bak-frt+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;frt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;bak--;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;q[++bak]=x;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (bak-frt+<span class="number">1</span>)&gt;<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> K,m,n,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Grass</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,t;</span><br><span class="line">&#125;ga[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,num;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;x.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;u;</span><br><span class="line">Deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line">ll f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(K,m,n);</span><br><span class="line">    <span class="built_in">re</span>(i,K)&#123;</span><br><span class="line">        <span class="built_in">read</span>(ga[i].p,ga[i].t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ga+<span class="number">1</span>,ga+K+<span class="number">1</span>,[](Grass x,Grass y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.p&lt;y.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>]=-inf,a[m+<span class="number">1</span>]=inf;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len=(a[i]-a[i<span class="number">-1</span>]+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">// 这里+1为了上取整</span></span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=K&amp;&amp;ga[now].p&lt;a[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;ga[q.<span class="built_in">front</span>()].p+len&lt;=ga[now].p)&#123;</span><br><span class="line">                sum-=ga[q.<span class="built_in">front</span>()].t;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(now);</span><br><span class="line">            sum+=ga[now].t; </span><br><span class="line">            f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],sum);</span><br><span class="line">            f[i][<span class="number">1</span>]+=ga[now++].t;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>((node)&#123;i,<span class="number">1</span>,f[i][<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    node u;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;n&amp;&amp;(!pq.<span class="built_in">empty</span>()))&#123;</span><br><span class="line">        u=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=u.val;</span><br><span class="line">        <span class="keyword">if</span>(u.num==<span class="number">1</span>)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>((node)&#123;u.id,<span class="number">2</span>,f[u.id][<span class="number">1</span>]-f[u.id][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P8021</title>
    <url>/2023/12/02/P8021/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8021">P8021 [ONTAK2015]
Bajtman i Okrągły Robin</a></p>
<span id="more"></span>
<p>难度在读题和转化模型。</p>
<p>题意：<span class="math inline">\(n\)</span>
个区间，每个区间有权值，对于每个时间段来说，可以在覆盖这个时间段的所有区间中选择一个区间，但是每个区间只能被选一次，求通过选区间能获得的最大权值。</p>
<p>说实话我觉得读题挺有难度的，没想出来翻译全责。</p>
<p>显然可以将区间和每个时间段当做点，分别放在二分图两侧，区间向覆盖到的时间段连带权边，跑二分图最大权匹配。</p>
<p>但边数为 <span class="math inline">\(O(n^2)\)</span>
量级，无法通过。</p>
<p>考虑优化，发现点向一段区间连边的操作可以用线段树优化连边，也就是
中转点 的思想，线段树中父亲与儿子连 <span
class="math inline">\(0\)</span>
权边，将一段区间分散到线段树上连带权边即可。</p>
<p>边数变成 <span class="math inline">\(O(n\log
n)\)</span>，代码写了最大费用最大流跑匹配，<code>EK</code>+<code>SPFA</code>的复杂度比较抽象，在这种二叉树+二分图上的复杂度我也不会算，所以复杂度就是
<span class="math inline">\(O(AC)\)</span> 了，最大点 <span
class="math inline">\(4s\)</span>，时限 <span
class="math inline">\(10s\)</span>，问题不大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,sour,conv;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].c=c;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ae</span>(u,v,w,c);</span><br><span class="line">    <span class="built_in">ae</span>(v,u,-w,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l[N],r[N],c[N];</span><br><span class="line"><span class="type">int</span> lim;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">af</span>(sour,rt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        lim=<span class="built_in">max</span>(lim,rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">af</span>(<span class="built_in">ls</span>(rt),rt,<span class="number">0</span>,mid-l+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">af</span>(<span class="built_in">rs</span>(rt),rt,<span class="number">0</span>,r-mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> tar,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">        <span class="built_in">af</span>(rt,tar,w,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">connect</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,tar,w);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">connect</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,tar,w);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> dis[N],vis[N],flow[N],pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,conv)dis[i]=-inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(sour);</span><br><span class="line">    vis[sour]=<span class="number">1</span>,dis[sour]=<span class="number">0</span>,flow[sour]=inf;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u],e[i].c);</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[conv]!=-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxflow,maxcost;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,mn,p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        u=conv;</span><br><span class="line">        maxflow+=flow[conv];</span><br><span class="line">        maxcost+=flow[conv]*dis[conv];</span><br><span class="line">        <span class="keyword">while</span>(u!=sour)&#123;</span><br><span class="line">            e[pre[u]].c-=flow[conv];</span><br><span class="line">            e[pre[u]^<span class="number">1</span>].c+=flow[conv];</span><br><span class="line">            u=e[pre[u]^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    sour=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i],r[i],c[i]);</span><br><span class="line">        r[i]--;</span><br><span class="line">        m=<span class="built_in">max</span>(m,r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    conv=lim+n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">connect</span>(<span class="number">1</span>,<span class="number">1</span>,m,l[i],r[i],lim+i,c[i]);</span><br><span class="line">        <span class="built_in">af</span>(lim+i,conv,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MCMF</span>();</span><br><span class="line">    <span class="built_in">write</span>(maxcost,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>线段树</tag>
        <tag>优化建图</tag>
        <tag>费用流</tag>
        <tag>二分图</tag>
        <tag>图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>P8026</title>
    <url>/2023/12/02/P8026/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8026">P8026 [ONTAK2015]
Bajtocja</a></p>
<span id="more"></span>
<p>答案只和连通性相关，考虑并查集。</p>
<p>判断两个点是否在每层图上都在一个连通块内并不好做。</p>
<p>将点在每个图内所属连通块的 <span class="math inline">\(fa\)</span>
串起来，看成一个长为 <span class="math inline">\(d\)</span> 的序列.</p>
<p>发现我们只是在判断两个点对应的序列是否相同。</p>
<p>有一种比较厉害的写法：为每一层随机一个权值 <span
class="math inline">\(wei[k]\)</span>，对每个点维护 <span
class="math inline">\(fa\)</span> 序列的哈希值之和（哈希值被定义为 <span
class="math inline">\(A[k]\times
wei[k]\)</span>），开桶（哈希表）记录每个哈希值对应的点个数，动态计算答案。</p>
<p>这里的哈希并不是传统的 <span class="math inline">\(base\)</span>
进制数形式的哈希，这里的第 <span class="math inline">\(i\)</span>
“位”（已经没有进制的位概念了，只是一些项加起来）是 <span
class="math inline">\(i\times wei[k]\)</span>，而不是 <span
class="math inline">\(base^i\times i\times
wei[k]\)</span>，这被称作和哈希。</p>
<p>由于随机变量的存在，他的正确率还是很高的。</p>
<p>我们用启发式合并去维护目前每一层每个连通块内放了哪些点。</p>
<p>在对 <span class="math inline">\((u,v)\)</span> 连边的时候，将 <span
class="math inline">\(u,v\)</span>
所属集合合并，然后贡献答案，将他们在这一层的对应哈希位置改成新的值即可。</p>
<p>关于贡献答案：加入哈希值要先算再加，删除要先减再算，和一些莫队是一样的。<span
class="math inline">\(\times
2+1\)</span>的原因显然（可以和之前的每个成员组成两个有序二元组，然后自己也可以和自己组成一个）。</p>
<p>因为启发式合并是把小集合合并到大集合，每次集合大小至少 <span
class="math inline">\(\times 2\)</span>，初始有 <span
class="math inline">\(dn\)</span> 个集合，每个集合大小至多为 <span
class="math inline">\(n\)</span>，所以时间复杂度为 <span
class="math inline">\(O(dn\log n)\)</span>，可以通过。</p>
<p>注：随机权值最好范围大一些，错误率会降低很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">D</span><span class="params">(<span class="number">205</span>)</span>,<span class="title">N</span><span class="params">(<span class="number">5e3</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> d,n,m,fa[D][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s[D][N];</span><br><span class="line">ull has[N],wei[D];</span><br><span class="line">unordered_map&lt;ull,<span class="type">int</span>&gt; cnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ull h)</span></span>&#123;</span><br><span class="line">    ans+=cnt[h]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    cnt[h]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(ull h)</span></span>&#123;</span><br><span class="line">    cnt[h]--;</span><br><span class="line">    ans-=cnt[h]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(d,n,m);</span><br><span class="line">    <span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="built_in">re</span>(i,d)&#123;</span><br><span class="line">        wei[i]=<span class="built_in">rnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,d)&#123;</span><br><span class="line">        <span class="built_in">re</span>(j,n)&#123;</span><br><span class="line">            fa[i][j]=j;</span><br><span class="line">            s[i][j].<span class="built_in">pb</span>(j);</span><br><span class="line">            has[j]+=j*wei[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">add</span>(has[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,k);</span><br><span class="line">        u=fa[k][u],v=fa[k][v];</span><br><span class="line">        <span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">            <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[k][u].<span class="built_in">size</span>()&lt;s[k][v].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">swap</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:s[k][v])&#123;</span><br><span class="line">            s[k][u].<span class="built_in">pb</span>(x);</span><br><span class="line">            fa[k][x]=u;</span><br><span class="line">            <span class="built_in">del</span>(has[x]);</span><br><span class="line">            has[x]+=(u-v)*wei[k];</span><br><span class="line">            <span class="built_in">add</span>(has[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        s[k][v].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>RANDOM</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
        <tag>哈希</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>P8179</title>
    <url>/2023/12/02/P8179/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8179">P8179 「EZEC-11」
Tyres</a></p>
<span id="more"></span>
<p>其实不太好想，是分两部分做的题。</p>
<p>不会做就看看特殊性质。</p>
<p>发现 <span class="math inline">\(t\)</span> 比较烦人，<span
class="math inline">\(t=0\)</span> 的部分是可以直接贪心的。</p>
<p>具体的，记录每套轮胎跑了多少圈，优先队列的<code>cmp</code>里计算秒数，每次贪心取顶，加圈数改<code>key</code>值即可，复杂度
<span class="math inline">\(O(m\log n)\)</span>。</p>
<p>加上 <span class="math inline">\(t\)</span> 怎么写呢。</p>
<p>首先十分显然的一点，一个轮胎被换下去后不可能再次被换上，可以将每个轮胎的秒数和圈数描述为
<span
class="math inline">\(f(x)=b(x-1)^2+a\)</span>，而这是二次函数，某个二次函数中的一段成为全部二次函数的最小值之后，如果不再是最小值，那当然就再也不可能是最小值。</p>
<p>不妨把 每一套轮胎的换胎时间 加到
当前这套轮胎跑第一圈的时间上，这样就没有换胎操作了。</p>
<p>但是这样不能贪心了，因为给第一圈加上 <span
class="math inline">\(t\)</span> 之后，每套轮胎的秒数不一定关于圈数在
<span class="math inline">\([1,m]\)</span> 上递增。</p>
<p>题目中 <span class="math inline">\(a_i+b_i(j-1)^2\)</span>
的贡献式子是有用的，这个平方比较显眼。</p>
<p>记 <span class="math inline">\(B=\lceil\sqrt{t}\rceil\)</span>。
注：以下的 <span class="math inline">\(B\)</span>
圈都是指每个轮胎各自跑了 <span class="math inline">\(B\)</span>
圈，并不是总共跑了 <span class="math inline">\(m\)</span> 圈中的前 <span
class="math inline">\(B\)</span> 圈。</p>
<p>不难发现，<span class="math inline">\(B\)</span>
圈之后，任意一套轮胎的花费都会大于等于这套轮胎在第一圈花费的时间加上累加的
这套轮胎的换胎时间。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;a_i+b_i\times 0+t\le a_i+b_i\times B^2\\
&amp;a_i+t\le a_i+b_it
\end{aligned}
\]</span></p>
<p>显然成立。</p>
<p>而且在 <span class="math inline">\(B\)</span>
圈之后每个轮胎跑一圈的秒数显然是递增的，也就是在 <span
class="math inline">\(\{1\}\cup[B+1,m]\)</span> 上一定递增。</p>
<p>所以在这种存在单调性的情况下，可以直接用前面的写法贪心，初始需要先假设所有轮胎都跑了
<span class="math inline">\(B\)</span> 圈。</p>
<p>但是 <span class="math inline">\(B\)</span> 圈之前的还需要处理。</p>
<p>预处理第 <span class="math inline">\(i\)</span> 个轮胎连跑 <span
class="math inline">\(j\)</span> 圈需要的秒数
（加上了前面说的换胎时间）。</p>
<p>将每个轮胎当成一组，组内放 <span class="math inline">\(B\)</span>
个，第 <span class="math inline">\(i\)</span> 组内第 <span
class="math inline">\(j\)</span> 个价值为 <span
class="math inline">\(f[i][j]\)</span>，跑 <span
class="math inline">\(01\)</span> 分组背包即可，不要忘了背包容量为 <span
class="math inline">\(n\times B\)</span> ，这是总圈数。</p>
<p>背包部分复杂度 <span
class="math inline">\(O(n^2t)\)</span>，贪心部分复杂度 <span
class="math inline">\(O(m\log n)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(n^2t+m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">505</span>)</span>,<span class="title">sqN</span><span class="params">(<span class="number">30</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> f[N][sqN],g[N*sqN],h[M];</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N],n,m,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;x,<span class="type">const</span> <span class="type">int</span>&amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a[x]+b[x]*c[x]*c[x]&gt;a[y]+b[y]*c[y]*c[y])||</span><br><span class="line">        (a[x]+b[x]*c[x]*c[x]==a[y]+b[y]*c[y]*c[y]&amp;&amp;x&gt;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,t);</span><br><span class="line">    <span class="type">int</span> B=<span class="built_in">sqrt</span>(t)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i],b[i]);</span><br><span class="line">        c[i]=B;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        f[i][<span class="number">1</span>]=a[i]+t;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">2</span>,B)&#123;</span><br><span class="line">            f[i][j]=f[i][j<span class="number">-1</span>]+a[i]+b[i]*(j<span class="number">-1</span>)*(j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        s=<span class="built_in">min</span>(m,s+B);</span><br><span class="line">        <span class="built_in">per</span>(j,s,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="built_in">min</span>(B,j))&#123;</span><br><span class="line">                g[j]=<span class="built_in">min</span>(g[j],g[j-k]+f[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        x=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]+a[x]+b[x]*c[x]*c[x];</span><br><span class="line">        c[x]++;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(s,m))&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,g[i]+h[m-i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans-t,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>背包</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8229</title>
    <url>/2023/12/02/P8229/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8229">[AGM 2022 资格赛]
抛硬币</a></p>
<span id="more"></span>
<p>设 <span class="math inline">\(g_i\)</span> 为抛 <span
class="math inline">\(i\)</span> 次硬币之后期望剩下的个数，<span
class="math inline">\(f_i\)</span> 为 <span
class="math inline">\(i\)</span> 次之后期望吃掉的个数。</p>
<p>容易写出式子： <span class="math display">\[
\begin{aligned}
&amp;g_i=kP\times g_{i-1}+1-P\\
&amp;f_i=f_{i-1}+(1-P)\times g_{i-1}
\end{aligned}
\]</span> 如果抛出正面，可以剩下 <span class="math inline">\(k\times
g_{i-1}\)</span>个，反面就剩 <span class="math inline">\(1\)</span>
个。</p>
<p>如果抛出正面，不会吃任何草莓，反面会吃 <span
class="math inline">\(g_{i-1}\)</span>个。</p>
<p><span class="math inline">\(n\)</span> 很大，考虑矩阵加速递推。</p>
<p>时间复杂度 <span class="math inline">\(O(T\times 27\log
n)\)</span>，可以通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll n,K,P;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123;</span><br><span class="line">    ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[i][j]=(i==j);</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="type">const</span> mat&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        mat c;c.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>)<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            c.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">            c.a[i][j]%=Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    mat ans,a,x;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(n,K,P);</span><br><span class="line">        ans.<span class="built_in">init</span>();</span><br><span class="line">        a.<span class="built_in">init</span>();</span><br><span class="line">        a.a[<span class="number">0</span>][<span class="number">0</span>]=P*K%Mod;</span><br><span class="line">        a.a[<span class="number">0</span>][<span class="number">1</span>]=a.a[<span class="number">2</span>][<span class="number">0</span>]=(<span class="number">1</span>-P+Mod)%Mod;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a;</span><br><span class="line">            a=a*a;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x.<span class="built_in">reset</span>();</span><br><span class="line">        x.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        ans=x*ans;</span><br><span class="line">        <span class="built_in">write</span>((ans.a[<span class="number">0</span>][<span class="number">0</span>]+ans.a[<span class="number">0</span>][<span class="number">1</span>])%Mod,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>P8321</title>
    <url>/2023/12/02/P8321/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8321">P8321
『JROI-4』沈阳大街 2</a></p>
<span id="more"></span>
<p>发现期望和这题几乎无关，从序列的性质入手。</p>
<p>看到数据范围，大概是一个 <span class="math inline">\(O(n^2)\)</span>
的DP。</p>
<p>对题目做一个比较精妙的转化：</p>
<p>将 <span class="math inline">\(A,B\)</span> 数组全部放进另一个数组
<span class="math inline">\(C\)</span> 内，对 <span
class="math inline">\(C\)</span> 从大到小排序。规定来自于 <span
class="math inline">\(A\)</span> 的数是红色，来自于 <span
class="math inline">\(B\)</span> 的数是蓝色；</p>
<p>因为是算全部排列的和，<span class="math inline">\(C\)</span>
可以排序。</p>
<p>那么算 <span class="math inline">\(f\)</span>
的过程事实上就是红蓝两种颜色相互匹配（只有不同颜色才能匹配），每一个红蓝对的权值是后面那个数（因为是从大到小排序），所有红蓝对的权值乘积。</p>
<p><span class="math inline">\(\sum f(\pi)\)</span>
也就变成所有完美匹配方式内部红蓝对乘积的和。</p>
<p>DP的时候要处理：当前位置是否作为后面的那个数，向前匹配红蓝对。</p>
<p>“权值是后面的数”是一个非常好的性质，这意味着我们DP的时候只需要知道当前值的大小。</p>
<p>可以设 <span class="math inline">\(f[i][j]\)</span> 为 <span
class="math inline">\(C\)</span> 中前 <span
class="math inline">\(i\)</span> 个数，匹配了 <span
class="math inline">\(j\)</span> 对的所有匹配方式贡献之和</p>
<p>可以写出如下转移式子： <span class="math display">\[
\begin{aligned}
f[i][j]=f[i-1][j]+f[i-1][j-1]\times c[i]\times (cnt-j+1)
\end{aligned}
\]</span> 这里 <span class="math inline">\(cnt\)</span>
设为中在前面和颜色不同的数字个数。</p>
<p>这非常好理解，我们可以不匹配，贡献为 <span
class="math inline">\(f[i-1][j]\)</span>；也可以匹配：在 <span
class="math inline">\(f[i-1][j-1]\)</span> 的状态下，<span
class="math inline">\(i\)</span> 的答案还没有算，一共还有 <span
class="math inline">\(cnt-(j-1)\)</span>
个没被匹配的，任选哪个匹配都可以，每一个匹配的对都要用 <span
class="math inline">\(c[i]\)</span> 做权值。</p>
<p>全部方案贡献之和为 <span class="math inline">\(f[2n][n]\)</span>
，不要忘了求的是期望，最终答案为 <span
class="math inline">\(\dfrac{f[2n][n]}{n!}\)</span></p>
<p>这样就做完了，时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5005</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,col;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N],sum[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*a%Mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        c[i]=(Node)&#123;a[i],<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        c[i+n]=(Node)&#123;b[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+n*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)&#123;</span><br><span class="line">        sum[<span class="number">0</span>][i]=sum[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        sum[<span class="number">1</span>][i]=sum[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">        sum[c[i].col][i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n*<span class="number">2</span>)f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n*<span class="number">2</span>)&#123;</span><br><span class="line">        cnt=sum[c[i].col^<span class="number">1</span>][i];</span><br><span class="line">        <span class="built_in">re</span>(j,<span class="built_in">min</span>(n,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=j)&#123;</span><br><span class="line">                f[i][j]=<span class="number">1ll</span>*f[i<span class="number">-1</span>][j<span class="number">-1</span>]*c[i].val%Mod*(cnt-j+<span class="number">1</span>)%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j]=(f[i<span class="number">-1</span>][j]+f[i][j])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ifac=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,n)ifac=<span class="number">1ll</span>*ifac*i%Mod;</span><br><span class="line">    ifac=<span class="built_in">qpow</span>(ifac,Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1ll</span>*f[n*<span class="number">2</span>][n]*ifac%Mod;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>P8600</title>
    <url>/2023/12/02/P8600/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8600">P8600 [蓝桥杯 2013
省 B] 连号区间数</a></p>
<span id="more"></span>
<p>比较经典的问题，比较经典的做法。</p>
<p>同类题：CF1175F</p>
<p>可以将问题转化为：</p>
<p>求区间 <span class="math inline">\([l,r]\)</span> 满足 <span
class="math inline">\(\max_{i=l}^rp_i-\min_{i=l}^rp_i=r-l\)</span>。</p>
<p>移项：<span
class="math inline">\(r=\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span>。</p>
<p>枚举 <span class="math inline">\(r\)</span>
考虑每个有多少个满足等式。</p>
<p>第一眼看上去不太好数 但可以注意到：</p>
<p><span
class="math inline">\(r\ge\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span>
一定成立。</p>
<p>也就是说 一个 <span class="math inline">\(r\)</span> 对应的 <span
class="math inline">\(l\)</span> 个数 是 <span
class="math inline">\(l\le r\)</span> 的所有 <span
class="math inline">\(\max_{i=l}^rp_i-\min_{i=l}^rp_i+l\)</span> 中的
最小值个数。</p>
<p>可以线段树维护。</p>
<p><span class="math inline">\(l\)</span> 这一项可以在建树时直接加上</p>
<p>问题在于 加入一个新的数的过程中 应该如何修改线段树中的 <span
class="math inline">\(\max\)</span> 和 <span
class="math inline">\(\min\)</span> 。</p>
<p>需要使用单调栈。</p>
<p>对于 <span class="math inline">\(\max\)</span> 来说，加入一个新的数
<span class="math inline">\(p_r\)</span> 时 如果单调栈需要弹出 <span
class="math inline">\(p_x\)</span> 弹出后栈顶为<span
class="math inline">\(p_y\)</span>。</p>
<p>也就是说 <span class="math inline">\(p_x\)</span>
不再是后缀最大值时，需要对 <span class="math inline">\([y+1,x]\)</span>
做修改： 加上 <span class="math inline">\(p_r\)</span> 再减掉之前加上的
<span class="math inline">\(p_x\)</span>。</p>
<p>对于 <span class="math inline">\(\min\)</span> 来说同理
都只是在做撤销/更新 而已。</p>
<p>枚举 <span class="math inline">\(r\)</span> 时，<span
class="math inline">\(Ans\)</span> 不断加上最小值个数。</p>
<p>显然复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> mn,lz,cnt;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    t[rt].mn=<span class="built_in">min</span>(t[<span class="built_in">ls</span>(rt)].mn,t[<span class="built_in">rs</span>(rt)].mn);</span><br><span class="line">    t[rt].cnt=t[<span class="built_in">ls</span>(rt)].cnt*(t[<span class="built_in">ls</span>(rt)].mn==t[rt].mn)+t[<span class="built_in">rs</span>(rt)].cnt*(t[<span class="built_in">rs</span>(rt)].mn==t[rt].mn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    t[rt].mn+=x;t[rt].lz+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].lz==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(rt),t[rt].lz);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(rt),t[rt].lz);</span><br><span class="line">    t[rt].lz=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">      t[rt].mn=l,t[rt].cnt=<span class="number">1</span>,t[rt].lz=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ml,<span class="type">int</span> mr,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=l&amp;&amp;r&lt;=mr)&#123;</span><br><span class="line">      <span class="built_in">update</span>(rt,x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ml&lt;=mid)<span class="built_in">modify</span>(<span class="built_in">ls</span>(rt),l,mid,ml,mr,x);</span><br><span class="line">    <span class="keyword">if</span>(mr&gt;mid)<span class="built_in">modify</span>(<span class="built_in">rs</span>(rt),mid+<span class="number">1</span>,r,ml,mr,x);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> st1[N],st2[N],tp1,tp2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">    x=i;</span><br><span class="line">    <span class="keyword">while</span>(tp1&amp;&amp;a[i]&gt;a[st1[tp1]])&#123;</span><br><span class="line">      t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,st1[tp1<span class="number">-1</span>]+<span class="number">1</span>,x<span class="number">-1</span>,a[i]-a[st1[tp1]]);</span><br><span class="line">      x=st1[tp1--];</span><br><span class="line">    &#125;</span><br><span class="line">    x=i;</span><br><span class="line">    <span class="keyword">while</span>(tp2&amp;&amp;a[i]&lt;a[st2[tp2]])&#123;</span><br><span class="line">      t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,st2[tp2<span class="number">-1</span>]+<span class="number">1</span>,x<span class="number">-1</span>,a[st2[tp2]]-a[i]);</span><br><span class="line">      x=st2[tp2--];</span><br><span class="line">    &#125;</span><br><span class="line">    st1[++tp1]=i;</span><br><span class="line">    st2[++tp2]=i;</span><br><span class="line">    ans+=t.t[<span class="number">1</span>].cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DSs</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P8945</title>
    <url>/2023/12/02/P8945/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8945">P8945
Inferno</a></p>
<span id="more"></span>
<p>值域为 <span class="math inline">\(\{-1,0,1\}\)</span> 的数组，在为
<span class="math inline">\(0\)</span> 的位置中选 <span
class="math inline">\(k\)</span> 个位置放 <span
class="math inline">\(1\)</span>，其余放 <span
class="math inline">\(-1\)</span>，求最大子段和。</p>
<p><span class="math inline">\(n\le 10^7\)</span>，<span
class="math inline">\(777ms\)</span>，需要线性做法。</p>
<p>首先，<span class="math inline">\(1\)</span> 肯定是放在一起，放 <span
class="math inline">\(1\)</span> 的位置之间不会放 <span
class="math inline">\(-1\)</span>。</p>
<p>考虑枚举最终成为最大子段的右端点 <span
class="math inline">\(r\)</span>。</p>
<p>显然，对于左端点 <span class="math inline">\(l\)</span>
的位置来说，本质上的区别在于：在 <span class="math inline">\(l\)</span>
到 <span class="math inline">\(r\)</span> 中是否有 <span
class="math inline">\(k\)</span> 个以上的 <span
class="math inline">\(0\)</span>。</p>
<p>分讨，设 <span class="math inline">\(0\)</span> 个数的前缀和为 <span
class="math inline">\(c\)</span>，原数组前缀和为 <span
class="math inline">\(s\)</span>。</p>
<p>当 <span class="math inline">\(c_r-c_{l-1}\le k\)</span> 时，和为
<span class="math inline">\(s_r-s_{l-1}+c_r-c_{l-1}\)</span>。</p>
<p>当 <span class="math inline">\(c_r-c_{l-1}&gt; k\)</span> 时，和为
<span class="math inline">\(s_r-s_{l-1}-c_r+c_{l-1}+2k\)</span>。</p>
<p>我们设前 <span class="math inline">\(i\)</span> 个数，<span
class="math inline">\(0\)</span> 都放上 <span
class="math inline">\(1\)</span> 之后的和为 <span
class="math inline">\(p\)</span>，<span class="math inline">\(0\)</span>
都放上 <span class="math inline">\(-1\)</span> 之后的和为 <span
class="math inline">\(q\)</span>。</p>
<p>现在上面两个式子就分别为 <span
class="math inline">\(p_r-p_{l-1}\)</span> 和 <span
class="math inline">\(q_r-q_{l-1}+2k\)</span>。</p>
<p>显然对于 <span class="math inline">\(c_r-c_{l-1}&gt;k\)</span>
的情况，<span class="math inline">\(l\)</span> 放的位置一定是 <span
class="math inline">\(r\)</span> 前面 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(0\)</span> 之前的前缀最小 <span
class="math inline">\(q\)</span>，这个可以扫的时候动态维护最右边的合法位置
<span class="math inline">\(pos\)</span> 和最小值。</p>
<p><span class="math inline">\(c_r-c_{l-1}\le k\)</span>
的情况用单调队列维护 <span class="math inline">\(r\)</span>
前面的一段合法区间最小值即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e7</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, k, a[N], p[N], q[N], c[N];</span><br><span class="line"><span class="type">int</span> que[N], fr, bk;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n, k);</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, pos = <span class="number">0</span>, mnpos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">re</span>(i, n) &#123;</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] + a[i] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    q[i] = q[i - <span class="number">1</span>] + a[i] - (a[i] == <span class="number">0</span>);</span><br><span class="line">    c[i] = c[i - <span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= bk &amp;&amp; c[i] - c[que[fr]] &gt;= k)fr++;</span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= bk &amp;&amp; p[i] &lt; p[que[bk]])bk--;</span><br><span class="line">    que[++bk] = i;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, p[i] - p[que[fr]]);</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt; k) &#123;</span><br><span class="line">      <span class="keyword">while</span> (c[i] - c[pos] &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[mnpos] &gt; q[pos])mnpos = pos;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, q[i] - q[mnpos] + <span class="number">2</span> * k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P9346</title>
    <url>/2023/12/02/P9346/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9346">P9346
无可奈何花落去</a></p>
<span id="more"></span>
<p>先翻译凋零的条件。</p>
<p>凋零的条件其实就是把这个树切成若干个链。</p>
<p>多步操作期望计算，考虑期望线性性。</p>
<p>期望持续的轮数，通过期望的线性性拆成经过每个非终止状态的期望次数之和。</p>
<p>本题中，树上所有边的每种状态只会经过一次；同时，非终止状态的任何前置状态都是非终止状态。所以有简单结论：如果一个非终止状态是删去了条边得到，那么经过该状态的期望次数为
<span class="math inline">\(\binom{n-1}{x}^{-1}\)</span>。</p>
<p>于是只需要求有多少种删去 <span class="math inline">\(x\)</span>
条边的未终止状态。未终止状态不好算，容斥转化为计数删去了 <span
class="math inline">\(x\)</span> 条边的终止状态，然后用 <span
class="math inline">\(\binom{n-1}{x}\)</span> 减去即可。</p>
<p>树形 DP，设 <span class="math inline">\(f[i][j][k]\)</span> 表示以
<span class="math inline">\(i\)</span> 为根的子树，保留 <span
class="math inline">\(j\)</span> 条边，根的度数为 <span
class="math inline">\(k\)</span> 的方案总数。容易得出 <span
class="math inline">\(k\in[0,2]\)</span>，则可以通过树上背包得到 <span
class="math inline">\(O(n^2)\)</span> 的复杂度。</p>
<p>写法都是比较经典的树上背包写法，DP式子就是乘法原理，<span
class="math inline">\(g\)</span> 数组只是一个 <span
class="math inline">\(temp\)</span> 数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">5e3</span>+<span class="number">5</span>)</span>,<span class="title">Mod</span><span class="params">(<span class="number">985661441</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,fa[N];</span><br><span class="line">ll f[N][N][<span class="number">3</span>],g[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=v;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N],finv[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%Mod;</span><br><span class="line">        a=a*a%Mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=finv[<span class="number">0</span>]=finv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    finv[n]=<span class="built_in">qpow</span>(fac[n],Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">2</span>)finv[i]=finv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*finv[m]%Mod*finv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">iC</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> finv[n]*fac[m]%Mod*fac[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">nx</span>(i,u)&#123;</span><br><span class="line">        v=e[i].to;</span><br><span class="line">        <span class="built_in">DP</span>(v);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,siz[u]<span class="number">-1</span>)<span class="built_in">rep</span>(p,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,siz[v]<span class="number">-1</span>)<span class="built_in">rep</span>(q,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                x=f[u][i][p]*f[v][j][q]%Mod;</span><br><span class="line">                g[i+j][p]+=x;</span><br><span class="line">                <span class="keyword">if</span>(p&lt;<span class="number">2</span>&amp;&amp;q&lt;<span class="number">2</span>)g[i+j+<span class="number">1</span>][p+<span class="number">1</span>]+=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,siz[u]+siz[v]<span class="number">-1</span>)<span class="built_in">rep</span>(p,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            f[u][i][p]=g[i][p]%Mod;</span><br><span class="line">            g[i][p]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CIOO;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">        <span class="built_in">ae</span>(fa[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">DP</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        x=(<span class="built_in">C</span>(n<span class="number">-1</span>,i)-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">0</span>]-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">1</span>]-f[<span class="number">1</span>][n-i<span class="number">-1</span>][<span class="number">2</span>])%Mod;</span><br><span class="line">        ans=(ans+<span class="built_in">iC</span>(n<span class="number">-1</span>,i)*x%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans+Mod)%Mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>组合</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>背包</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P9379</title>
    <url>/2023/12/02/P9379/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P9379">P9379 [THUPC 2023
决赛] 老虎机</a></p>
<span id="more"></span>
<p>比较难写的分步期望DP。</p>
<p>一个想法是对于每个字符串，求出我们必须要知道哪些位置才能确定是当前的字符串。</p>
<p>对于每一位，我们在操作过后有三种情况：已知是 <span
class="math inline">\(0\)</span>，已知是 <span
class="math inline">\(1\)</span>，未知（用 <span
class="math inline">\(2\)</span>
表示）。可以用一个三进制数表示当前状态。</p>
<p>对于某一个状态，如果其中有 <span class="math inline">\(2\)</span> 且
<span class="math inline">\(2\)</span> 换成 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span>
都不会出现两种不同字符串，那这个状态就是合法的。</p>
<p>因为先换哪个 <span class="math inline">\(2\)</span>
不影响对合法的判断，可以使用 lowbit 递推，每次找到最低位的 ，对将 <span
class="math inline">\(2\)</span> 换成 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 分类讨论，计算贡献。</p>
<p>对于一个字符串来说，只要到达了属于它的某个状态，就能够确定他。</p>
<p>每一位 知道或不知道 的状态可以用二进制数表示（以下所有 状态
都指这个状态）。</p>
<p>问题转化成到达这个状态的期望时间，发现操作之后再操作肯定还是合法的，于是容斥一步，考虑计算维持不合法的期望时间。</p>
<p>分别在每个不合法状态停留的期望时间 乘上 到达这个状态的概率
的和，就是在这个不合法状态停留的期望时间。</p>
<p>具体的，设 <span class="math inline">\(t\)</span> 为停留在状态 <span
class="math inline">\(S\)</span> 的期望时间，如果有 <span
class="math inline">\(P=\prod_{i\not\in S}(1-p_i)\)</span>，那么显然有
<span
class="math inline">\(t=\sum_{x=0}^{\infty}P^x=\frac{1}{1-P}\)</span>，而到达这个状态的概率和可以通过
DP 得出：设 <span class="math inline">\(F[s][i]\)</span> 为考虑前 <span
class="math inline">\(i\)</span> 位，到达状态 <span
class="math inline">\(s\)</span> 的概率，DP出来之后对 val 乘上 <span
class="math inline">\(t\)</span> 做贡献即可。</p>
<p>时间复杂度 <span class="math inline">\(O(3^l)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>,<span class="built_in">pwN</span>(<span class="number">14348912</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y,x&gt;=mod&amp;&amp;(x-=mod);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>,b=mod<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="built_in">mul</span>(a,a))&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="built_in">mul</span>(res,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pw3[<span class="number">20</span>],p[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> lowb[pwN],id[pwN],rev[pwN];</span><br><span class="line"><span class="type">int</span> val[N],F[N][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> L,n;cin&gt;&gt;L&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">        p[i]=<span class="built_in">mul</span>(<span class="built_in">inv</span>(<span class="number">10000</span>),p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line">    val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> update=[&amp;]()&#123;</span><br><span class="line">            <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)<span class="built_in">add</span>(F[s][i+<span class="number">1</span>],F[s][i]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">add</span>(F[s|(<span class="number">1</span>&lt;&lt;i)][i+<span class="number">1</span>],<span class="built_in">mul</span>(F[s][i],p[i]));</span><br><span class="line">                    <span class="built_in">add</span>(F[s][i+<span class="number">1</span>],<span class="built_in">mul</span>(F[s][i],<span class="number">1</span>+mod-p[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">        <span class="keyword">if</span>(s)val[s]=F[s][L];</span><br><span class="line">        <span class="keyword">else</span> val[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> P=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,L<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((~s)&gt;&gt;i&amp;<span class="number">1</span>)P=<span class="built_in">mul</span>(P,<span class="number">1</span>+mod-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">inv</span>(mod+<span class="number">1</span>-P);</span><br><span class="line">        <span class="built_in">memset</span>(F[s],<span class="number">0</span>,<span class="built_in">sizeof</span>(F[s]));</span><br><span class="line">        F[s][<span class="number">0</span>]=<span class="built_in">mul</span>(val[s],t);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">        val[s]=<span class="built_in">mul</span>(val[s],t);</span><br><span class="line">        <span class="built_in">add</span>(sum,val[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="built_in">sizeof</span>(id));</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        string s;cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">range</span>(s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:s)x=x*<span class="number">3</span>+p-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        id[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> U=(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s,<span class="number">0</span>,pw3[L]<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~lowb[s])&#123;</span><br><span class="line">            <span class="type">int</span> u=id[s-pw3[lowb[s]]],v=id[s-pw3[lowb[s]]*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">-1</span>||v==<span class="number">-1</span>||(u!=<span class="number">0</span>)&amp;&amp;(v!=<span class="number">0</span>))id[s]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> id[s]=u|v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id[s]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ans[id[s]],val[rev[s]^U]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        cout&lt;&lt;(sum+mod-ans[i])%mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pw3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,<span class="number">15</span>)pw3[i]=pw3[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,pw3[<span class="number">15</span>])&#123;</span><br><span class="line">        lowb[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,x=i;j&lt;<span class="number">15</span>;j++,x/=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>)&#123;lowb[i]=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(~lowb[i])&#123;</span><br><span class="line">            rev[i]=rev[i-pw3[lowb[i]]*<span class="number">2</span>]|<span class="number">1</span>&lt;&lt;lowb[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;cin&gt;&gt;T;<span class="keyword">while</span>(T--)<span class="built_in">Main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>随机过程与计数</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>U169078</title>
    <url>/2023/12/02/U169078/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/U169078">U169078
[NOI2021SDPT3Test4]图论题</a></p>
<span id="more"></span>
<p>不是主题库的题，感觉题挺好就写了题解。</p>
<p>题面：有向带权图，可以花费 <span
class="math inline">\((x-y)^2\)</span> 的代价从 <span
class="math inline">\(x\)</span> 走到 <span
class="math inline">\(y\)</span>，这个技能只能用一次，求 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的最短路，<span
class="math inline">\(|V|\le 2\times 10^5,|E|\le 4\times
10^5\)</span>。</p>
<p>看到题面，当然是最短路。</p>
<p>首先可以对题目做转化：我们走的是形如 <span class="math inline">\(s\to
u\to v\to t\)</span> 的一条路径，<span class="math inline">\(u\to
v\)</span> 是只使用技能的。</p>
<p>发现只需要求两个点之间的最短路，有一种对称性。</p>
<p>可以在正图和反图上跑两遍最短路，获得每个点到 <span
class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 的最短路 <span
class="math inline">\(d_1[u],d_2[u]\)</span>。</p>
<p>现在上面那条路径的长度也可以表示了：<span
class="math inline">\(d_1[u]+d_2[v]+(u-v)^2\)</span>，我们现在有了一个
<span class="math inline">\(O(n^2)\)</span> 枚举 <span
class="math inline">\(u,v\)</span> 的做法。</p>
<p>肯定需要一个更好的复杂度。</p>
<p>考虑枚举 <span
class="math inline">\(u\)</span>，思考<strong>当什么情况下，我们应该去选
<span class="math inline">\(v_1\)</span> 而不是 <span
class="math inline">\(v_2\)</span>。</strong></p>
<p>当然，肯定是走 <span class="math inline">\(v_1\)</span> 更短。</p>
<p>也就是：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;d_1[u]+d_2[v_1]+(u-v_1)^2&lt;d_1[u]+d_2[v_2]+(u-v_2)^2\\
&amp;d_2[v_1]+u^2-2uv_1+v_1^2&lt;d_2[v_2]+u^2-2uv_2+v_2^2\\
&amp;d_2[v_1]+v_1^2-2uv_1&lt;d_2[v_2]+v_2^2-2uv_2\\
&amp;(d_2[v_1]+v_1^2)-(d_2[v_2]+v_2^2)&lt;2uv_1-2uv_2
\end{aligned}
\]</span></p>
<p>发现这个式子的形式很好。</p>
<p>可以设 <span class="math inline">\(y[u]=d_2[u]+u^2\)</span></p>
<p>那么进一步就有：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;y[v_1]-y[v_2]&lt;2uv_1-2uv_2\\
&amp;y[v_1]-y[v_2]&lt;2u(v_1-v_2)\\
&amp;\frac{y[v_1]-y[v_2]}{v_1-v_2}&lt;2u
\end{aligned}
\]</span></p>
<p>如果把 <span class="math inline">\((v,y[v])\)</span>
看成点，就会获得一个更好的形式：斜率。</p>
<p>我们一直在对式子做等价的变换，显然 <span
class="math inline">\(\frac{y[v_1]-y[v_2]}{v_1-v_2}&lt;2u\)</span> 和
<span class="math inline">\(v_1\)</span> 比 <span
class="math inline">\(v_2\)</span> 更优 是互为充要条件的。</p>
<p>题目被简化，只需要用单调队列先求一遍下凸壳，在这个斜率单调递增的凸壳上用指针维护当前最后一个斜率
<span class="math inline">\(&lt;2u\)</span> 的位置即可，这个位置对于
<span class="math inline">\(u\)</span> 来说就是最优的。</p>
<p>为什么只需要下凸壳上的点？我们可以将所有的斜率看做一种偏序关系，简单分讨可得，不在下凸壳上的点，一定不如在他两边凸壳上的点优。</p>
<p>为什么找最后一个斜率的位置是对的？因为在满足斜率的时候向后走，是在做一个“递推”（<span
class="math inline">\(v_2\)</span> 比 <span
class="math inline">\(v_1\)</span> 优，<span
class="math inline">\(v_3\)</span> 比 <span
class="math inline">\(v_2\)</span> 优，<span
class="math inline">\(v_4\)</span> 比 <span
class="math inline">\(v_3\)</span>
优……），每一个都比上一个更优，直到不满足的时候，这条递推关系就断了，答案会变得更劣。</p>
<p>现在来考虑：如果从到枚举，会发现是递增的，那么匹配到的最优位置也显然是单调不降的，所以在处理好的下凸壳上扫一遍就做完了。</p>
<p>注：如果枚举的“目标斜率” <span class="math inline">\(2u\)</span> 没有
与凸壳单调性相同 的性质，就需要写二分。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">2e5</span>+<span class="number">5</span>)</span>,<span class="title">M</span><span class="params">(<span class="number">4e5</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line">vector&lt;pii&gt; G[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; pli;</span><br><span class="line">priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt; pq;</span><br><span class="line">ll dis[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">re</span>(i,n)dis[o][i]=INF;</span><br><span class="line">    dis[o][u]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">mkp</span>(<span class="number">0</span>,u));</span><br><span class="line">    pli tp;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        tp=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tp.fi!=dis[o][tp.se])<span class="keyword">continue</span>;</span><br><span class="line">        u=tp.se;</span><br><span class="line">        <span class="built_in">each</span>(v,G[o][u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[o][v.fi]&gt;dis[o][u]+v.se)&#123;</span><br><span class="line">                dis[o][v.fi]=dis[o][u]+v.se;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">mkp</span>(dis[o][v.fi],v.fi));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">ll y[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s,t);</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">re</span>(i,m)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        G[<span class="number">0</span>][u].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(v,w));</span><br><span class="line">        G[<span class="number">1</span>][v].<span class="built_in">pb</span>(<span class="built_in">mkp</span>(u,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">0</span>,s);</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">1</span>,t);</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        y[i]=dis[<span class="number">1</span>][i]+<span class="number">1ll</span>*i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)q.<span class="built_in">pb</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> siz=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">3</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;(__int128)(y[q.<span class="built_in">back</span>()]-y[q[q.<span class="built_in">size</span>()<span class="number">-2</span>]])*(i-q.<span class="built_in">back</span>())&gt;=(__int128)(y[i]-y[q.<span class="built_in">back</span>()])*(q.<span class="built_in">back</span>()-q[q.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="built_in">re</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;q.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;(y[q[now+<span class="number">1</span>]]-y[q[now]])&lt;<span class="number">2ll</span>*i*(q[now+<span class="number">1</span>]-q[now]))&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][q[now]]+<span class="number">1ll</span>*(i-q[now])*(i-q[now]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>GraphTA</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
</search>
